<network>
<node body="" id="1" linkTypes="3 3 3 3 2 3 3" links="2 3 4 5 6 7 8" title="LeoDocs" />
<node body="For instruction about installing Leo see: &lt;br&gt; http://leoeditor.com/installing.html &lt;br&gt;  &lt;br&gt; For everything a beginner needs to know about Leo see: &lt;br&gt; http://leoeditor.com/tutorial.html &lt;br&gt;  &lt;br&gt; For help, please ask questions at: &lt;br&gt; http://groups.google.com/group/leo-editor &lt;br&gt; " id="2" linkTypes="1" links="1" title="** Read me first **" />
<node body="This section contains settings for this file. &lt;br&gt;  &lt;br&gt; It also contains other information of little interest to most Leo users." id="3" linkTypes="3 3 3 3" links="9 10 11 12" title="Startup" />
<node body="This section contains files used to generate Leo's web site, &lt;br&gt; including Leo's home page. &lt;br&gt; " id="4" linkTypes="3 3 3 3 3 3 3 3" links="13 14 15 16 17 18 19 20" title="Web pages" />
<node body="@pagewidth 70 &lt;br&gt; @tabwidth -4 &lt;br&gt;  &lt;br&gt; These are the sources for Leo's users guide. &lt;br&gt;  &lt;br&gt; They contain sphinx markup. See:: &lt;br&gt;  &lt;br&gt;     http://sphinx.pocoo.org/ &lt;br&gt;     http://docutils.sourceforge.net/docs/user/rst/quickstart.html &lt;br&gt;      &lt;br&gt; To generate these docs:: &lt;br&gt;  &lt;br&gt;     cd leo/doc/html &lt;br&gt;     make html &lt;br&gt;      &lt;br&gt; Important files: &lt;br&gt;  &lt;br&gt; - doc\html\conf.py contains settings, including the name of the master toctree &lt;br&gt;   document, leo_toc.html.txt. &lt;br&gt;  &lt;br&gt; - leo_toc.html.txt contains a list of all file to be included. &lt;br&gt; " id="5" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3" links="21 22 23 24 25 26 27 28 29 30 31 32 33" title="Leo's Documentation" />
<node body="" id="6" linkTypes="3 3 3" links="34 35 36" title="What's new in Leo 5.3" />
<node body="Leo 5.3-final May 2, 2016 &lt;br&gt;  &lt;br&gt; [Leo](http://leoeditor.com/) 5.3-final is now available on [SourceForge](http://sourceforge.net/projects/leo/files/Leo/). Leo is a PIM, an IDE and an outliner. &lt;br&gt;  &lt;br&gt; **The highlights of Leo 5.3** &lt;br&gt;  &lt;br&gt; - Leo now supports Jupyter Notebook (.ipynb) files. &lt;br&gt; - @chapter is now allowed anywhere. No need for @chapters. &lt;br&gt; - Faster spell checking. &lt;br&gt; - The rst3 command supports @rst-table. &lt;br&gt; - The show-invisibles command now uses native Qt characters. &lt;br&gt; - Dozens of other improvements and bug fixes. &lt;br&gt;  &lt;br&gt; **Leo is**: &lt;br&gt;  &lt;br&gt; - An outliner. Everything in Leo is an outline. &lt;br&gt; - A Personal Information Manager. &lt;br&gt; - A browser with a memory. &lt;br&gt; - A powerful scripting environment. &lt;br&gt; - A tool for studying other people's code. &lt;br&gt; - A fully-featured IDE, with emacs-like commands. &lt;br&gt; - Extensible via a simple plugin architecture. &lt;br&gt; - A tool that plays well with  IPython, vim and xemacs. &lt;br&gt; - Written in 100% pure Python &lt;br&gt; - Compatible with Python 2.6 and above or Python 3.0 and above. &lt;br&gt; - A tool with an inspiring and active community. &lt;br&gt;  &lt;br&gt; **Leo's unique features**: &lt;br&gt;      &lt;br&gt; - Always-present, persistent, outline structure. &lt;br&gt; - Leo's underlying data is a Directed Acyclic Graph. &lt;br&gt; - Clones create multiple views of an outline. &lt;br&gt; - A simple, powerful, outline-oriented Python API. &lt;br&gt; - Scripts and programs can be composed from outlines. &lt;br&gt; - Importers convert flat text into outlines. &lt;br&gt; - Scripts have full access to all of Leo's sources. &lt;br&gt; - Commands that act on outline structure. &lt;br&gt;   Example: the rst3 command converts outlines to reStructuredText. &lt;br&gt; - @test and @suite scripts create unit tests automatically. &lt;br&gt; - @button scripts apply scripts to outline data. &lt;br&gt; - Outline-oriented directives. &lt;br&gt;  &lt;br&gt; Simulating these features in vim, Emacs or Eclisps is possible, &lt;br&gt; just as it is possible to simulate Python in assembly language... &lt;br&gt;  &lt;br&gt; **Links** &lt;br&gt;  &lt;br&gt; - [Leo's home page](http://leoeditor.com) &lt;br&gt; - [Documentation](http://leoeditor.com/leo_toc.html) &lt;br&gt; - [Tutorials](http://leoeditor.com/tutorial.html) &lt;br&gt; - [Video tutorials](http://leoeditor.com/screencasts.html) &lt;br&gt; - [Forum](http://groups.google.com/group/leo-editor) &lt;br&gt; - [Download](http://sourceforge.net/projects/leo/files/) &lt;br&gt; - [Leo on Github](https://github.com/leo-editor/leo-editor) &lt;br&gt; - [What people are saying about Leo](http://leoeditor.com/testimonials.html) &lt;br&gt; - [A web page that displays .leo files](http://leoeditor.com/load-leo.html) &lt;br&gt; - [More links](http://leoeditor.com/leoLinks.html) &lt;br&gt; " id="7" linkTypes="3 3 3 3" links="37 38 39 40" title="Leo 5.3 release notes" />
<node body="The docs. might need tweaking to mention that while the above describes &lt;br&gt; how Leo searches for existing settings, if you attempt to open (through &lt;br&gt; the Settings menu) myLeoSettings.leo when it doesn't exist, it's &lt;br&gt; automagically created with a copy of @enabled-plugins from &lt;br&gt; leoSettings.leo. " id="8" linkTypes="1" links="1" title="** update myLeoSettings.leo docs" />
<node body="" id="9" linkTypes="3 3 3 3 3 3 3 3 3 3" links="41 42 43 44 45 46 47 48 49 50" title="@settings" />
<node body="@language python &lt;br&gt;  &lt;br&gt; " id="10" linkTypes="3 3 3 3 3 3" links="51 52 53 54 55 56" title="Buttons" />
<node body="@language python &lt;br&gt; " id="11" linkTypes="3 3 3 3" links="57 58 59 60" title="Scripts" />
<node body="" id="12" linkTypes="3 3 3 3" links="61 62 63 64" title="To do" />
<node body="@language rest &lt;br&gt; @tabwidth -4 &lt;br&gt; @others &lt;br&gt;  &lt;br&gt; .. Warning: this node is ignored when writing this file. &lt;br&gt; .. However, @ @rst-options are recognized in this node. &lt;br&gt; " id="13" linkTypes="3 3 3" links="65 66 67" title="@auto-rst treecaching.txt" />
<node body="@language python &lt;br&gt; # -*- coding: utf-8 -*- &lt;br&gt; # &lt;br&gt; # Leo documentation documentation build configuration file, created by &lt;br&gt; # sphinx-quickstart on Mon Mar 30 16:39:02 2009. &lt;br&gt; # &lt;br&gt; # This file is execfile()d with the current directory set to its containing dir. &lt;br&gt; # &lt;br&gt; # Note that not all possible configuration values are present in this &lt;br&gt; # autogenerated file. &lt;br&gt; # &lt;br&gt; # All configuration values have a default; values that are commented out &lt;br&gt; # serve to show the default. &lt;br&gt;  &lt;br&gt; # 2014/02/14: -----&gt; Replaced cr/lf by lf. &lt;br&gt;  &lt;br&gt; import sys, os &lt;br&gt;  &lt;br&gt; # If extensions (or modules to document with autodoc) are in another directory, &lt;br&gt; # add these directories to sys.path here. If the directory is relative to the &lt;br&gt; # documentation root, use os.path.abspath to make it absolute, like shown here. &lt;br&gt; #sys.path.append(os.path.abspath('.')) &lt;br&gt;  &lt;br&gt; # -- General configuration ----------------------------------------------------- &lt;br&gt;  &lt;br&gt; # Add any Sphinx extension module names here, as strings. They can be extensions &lt;br&gt; # coming with Sphinx (named 'sphinx.ext.*') or your custom ones. &lt;br&gt; extensions = [] &lt;br&gt;  &lt;br&gt; # Add any paths that contain templates here, relative to this directory. &lt;br&gt; templates_path = ['_templates'] &lt;br&gt;  &lt;br&gt; # The suffix of source filenames. &lt;br&gt; source_suffix = '.html.txt' &lt;br&gt;  &lt;br&gt; # The encoding of source files. &lt;br&gt; #source_encoding = 'utf-8' &lt;br&gt;  &lt;br&gt; # The master toctree document. &lt;br&gt; master_doc = 'leo_toc' # don't use any suffix. &lt;br&gt;  &lt;br&gt; # General information about the project. &lt;br&gt; project = 'Leo' &lt;br&gt;  &lt;br&gt; copyright = '2016, Edward K. Ream' &lt;br&gt;  &lt;br&gt; # The version info for the project you're documenting, acts as replacement for &lt;br&gt; # |version| and |release|, also used in various other places throughout the &lt;br&gt; # built documents. &lt;br&gt; # &lt;br&gt; # The short X.Y version. &lt;br&gt; version = '5.3' &lt;br&gt; # The full version, including alpha/beta/rc tags. &lt;br&gt; release = '5.3' # Using the short version is simplest and good. &lt;br&gt;  &lt;br&gt; # The language for content autogenerated by Sphinx. Refer to documentation &lt;br&gt; # for a list of supported languages. &lt;br&gt; #language = None &lt;br&gt;  &lt;br&gt; # There are two options for replacing |today|: either, you set today to some &lt;br&gt; # non-false value, then it is used: &lt;br&gt; #today = '' &lt;br&gt; # Else, today_fmt is used as the format for a strftime call. &lt;br&gt; #today_fmt = '%B %d, %Y' &lt;br&gt;  &lt;br&gt; # List of documents that shouldn't be included in the build. &lt;br&gt; #unused_docs = [] &lt;br&gt;  &lt;br&gt; # List of directories, relative to source directory, that shouldn't be searched &lt;br&gt; # for source files. &lt;br&gt; exclude_trees = ['_build'] &lt;br&gt;  &lt;br&gt; # The reST default role (used for this markup: `text`) to use for all documents. &lt;br&gt; #default_role = None &lt;br&gt;  &lt;br&gt; # If true, '()' will be appended to :func: etc. cross-reference text. &lt;br&gt; #add_function_parentheses = True &lt;br&gt;  &lt;br&gt; # If true, the current module name will be prepended to all description &lt;br&gt; # unit titles (such as .. function::). &lt;br&gt; #add_module_names = True &lt;br&gt;  &lt;br&gt; # If true, sectionauthor and moduleauthor directives will be shown in the &lt;br&gt; # output. They are ignored by default. &lt;br&gt; #show_authors = False &lt;br&gt;  &lt;br&gt; # The name of the Pygments (syntax highlighting) style to use. &lt;br&gt; pygments_style = 'sphinx' &lt;br&gt;  &lt;br&gt; # A list of ignored prefixes for module index sorting. &lt;br&gt; #modindex_common_prefix = [] &lt;br&gt;  &lt;br&gt;  &lt;br&gt; # -- Options for HTML output --------------------------------------------------- &lt;br&gt;  &lt;br&gt; # The theme to use for HTML and HTML Help pages.  Major themes that come with &lt;br&gt; # Sphinx are currently 'default' and 'sphinxdoc'. &lt;br&gt; html_theme = 'classic' &lt;br&gt;  &lt;br&gt; # Theme options are theme-specific and customize the look and feel of a theme &lt;br&gt; # further.  For a list of options available for each theme, see the &lt;br&gt; # documentation. &lt;br&gt; html_theme_options = { &lt;br&gt;  &lt;br&gt;     'collapsiblesidebar': True, &lt;br&gt;  &lt;br&gt; 	#  footerbgcolor (CSS color): Background color for the footer line. &lt;br&gt; 	#  footertextcolor (CSS color): Text color for the footer line. &lt;br&gt; 	#  sidebarbgcolor (CSS color): Background color for the sidebar. &lt;br&gt; 	'sidebarbgcolor': &quot;#fffdbc&quot;, # typical yellow.  &lt;br&gt;     ## 'sidebarbgcolor': &quot;#cbf5b1&quot;, # 203,245,177 # green1 harsh &lt;br&gt;     ##'sidebarbgcolor': &quot;#e2fad3&quot;, # 226, 250, 211 # green2 &lt;br&gt; 	#  sidebartextcolor (CSS color): Text color for the sidebar. &lt;br&gt; 	'sidebartextcolor': 'black', &lt;br&gt; 	#  sidebarlinkcolor (CSS color): Link color for the sidebar. &lt;br&gt; 	'sidebarlinkcolor': 'black', &lt;br&gt; 	#  relbarbgcolor (CSS color): Background color for the relation bar. &lt;br&gt; 	#  relbartextcolor (CSS color): Text color for the relation bar. &lt;br&gt; 	#  relbarlinkcolor (CSS color): Link color for the relation bar. &lt;br&gt; 	#  bgcolor (CSS color): Body background color. &lt;br&gt; 	'bgcolor': &quot;#fffbdc&quot;, # r = 256, g = 253, b = 220 &lt;br&gt;  &lt;br&gt; 	#  textcolor (CSS color): Body text color. &lt;br&gt; 	#  linkcolor (CSS color): Body link color. &lt;br&gt; 	#  headbgcolor (CSS color): Background color for headings. &lt;br&gt; 	#  headtextcolor (CSS color): Text color for headings. &lt;br&gt; 	#  headlinkcolor (CSS color): Link color for headings. &lt;br&gt; 	#  codebgcolor (CSS color): Background color for code blocks. &lt;br&gt; 	#  codetextcolor (CSS color): Default text color for code blocks, if not set differently by the highlighting style. &lt;br&gt; 	#  bodyfont (CSS font-family): Font for normal text. &lt;br&gt; 	#  headfont (CSS font-family): Font for headings. &lt;br&gt; } &lt;br&gt;  &lt;br&gt; # Add any paths that contain custom themes here, relative to this directory. &lt;br&gt; #html_theme_path = [&quot;_themes&quot;] &lt;br&gt;  &lt;br&gt; # The name for this set of Sphinx documents.  If None, it defaults to &lt;br&gt; # &quot;&lt;project&gt; v&lt;release&gt; documentation&quot;. &lt;br&gt; #html_title = None &lt;br&gt;  &lt;br&gt; # A shorter title for the navigation bar.  Default is the same as html_title. &lt;br&gt; #html_short_title = None &lt;br&gt;  &lt;br&gt; # The name of an image file (relative to this directory) to place at the top &lt;br&gt; # of the sidebar. &lt;br&gt; #html_logo = None &lt;br&gt; html_logo = 'Leo4-80-border.jpg' &lt;br&gt;  &lt;br&gt; # The name of an image file (within the static path) to use as favicon of the &lt;br&gt; # docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32 &lt;br&gt; # pixels large. &lt;br&gt; #html_favicon = None &lt;br&gt;  &lt;br&gt; # Add any paths that contain custom static files (such as style sheets) here, &lt;br&gt; # relative to this directory. They are copied after the builtin static files, &lt;br&gt; # so a file named &quot;default.css&quot; will overwrite the builtin &quot;default.css&quot;. &lt;br&gt; html_static_path = ['_static'] &lt;br&gt;  &lt;br&gt; # If not '', a 'Last updated on:' timestamp is inserted at every page bottom, &lt;br&gt; # using the given strftime format. &lt;br&gt; html_last_updated_fmt = '%b %d, %Y' &lt;br&gt;  &lt;br&gt; # If true, SmartyPants will be used to convert quotes and dashes to &lt;br&gt; # typographically correct entities. &lt;br&gt; html_use_smartypants = True &lt;br&gt;  &lt;br&gt; # Custom sidebar templates, maps document names to template names. &lt;br&gt; ## html_sidebars = {'FAQ':'noSideBar.txt'} ### raises TemplateNotFound exception. &lt;br&gt;  &lt;br&gt;     # * localtoc.html – a fine-grained table of contents of the current document &lt;br&gt;     # * globaltoc.html – a coarse-grained table of contents for the whole documentation set, collapsed &lt;br&gt;     # * relations.html – two links to the previous and next documents &lt;br&gt;     # * sourcelink.html – a link to the source of the current document, if enabled in html_show_sourcelink &lt;br&gt;     # * searchbox.html – the “quick search” box &lt;br&gt;  &lt;br&gt; html_sidebars = { &lt;br&gt;    '**': ['relations.html','searchbox.html',]  &lt;br&gt;    # 'localtoc.html', &lt;br&gt;    # 'globaltoc.html', &lt;br&gt;    # 'sourcelink.html', &lt;br&gt; } &lt;br&gt;  &lt;br&gt; # Additional templates that should be rendered to pages, maps page names to &lt;br&gt; # template names. &lt;br&gt; #html_additional_pages = {} &lt;br&gt;  &lt;br&gt; # If false, no module index is generated. &lt;br&gt; html_use_modindex = False &lt;br&gt;  &lt;br&gt; # If false, no index is generated. &lt;br&gt; html_use_index = True &lt;br&gt;  &lt;br&gt; # If true, the index is split into individual pages for each letter. &lt;br&gt; html_split_index = False &lt;br&gt;  &lt;br&gt; # If true, links to the reST sources are added to the pages. &lt;br&gt; html_show_sourcelink = False &lt;br&gt;  &lt;br&gt; # If true, an OpenSearch description file will be output, and all pages will &lt;br&gt; # contain a &lt;link&gt; tag referring to it.  The value of this option must be the &lt;br&gt; # base URL from which the finished HTML is served. &lt;br&gt; html_use_opensearch = '' &lt;br&gt;  &lt;br&gt; # If nonempty, this is the file name suffix for HTML files (e.g. &quot;.xhtml&quot;). &lt;br&gt; #html_file_suffix = '' &lt;br&gt;  &lt;br&gt; # Output file base name for HTML help builder. &lt;br&gt; htmlhelp_basename = 'Leodoc' &lt;br&gt;  &lt;br&gt;  &lt;br&gt; # -- Options for LaTeX output -------------------------------------------------- &lt;br&gt;  &lt;br&gt; # The paper size ('letter' or 'a4'). &lt;br&gt; latex_paper_size = 'a4' &lt;br&gt;  &lt;br&gt; # The font size ('10pt', '11pt' or '12pt'). &lt;br&gt; #latex_font_size = '10pt' &lt;br&gt;  &lt;br&gt; # Grouping the document tree into LaTeX files. List of tuples &lt;br&gt; # tex_documents(source start file, target name, title, author, documentclass [howto/manual]). &lt;br&gt; latex_documents = [ &lt;br&gt;   ('leo_toc', 'Leodocumentation.tex', 'Leo', &lt;br&gt;    'Edward K. Ream', 'manual'), &lt;br&gt; ] &lt;br&gt;  &lt;br&gt; # The name of an image file (relative to this directory) to place at the top of &lt;br&gt; # the title page. &lt;br&gt; #latex_logo = None &lt;br&gt;  &lt;br&gt; # For &quot;manual&quot; documents, if this is true, then toplevel headings are parts, &lt;br&gt; # not chapters. &lt;br&gt; #latex_use_parts = False &lt;br&gt;  &lt;br&gt; # Additional stuff for the LaTeX preamble. &lt;br&gt; #latex_preamble = '' &lt;br&gt;  &lt;br&gt; # Documents to append as an appendix to all manuals. &lt;br&gt; #latex_appendices = [] &lt;br&gt;  &lt;br&gt; # If false, no module index is generated. &lt;br&gt; latex_use_modindex = False &lt;br&gt; " id="14" linkTypes="1" links="4" title="@edit html\conf.py" />
<node body="@language python &lt;br&gt;  &lt;br&gt; &lt;&lt; docstring &gt;&gt; &lt;br&gt; &lt;&lt; imports &gt;&gt; &lt;br&gt;  &lt;br&gt; @others &lt;br&gt;  &lt;br&gt; if __name__ == &quot;__main__&quot;: &lt;br&gt;     if ok: &lt;br&gt;         main() &lt;br&gt; " id="15" linkTypes="3 3 3 3 3" links="68 69 70 71 72" title="@file plugin_catalog.py" />
<node body="http://www.greygreen.org/tmp/plugins.html" id="16" linkTypes="1" links="4" title="@url docs generated from plugin_catalog.py" />
<node body="" id="17" linkTypes="3" links="73" title="Home page" />
<node body="" id="18" linkTypes="3" links="74" title="Slideshows" />
<node body="Leo uses a TOC that *looks* like a Sphinx toc but is built by hand." id="19" linkTypes="3" links="75" title="TOC" />
<node body="@nocolor-node &lt;br&gt;  &lt;br&gt; {{Infobox software &lt;br&gt; | name = Leo: Leonine Editor with Outlines &lt;br&gt; | screenshot = [http://sourceforge.net/project/screenshots.php?group_id=3458&amp;ssid=22298 Screenshots] &lt;br&gt; | caption = &lt;br&gt; | developer = Edward K. Ream &lt;br&gt; | latest_release_version = 5.3 &lt;br&gt; | latest_release_date = {{release date and age|2016|04|02}} &lt;br&gt; | operating_system = [[Cross-platform]] &lt;br&gt; | genre = [[Text editor]], [[Outliner]], [[Integrated development environment|IDE]] &lt;br&gt; | license = [[Python (programming language)|Python]] License &lt;br&gt; | website = http://leoeditor.com &lt;br&gt; }} &lt;br&gt;  &lt;br&gt; '''Leo''' ('''L'''eonine '''E'''ditor with '''O'''utlines) is a [[text editor]] &lt;br&gt; that features [[outliner|outlines]] with clones as its central tool of &lt;br&gt; organization, navigation, customization and scripting. &lt;br&gt;  &lt;br&gt; ==Language== &lt;br&gt;  &lt;br&gt; Leo is written in [[Python (programming language)|Python]] and uses the [[Qt &lt;br&gt; (toolkit)|Qt]]. It is fully scriptable using Python and can be extended with &lt;br&gt; plugins. In Leo, outlines are hierarchical data structures that people use to &lt;br&gt; work with and manage text files—including code. &lt;br&gt;  &lt;br&gt; ==Trees, clones and views== &lt;br&gt;  &lt;br&gt; Leo is an [[outliner]]. Leo's outline pane shows a [[tree (data structure)]] of data nodes. &lt;br&gt; Nodes contain headlines, body text, and other information. &lt;br&gt; Headlines naturally serve as descriptions of the body text. &lt;br&gt; For example, @file nodes are nodes whose headline starts with @file. &lt;br&gt;  &lt;br&gt; Leo trees are in fact [[directed acyclic graph|directed acyclic graphs]]; &lt;br&gt; nodes may have more than one parent. &lt;br&gt; Leo calls such nodes clones. &lt;br&gt; Clones appear in several places in the outline pane. &lt;br&gt;  &lt;br&gt; Views are simply nodes whose children contain clones. A single outline may contain &lt;br&gt; arbitrarily many views of the nodes contained therein. &lt;br&gt; Views and clones turn Leo into a supremely flexible filing cabinet: any node may be filed &lt;br&gt; in arbitrarily many places. &lt;br&gt; &lt;ref&gt;[http://leoeditor.com/nutshell.html Leo documentation: Leo in a Nutshell]&lt;/ref&gt; &lt;br&gt;  &lt;br&gt; ==External files== &lt;br&gt;  &lt;br&gt; @file nodes represent external files, files on the computer's file system. &lt;br&gt; When saving an outline Leo automatically writes all changed @file &lt;br&gt; trees back to the external files. &lt;br&gt; Comments, called sentinel lines, in external files represent the outline structure. &lt;br&gt; When reading an outline, these comments allows Leo to recreate &lt;br&gt; @file trees using only the data in the external file. &lt;br&gt;  &lt;br&gt; @auto nodes represent external files without using sentinel comments. &lt;br&gt; When reading @auto nodes, Leo uses the program structure of the external file &lt;br&gt; to create the @auto tree. &lt;br&gt;  &lt;br&gt; ==Scripting== &lt;br&gt;  &lt;br&gt; Leo's scripting environment takes full advantage of outline structure: &lt;br&gt;  &lt;br&gt; * The body text of any node may contain a Leo script, a Python script executed in the context of a Leo outline. &lt;br&gt;  &lt;br&gt; * A simple [[API]] &lt;ref&gt;[http://leoeditor.com/scripting.html Leo documentation: Scripting Leo with Python]&lt;/ref&gt; gives Leo scripts full access to all data in loaded outlines, as well as full access to Leo's own source code. The API includes Python [[iterators]] that allow scripts to traverse outlines easily. &lt;br&gt;  &lt;br&gt; * Scripts may be composed of any tree of nodes. &lt;br&gt;   A [[markup language]] similar to [[noweb]] &lt;ref&gt;[http://leoeditor.com/tutorial.html#section-references Leo documentation: Tutorial]&lt;/ref&gt; tells Leo how to create scripts from (parts of) an outline. &lt;br&gt;  &lt;br&gt; * Headlines naturally control and guide scripts. &lt;br&gt;  &lt;br&gt; ** @test nodes represent unit tests. Leo can execute the body of an @test node as unit test, without the body having to create an explicit subclass of Python's UnitTest.TestCase class. &lt;ref&gt;[ &lt;br&gt;  &lt;br&gt; ** @button nodes contain scripts that can be applied to other nodes.  In effect, @button nodes create user-defined commands. &lt;ref&gt; &lt;br&gt;  &lt;br&gt; ==External links== &lt;br&gt; {{Portal|Free software}} &lt;br&gt; *[http://leoeditor.com Leo's homepage] &lt;br&gt; *[http://sourceforge.net/projects/leo/ Leo at SourceForge],[http://sourceforge.net/project/screenshots.php?group_id=3458&amp;ssid=22298 screenshots] &lt;br&gt; *[http://groups.google.com/group/leo-editor leo-editor Google Group] &lt;br&gt; *{{cite web | title=Literate Programming and Leo | publisher = [[Slashdot]] | date=2002-08-28 | url=http://developers.slashdot.org/article.pl?sid=02/08/28/1655207 }} &lt;br&gt; *{{cite web |author=[[James Tauber]] |title=Using the Leo Outliner as a PIM | date=2004-05-15 |url=http://jtauber.com/blog/2004/05/15/using_the_leo_outliner_as_a_pim/ }} &lt;br&gt; *{{cite book | author = Vreda Pieterse, Derrick G. Kourie, Andrew Boake | title=ACM International Conference Proceeding Series; Vol. 75. Proceedings of the 2004 annual research conference of the South African institute of computer scientists and information technologists on IT research in developing countries | chapter=A case for contemporary literate programming | editor=[[Association for Computing Machinery|ACM]] | pages=2–9 | url=http://portal.acm.org/citation.cfm?id=1035054}} (cited in references) &lt;br&gt;  &lt;br&gt; ==References== &lt;br&gt; &lt;references/&gt; &lt;br&gt;  &lt;br&gt; {{DEFAULTSORT:Leo (Text Editor)}} &lt;br&gt; [[Category:Free text editors]] &lt;br&gt; [[Category:Free software programmed in Python]] &lt;br&gt; [[Category:Outliners]] &lt;br&gt; " id="20" linkTypes="1" links="4" title="wikipedia entry" />
<node body="" id="21" linkTypes="3 3 3 3" links="76 77 78 79" title="Additonal web pages" />
<node body="" id="22" linkTypes="3 3" links="80 81" title="How to..." />
<node body="" id="23" linkTypes="3 3 3 3 3" links="82 83 84 85 86" title="Preliminaries" />
<node body="" id="24" linkTypes="3 3 3 3" links="87 88 89 90" title="Installing &amp; running Leo" />
<node body="" id="25" linkTypes="3" links="91" title="FAQ" />
<node body="" id="26" linkTypes="3 3 3 3 3 3" links="92 93 94 95 96 97" title="Tutorials" />
<node body="Do *not* nest any @rst nodes." id="27" linkTypes="3 3 3 3 3 3" links="98 99 100 101 102 103" title="Users Guide" />
<node body="" id="28" linkTypes="3 3 3 3 3 3" links="104 105 106 107 108 109" title="Leo and Other Programs" />
<node body="" id="29" linkTypes="3 3 3 3 3 3 3 3 3" links="110 111 112 113 114 115 116 117 118" title="Advanced Topics" />
<node body="" id="30" linkTypes="3" links="119" title="Cheat Sheet" />
<node body="" id="31" linkTypes="3" links="120" title="History of Leo" />
<node body="" id="32" linkTypes="3 3" links="121 122" title="Appendices &amp; glossary" />
<node body="" id="33" linkTypes="3" links="123" title="What's New..." />
<node body="Leo 5.3-final released May 2, 2016. &lt;br&gt;  &lt;br&gt; - Leo now supports Jupyter Notebook (.ipynb) files. &lt;br&gt; - @chapter is now allowed anywhere. No need for @chapters. &lt;br&gt; - Faster spell checking. &lt;br&gt; - The rst3 command supports @rst-table. &lt;br&gt; - The show-invisibles command now uses native Qt characters. &lt;br&gt; " id="34" linkTypes="1" links="6" title="Highlights" />
<node body="- Added clean-at-clean-files and clean-at-clean-tree commands. &lt;br&gt; - Added python-to-coffeescript command. &lt;br&gt; - Better defaults for open/save file dialogs. &lt;br&gt; - Improved clone-find commands. &lt;br&gt; - Improved kill &amp; yank commands." id="35" linkTypes="1" links="6" title="Commands" />
<node body="- The livecode plugin is enabled by default, provided that the [meta] &lt;br&gt;   (https://pypi.python.org/pypi/meta) package is available. &lt;br&gt;  &lt;br&gt; - The viewrendered3 plugin is intended to replace the VR1 and VR2 plugins." id="36" linkTypes="1" links="6" title="Plugins" />
<node body="" id="37" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156" title="Bug fixes" />
<node body="" id="38" linkTypes="3 3 3 3 3 3" links="157 158 159 160 161 162" title="Major features" />
<node body="- Added clean-at-clean-files and clean-at-clean-tree commands. &lt;br&gt;  &lt;br&gt;   The clean-at-clean-files command cleans all @clean nodes (for .py files only) in the entire outline.  The clean-at-clean-tree does the same, but for only one @clean node.  You can invoke the clean-at-clean-tree from any descendant of the @clean node. &lt;br&gt;  &lt;br&gt;   The new commands add zero, one or two blanks lines to the start of each node in @clean trees for .py files. Root nodes not affected. Zero for section definition nodes, two for nodes that start with 'class' and one otherwise. &lt;br&gt;  &lt;br&gt; - Added python-to-coffeescript command. &lt;br&gt; - Better defaults for open/save file dialogs. &lt;br&gt; - Improved clone-find commands. &lt;br&gt; - Improved kill &amp; yank commands. &lt;br&gt; - quickstart.leo tells how add Windows file associations." id="39" linkTypes="1" links="7" title="Commands: new and improved" />
<node body="- The livecode plugin is enabled by default, provided that the [meta](https://pypi.python.org/pypi/meta) package is available. &lt;br&gt;  &lt;br&gt; - The viewrendered3 plugin is intended to replace the VR1 and VR2 plugins." id="40" linkTypes="1" links="7" title="Plugins: new and improved" />
<node body="" id="41" linkTypes="1" links="9" title="@bool check_outline_after_read = True" />
<node body="" id="42" linkTypes="1" links="9" title="@bool check_outline_before_save = True" />
<node body="" id="43" linkTypes="1" links="9" title="@bool wikiview-active = False" />
<node body="run-marked-unit-tests-externally = Alt-4 &lt;br&gt; run-all-unit-tests-externally = Alt-5 &lt;br&gt; " id="44" linkTypes="1" links="9" title="@shortcuts" />
<node body="The default language if no @language or @comment is in effect. &lt;br&gt;  &lt;br&gt; Valid values are (case is ignored): &lt;br&gt;  &lt;br&gt; actionscript,c,csharp,css,cweb,elisp,html,java,latex, &lt;br&gt; pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk." id="45" linkTypes="1" links="9" title="@string target_language = rest" />
<node body="" id="46" linkTypes="1" links="9" title="@bool body_pane_wraps = True" />
<node body="" id="47" linkTypes="3 3" links="163 164" title="Inkscape options" />
<node body="" id="48" linkTypes="3 3 3" links="165 166 167" title="File options" />
<node body=" &lt;br&gt;  &lt;br&gt;  &lt;br&gt;  &lt;br&gt; " id="49" linkTypes="3 3 3" links="168 169 170" title="@page http plugin" />
<node body="" id="50" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187" title="@page rst3 options" />
<node body="" id="51" linkTypes="3 3 3 3" links="188 189 190 191" title=" Slideshow Buttons" />
<node body="target = '-- \nYou received this message because' &lt;br&gt; target = '--=20\nYou received this message because' &lt;br&gt; while p: &lt;br&gt;     s = p.b &lt;br&gt;     i = s.find(target) &lt;br&gt;     if i &gt; -1: &lt;br&gt;         p.b = s[:i] &lt;br&gt;         g.es(p.h) &lt;br&gt;     p.moveToThreadNext() &lt;br&gt; " id="52" linkTypes="1" links="10" title="@@button clean-mail" />
<node body="@language python &lt;br&gt; import os &lt;br&gt; pos = c.find_h(&quot;Users Guide&quot;)[0] &lt;br&gt; c.selectPosition(pos) &lt;br&gt; c.k.simulateCommand('rst3') &lt;br&gt; &lt;&lt; html manual &gt;&gt; &lt;br&gt; &lt;&lt; pdf manual &gt;&gt; &lt;br&gt; " id="53" linkTypes="3 3" links="192 193" title="@@button generate-full-userguide" />
<node body="import os &lt;br&gt; pos = c.find_h(&quot;Users Guide&quot;)[0] &lt;br&gt; c.selectPosition(pos) &lt;br&gt; c.k.simulateCommand('rst3') &lt;br&gt; &lt;&lt; html manual &gt;&gt; &lt;br&gt; # no pdf manual creation, perhaps too &quot;involved&quot; for many &lt;br&gt; " id="54" linkTypes="3 3" links="194 195" title="@@button generate-userguide" />
<node body="@language python &lt;br&gt; '''Run sphinx make clean ; make html.''' &lt;br&gt; import os &lt;br&gt; trace = True &lt;br&gt; g.cls() &lt;br&gt; c.setComplexCommand('make-sphinx') &lt;br&gt; if c.isChanged(): &lt;br&gt;     c.save() &lt;br&gt; aList = c.rstCommands.rst3() &lt;br&gt; if aList: &lt;br&gt;     path = g.os_path_finalize_join(g.app.loadDir,'..','doc','html') &lt;br&gt;     os.chdir(path) &lt;br&gt;     if len(aList) &gt; 1: g.execute_shell_commands('make clean',trace=trace) &lt;br&gt;     g.execute_shell_commands('make html',trace=trace) &lt;br&gt;     fn = aList[0].h.strip() if len(aList) == 1 else 'leo_toc.html' &lt;br&gt;     fn = g.os_path_finalize_join(path,'_build','html',g.os_path_basename(fn)) &lt;br&gt;     if g.os_path_exists(fn): &lt;br&gt;         # Don't wait for this command to exit! &lt;br&gt;         g.execute_shell_commands(['&amp;%s' % (fn)],trace=trace) &lt;br&gt; " id="55" linkTypes="1" links="10" title="@button make-sphinx" />
<node body="@language python &lt;br&gt; # From Script: clean ekr-spellpyx.txt &lt;br&gt; p.b = ''.join(sorted(set(g.splitLines(p.b.rstrip()+'\n'))))" id="56" linkTypes="1" links="10" title="@@button remove dups" />
<node body="@language python &lt;br&gt; ''' &lt;br&gt; Print all command names from headlines in Docstrings outline not appearing in &lt;br&gt; Commands Reference. &lt;br&gt;  &lt;br&gt; This script assumes the following outline structure:: &lt;br&gt;      &lt;br&gt;     - This script &lt;br&gt;         - Docstrings (a tree produced by &quot;Print commands &amp; docstrings&quot; script). &lt;br&gt;     - Commands Reference &lt;br&gt; ''' &lt;br&gt; g.cls() &lt;br&gt; ref = p.next() &lt;br&gt; assert ref.h == 'Commands Reference' &lt;br&gt; found, not_found = [],[] &lt;br&gt; child = p.firstChild() &lt;br&gt; for group in child.children(): &lt;br&gt;     for p in group.children(): &lt;br&gt;         target = p.h &lt;br&gt;         # print(target) &lt;br&gt;         for p2 in ref.subtree(): &lt;br&gt;             s = p2.b &lt;br&gt;             if s.find(target) &gt; -1: &lt;br&gt;                 found.append(target) &lt;br&gt;                 break &lt;br&gt;         else: &lt;br&gt;             not_found.append(target) &lt;br&gt; if 0: &lt;br&gt;     print('===== %s Found =====' % len(found)) &lt;br&gt;     for z in sorted(found): &lt;br&gt;         print(z) &lt;br&gt; if 1: &lt;br&gt;     print('===== %s Not Found =====' % len(not_found)) &lt;br&gt;     for z in sorted(not_found): &lt;br&gt;         print(z) &lt;br&gt; print('found: %s not found: %s' % (len(found),len(not_found)))" id="57" linkTypes="1" links="11" title="Script: check all command names" />
<node body="@language python &lt;br&gt;  &lt;br&gt; '''Creates an outline containing most docstrings from leoPlugins.leo. &lt;br&gt;  &lt;br&gt; Documentation for some docstrings are suppressed.''' &lt;br&gt;  &lt;br&gt; @others &lt;br&gt;  &lt;br&gt; controller(c).run() &lt;br&gt; " id="58" linkTypes="3" links="196" title="Script: get-plugin-docstrings" />
<node body="@language python &lt;br&gt;  &lt;br&gt; # Should be run from an empty .leo file. &lt;br&gt; # Such traces might be part of the tutorial, but aren't at present. &lt;br&gt;  &lt;br&gt; g.cls() &lt;br&gt;  &lt;br&gt; def print_p(p): &lt;br&gt;     c,result = p.v.context,[] &lt;br&gt;     v,n = p.v,p.childIndex() &lt;br&gt;     for data in p.stack: &lt;br&gt;         v,n = data &lt;br&gt;         result.append('(%s %s)' % (n,v.h)) &lt;br&gt;     return ','.join(result) &lt;br&gt;  &lt;br&gt; for p in c.all_positions(): &lt;br&gt;     print('(%s %s) p.stack: %s' % (p.childIndex(),p.h,print_p(p))) &lt;br&gt; " id="59" linkTypes="1" links="11" title="Script: generate position trace" />
<node body="s = p.b &lt;br&gt; for child in p.children(): &lt;br&gt;     s = s + '\n- ' + child.h &lt;br&gt; p.b = s" id="60" linkTypes="1" links="11" title="get-child-headlines" />
<node body="" id="61" linkTypes="1" links="12" title="improve MacOS install: chmod" />
<node body="Samples of use (Maybe): &lt;br&gt;  &lt;br&gt;     Sample on how to import bookmarks from Internet browser (I have that &lt;br&gt;     script ready myself, I could add that) &lt;br&gt;  &lt;br&gt;     Sample of website generated with an outline, easy to open and edit for &lt;br&gt;     the user to view its power. Ideally, just after transforming the &lt;br&gt;     outline to website, the user should be able to open it and see it in &lt;br&gt;     html. &lt;br&gt;  &lt;br&gt;     Sample of RST outline and one click opening with render pane. &lt;br&gt;  &lt;br&gt;     The RPG helper we recently discussed about. &lt;br&gt;  &lt;br&gt;     And as many other practical and ready-to-go samples that could impress &lt;br&gt;     the new user. All of them, ready to go, no edit required to view. There &lt;br&gt;     are ways of using Leo that beginners can't think of and those would make &lt;br&gt;     a great addon for such a beginner's leo file. &lt;br&gt;  &lt;br&gt; Other (JKN) &lt;br&gt;     how to invoke Leo (short list of command-line parameters     &lt;br&gt;     brief note on creating your own settings (myLeoSettings etc)     &lt;br&gt;     How to 'install' plugins, adding buttons     &lt;br&gt;     @node summary usage     &lt;br&gt;  &lt;br&gt; More: Rest of the directives: &lt;br&gt;     @button     &lt;br&gt;     @rclick     &lt;br&gt;     and all of them, with sample of usage     &lt;br&gt;  &lt;br&gt; More: Associate leo files     &lt;br&gt;     Include the bat + instructions on how to associate Leo files for &lt;br&gt;     double-click opening in windows. &lt;br&gt; " id="62" linkTypes="1" links="12" title="Examples for cheat sheet" />
<node body="- Cut &amp; copy a clone to create an unlinked (archived, non-cloned) copy of it. &lt;br&gt;  &lt;br&gt; - if 0: &lt;br&gt;     @others &lt;br&gt;      &lt;br&gt; - Reorganize (clone) @test nodes to specify only those tests that you want to run. &lt;br&gt;  &lt;br&gt; - Clone nodes and move them close together to focus your attention on them. &lt;br&gt;  &lt;br&gt; - class myClass: &lt;br&gt;     @others &lt;br&gt;      &lt;br&gt; - &lt;&lt; imports &gt;&gt; &lt;br&gt;  &lt;br&gt; - Creating to-do nodes to get to-do items *out* of sight. &lt;br&gt;  &lt;br&gt; - Put the project I am working on at the *bottom* of the outline." id="63" linkTypes="3" links="197" title="Example Leo patterns" />
<node body="Give differences between Leo and Emacs, Vim &amp; IPython." id="64" linkTypes="3 3 3 3" links="198 199 200 201" title="Leo &amp; other programs" />
<node body="Positions and trees are objects that exists only within Leo instance. However, trees can have &quot;serialized&quot; representation in .leo xml files (where structure is described by xml hierarchy), or @file nodes (where structure is described by sentinels). &lt;br&gt;  &lt;br&gt; Sometimes, both formats are too heavyweight. Both xml and &quot;flat&quot; text files involve nontrivial callback-based (or worse) parsing. Luckily, trees can be represented naturally with python lists, which can be pickled and passed around with almost zero cost in CPU consumption or code complexity. In theory position objects can be passed around in this fashion as well, but positions always have to exist in the tree (there is no concept of 'detached' position) and they can't be pickled or moved around outside the Leo instance. &lt;br&gt;  &lt;br&gt; For the purposes of this discussion (and for the sheer narcissistic pleasure of inventing new terminology), I'm calling these data structures `objtrees`. &lt;br&gt;  &lt;br&gt; The structure of objtrees is a standard Python list of the form:: &lt;br&gt;  &lt;br&gt;     [headline, bodystring, gnx, [children...]] &lt;br&gt;  &lt;br&gt; Where `children` is a recursive tree. Here's an example objtree (from ILeo session):: &lt;br&gt;  &lt;br&gt;     ileo[~/hashcache]|11&gt; g.tree_at_position(p) &lt;br&gt;                      &lt;11&gt; &lt;br&gt;     [u'root', &lt;br&gt;      u'Root body', &lt;br&gt;      'ville.20090601215420.1449', &lt;br&gt;      [[u'ch1 head', &lt;br&gt;        u'child 1 body', &lt;br&gt;        'ville.20090609184451.5679', &lt;br&gt;        [[u'ch1.1 head', u'ch1.1 body', 'ville.20090609184451.5680', []], &lt;br&gt;         [u'ch1.2 head', u'ch1.2 body', 'ville.20090609184451.5681', []]]], &lt;br&gt;       [u'ch2 head', &lt;br&gt;        u'ch2 body', &lt;br&gt;        'ville.20090609184451.5682', &lt;br&gt;        [[u'ch2.1 head', u'', 'ville.20090609184451.5683', []]]]]] &lt;br&gt;  &lt;br&gt; Note that these trees are constructed using `g.tree_at_position(pos)`. These objtrees can be re-incorporated to Leo document using `g.create_tree_at_vnode(c, v, tree)`, which rebuilds the structure at position p. The &quot;vnode&quot; is available as p.v attribute. This functions also creates clones if necessary (according to gnx). If you want to avoid creating clones (e.g. to implement simple copy-paste functionality), you can use `g.create_tree_at_position(p)`. create_tree_at_position also server as a trivial example for recursing through objtree data structure:: &lt;br&gt;  &lt;br&gt;     def create_tree_at_position(p, tree): &lt;br&gt;         &quot;&quot;&quot; Like create_tree_at_vnode, but slower, simpler, without clone/gnx support &lt;br&gt;         &quot;&quot;&quot; &lt;br&gt;         h,b,gnx,chi = tree &lt;br&gt;  &lt;br&gt;         p.h = h &lt;br&gt;         p.b = b &lt;br&gt;  &lt;br&gt;         for el in chi: &lt;br&gt;             chpos = p.insertAsLastChild().copy() &lt;br&gt;             # recurse &lt;br&gt;             create_tree_at_position(chpos, el) &lt;br&gt;  &lt;br&gt; `g.create_tree_at_vnode` is more complex, but faster and supports clones. It relies on `g.fast_add_last_child(c, parent_v, gnxString)`, which adds a new node to the tree as last child of parent_v (vnode), It either returns the created vnode, or None if it created a clone (i.e. a node with same gnx was already found in the document). This is a conscious design choice, as it prevents you from accidentally manipulating the tree of the clone (since it already has a tree of its own!). &lt;br&gt; " id="65" linkTypes="1" links="13" title="Python list based description of trees ('objtrees')" />
<node body="Objtrees are not without real life applications. They are used to implement the content hash based node cache that radically speeds up Leo's startup (effectively eliminating the delay caused by Leo parsing @file / @auto nodes - something which made trees with several @auto or @file nodes intolerable in practice. The trick here relies on the fact that: &lt;br&gt;  &lt;br&gt; - The whole content of external file (say, foo.py) can be described by calculating an md5sum of the file - The same external file content will always create the same leo tree. &lt;br&gt;  &lt;br&gt; In brief, &lt;br&gt;  &lt;br&gt; - When we are reading in a @file node foo.cpp, we first read in the whole file and calculate md5sum of its contents. Let's say the md5 sum is 8095e2dabbfe90b349066209fb090df6. &lt;br&gt;  &lt;br&gt; - Leo tries to look for existing cached version in ~/.leo/db/LeoDocs.leo/fcache/8095e2dabbfe90b349066209fb090df6. Initially, it doesn't exist, so Leo executes the standard (slow) @file code parsing routine and creates the tree normally &lt;br&gt;  &lt;br&gt; - After creating the tree, Leo executes g.tree_at_position and pickles the objtree to file ~/.leo/db/LeoDocs.leo/fcache/8095e2dabbfe90b349066209fb090df6 &lt;br&gt;  &lt;br&gt; - Now, on the next startup, Leo *will* find the cached pickle, read it in and execute `g.create_tree_at_vnode` &lt;br&gt; " id="66" linkTypes="1" links="13" title="Using objtrees for caching" />
<node body="Previous discussion omitted one fact - Leo doesn't actually operate on files directly, but uses the `pickleshare` library (shipped with Leo) to access the cached pickles. In essence, the database is always associated with one specific Leo document, and is available through c.db. So, storing a tree is (in simplified form) about doing:: &lt;br&gt;  &lt;br&gt;    cachename = &quot;fcache/8095e2dabbfe90b349066209fb090df6&quot; &lt;br&gt;    if cachename in c.db: &lt;br&gt;         g.trace('Already cached') &lt;br&gt;     else: &lt;br&gt;         tree = g.tree_at_position(pos) &lt;br&gt;         c.db[cachename] = tree &lt;br&gt;  &lt;br&gt; Pickleshare (as used by Leo) stores the pickles in zlib-compressed form, which yields significant size benefits for large pickles like objtrees. &lt;br&gt;  &lt;br&gt; Note that c.db is available to all plugins and scripts, and in no way limited to this specific caching purpose. In practice, it's useful for data you want to persist through Leo sessions, but not added to .leo document (which is what unknownAttributes are used for). &lt;br&gt;  &lt;br&gt; In addition to c.db, there is g.app.db that can be used for global (non-document specific) persisted data. E.g.:: &lt;br&gt;  &lt;br&gt;     g.app.db['foo'] = [1,2,3]   &lt;br&gt;  &lt;br&gt; The underlying files for c.db are at under ~/.leo/db/somedocument.leo_somehash. &lt;br&gt;  &lt;br&gt; Files for g.app.db are at ~/.leo/db/global. &lt;br&gt;  &lt;br&gt; " id="67" linkTypes="1" links="13" title="The `Leo database` (c.db, g.app.db)" />
<node body="&quot;&quot;&quot; &lt;br&gt; Extract plugin status and docs. from docstrings &lt;br&gt;  &lt;br&gt; :last_update: 20100301 &lt;br&gt; :plugin_status: initial development &lt;br&gt; :gui: qt &lt;br&gt; :maintainer: terry_n_brown@yahoo.com &lt;br&gt;  &lt;br&gt; Generate merged documentation from plugins (or any .py files). &lt;br&gt;  &lt;br&gt; E.g.:: &lt;br&gt;  &lt;br&gt;     python doc/plugin_catalog.py \ &lt;br&gt;       --css-file=.../Sphinx-0.6.5/sphinx/themes/sphinxdoc/static/sphinxdoc.css \ &lt;br&gt;       plugins/ doc/plugin_docs.html &lt;br&gt;  &lt;br&gt; Options: &lt;br&gt;   -h, --help            show this help message and exit &lt;br&gt;   --location=LOCATION   Add a location to the list to search &lt;br&gt;   --css-file=CSS_FILE   Use this CSS file in the HTML output &lt;br&gt;   --max-files=MAX_FILES &lt;br&gt;                         Stop after this many files, mainly for testing &lt;br&gt;   --include-contents    Include table of contents (the summary is more useful) &lt;br&gt;   --no-summary          Don't generate the summary &lt;br&gt;   --show-paths          Show paths to .py files, useful for resolving RST &lt;br&gt;                         errors &lt;br&gt;   --output=OUTPUT       Filename for the html output &lt;br&gt;   --xml-output=XML_OUTPUT &lt;br&gt;                         Filename for optional xml output, mainly for testing &lt;br&gt;  &lt;br&gt; TODO &lt;br&gt;  &lt;br&gt;  - Design encoding of plugin status in rst docstring &lt;br&gt;  &lt;br&gt;    - interface (qt) &lt;br&gt;    - maintained / working / old / broken &lt;br&gt;    - maintainer &lt;br&gt;  &lt;br&gt;  - List of commands provided by plugin (or command pattern, e.g active-path-\*) &lt;br&gt;  - List of semantic tags provided by plugin (@bookmark...) &lt;br&gt;  &lt;br&gt; &quot;&quot;&quot; &lt;br&gt; " id="68" linkTypes="1" links="15" title="&lt;&lt; docstring &gt;&gt;" />
<node body="import os &lt;br&gt; import sys &lt;br&gt; import ast &lt;br&gt; import time &lt;br&gt; from copy import deepcopy &lt;br&gt; import optparse &lt;br&gt;  &lt;br&gt; try: &lt;br&gt;     ok = True &lt;br&gt;     from docutils.core import publish_doctree, publish_from_doctree &lt;br&gt;     from docutils import nodes &lt;br&gt;     from docutils.transforms.parts import Contents &lt;br&gt;     from docutils.utils import SystemMessage &lt;br&gt; except Exception: &lt;br&gt;     sys.stderr.write('plugin_catalog.py: can not import docutils\n') &lt;br&gt;     ok = False &lt;br&gt; " id="69" linkTypes="1" links="15" title="&lt;&lt; imports &gt;&gt;" />
<node body="def err(s): &lt;br&gt;     sys.stderr.write(s) &lt;br&gt;     sys.stderr.flush() &lt;br&gt; " id="70" linkTypes="1" links="15" title="err" />
<node body="class PluginCatalog(object): &lt;br&gt;      &lt;br&gt;     &quot;&quot;&quot;see module docs. and make_parser()&quot;&quot;&quot; &lt;br&gt;      &lt;br&gt;     @others &lt;br&gt; " id="71" linkTypes="3 3 3 3 3 3 3" links="202 203 204 205 206 207 208" title="class PluginCatalog" />
<node body="def main(): &lt;br&gt;      &lt;br&gt;     &quot;&quot;&quot;create and run a PluginCatalog&quot;&quot;&quot; &lt;br&gt;      &lt;br&gt;     opts, args = PluginCatalog.make_parser().parse_args() &lt;br&gt;  &lt;br&gt;     if args and not opts.output: &lt;br&gt;         opts.output = args[-1] &lt;br&gt;         del args[-1] &lt;br&gt;  &lt;br&gt;     opts.location.extend(args) &lt;br&gt;  &lt;br&gt;     plugin_catalog = PluginCatalog(opts) &lt;br&gt;     plugin_catalog.run() &lt;br&gt; " id="72" linkTypes="1" links="15" title="main" />
<node body="@first &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &lt;br&gt; @first &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;br&gt; @first &lt;!-- This is Leo's home page --&gt; &lt;br&gt;  &lt;br&gt; @language html &lt;br&gt; @tabwidth -2 &lt;br&gt;  &lt;br&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;br&gt; &lt;head&gt; &lt;br&gt;     &lt;&lt; head &gt;&gt; &lt;br&gt; &lt;/head&gt; &lt;br&gt; &lt;body&gt; &lt;br&gt;   &lt;&lt; div top nav &gt;&gt; &lt;br&gt;   &lt;div class=&quot;document&quot;&gt; &lt;br&gt;     &lt;div class=&quot;documentwrapper&quot;&gt; &lt;br&gt;       &lt;div class=&quot;bodywrapper&quot;&gt; &lt;br&gt;         &lt;div class=&quot;body&quot;&gt; &lt;br&gt;           &lt;&lt; div main section &gt;&gt; &lt;br&gt;         &lt;/div&gt; &lt;br&gt;       &lt;/div&gt; &lt;br&gt;     &lt;/div&gt; &lt;br&gt;     &lt;&lt; sidebar &gt;&gt; &lt;br&gt;     &lt;div class=&quot;clearer&quot;&gt;&lt;/div&gt; &lt;br&gt;   &lt;/div&gt; &lt;br&gt;   &lt;&lt; div bottom nav &gt;&gt; &lt;br&gt;   &lt;&lt; div footer &gt;&gt; &lt;br&gt; &lt;/body&gt; &lt;br&gt; &lt;/html&gt; &lt;br&gt; " id="73" linkTypes="3 3 3 3 3 3" links="209 210 211 212 213 214" title="@file html/index.html" />
<node body=" &lt;br&gt; @pagewidth 70 &lt;br&gt; @all &lt;br&gt; " id="74" linkTypes="3 3 3 3 3 3 3 3" links="215 216 217 218 219 220 221 222" title="@file slideshows.txt" />
<node body="@nocolor &lt;br&gt;  &lt;br&gt; .. Leo documentation documentation master file, created by &lt;br&gt; .. sphinx-quickstart on Mon Mar 30 16:39:02 2009. &lt;br&gt; .. You can adapt this file completely to your liking, but it should at least &lt;br&gt; .. contain the root `toctree` directive. &lt;br&gt;  &lt;br&gt; .. 2013/10/08: This page now *does* generate the real TOC. &lt;br&gt;  &lt;br&gt; Leo's Documentation Page &lt;br&gt; ======================== &lt;br&gt;  &lt;br&gt; **Important**: the easiest way to search Leo's documentation is to search LeoDocs.leo. &lt;br&gt;  &lt;br&gt; .. _`Leo's home page`: http://leoeditor.com/ &lt;br&gt;  &lt;br&gt; `Leo's home page`_ &lt;br&gt;  &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 2 &lt;br&gt;     &lt;br&gt;    preliminaries &lt;br&gt;     &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 1 &lt;br&gt;  &lt;br&gt;    getting-started &lt;br&gt;     &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 1 &lt;br&gt;  &lt;br&gt;    Cheat Sheet &lt;cheatsheet&gt; &lt;br&gt;     &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 2 &lt;br&gt;  &lt;br&gt;    screencasts &lt;br&gt;    Tutorial &lt;tutorial&gt; &lt;br&gt;    Users Guide &lt;usersguide&gt; &lt;br&gt;    leoandotherprograms &lt;br&gt;    intermediatetopics &lt;br&gt;    appendices &lt;br&gt;  &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 1 &lt;br&gt;  &lt;br&gt;    history &lt;br&gt;    FAQ &lt;br&gt;    glossary &lt;br&gt;    What's New &lt;what-is-new&gt; &lt;br&gt;  &lt;br&gt; .. toctree:: &lt;br&gt;    :hidden: &lt;br&gt;  &lt;br&gt;    slides &lt;br&gt;    leoLinks &lt;br&gt;    screen-shots &lt;br&gt;  &lt;br&gt; `Leo's home page`_. &lt;br&gt;  &lt;br&gt;     " id="75" linkTypes="1" links="19" title="@edit html\leo_toc.html.txt" />
<node body="################## &lt;br&gt; More Leo Resources &lt;br&gt; ################## &lt;br&gt;  &lt;br&gt; .. _`blog post`: http://rickardlindberg.me/writing/reflections-on-programming/2013-02-24-related-things-are-not-kept-together/ &lt;br&gt; .. _`2012 PyOhio talk`:     http://www.youtube.com/watch?v=JgJ89ekGj-s &lt;br&gt; .. _`Icons`:                http://leoeditor.com/icons.html &lt;br&gt; .. _`Introduction to Leo`:  http://www.youtube.com/watch?v=Zu6J-J0qFi0 &lt;br&gt; .. _`Leo in a nutshell`:    https://groups.google.com/d/msg/leo-editor/lgHE4OJSLzw/2VXkckrvnsIJ &lt;br&gt; .. _`Leo's resource page`:  http://www.jserv.com/jk_orr/xml/leo.htm &lt;br&gt; .. _`Mind Mapping`:         http://www.mind-mapping.org/ &lt;br&gt; .. _`bookmarks plugin video`: https://vimeo.com/77720098  &lt;br&gt; .. _`literate programming`: http://www.literateprogramming.com/ &lt;br&gt; .. _`scripting tutorial`:   http://blog.suspended-chord.info/2014/01/28/intro-to-leo-scripting/ &lt;br&gt; .. _`slashdot article`:     http://leoeditor.com/testimonials.html#speed-ream-s-slashdot-article &lt;br&gt; .. _`web viewer`:           http://leoeditor.com/load-leo.html &lt;br&gt; .. _`wikipedia page`:       http://en.wikipedia.org/wiki/Leo_(editor) &lt;br&gt;  &lt;br&gt; Videos: &lt;br&gt;  &lt;br&gt; - Ville Vainio's `Introduction to Leo`_. &lt;br&gt; - Terry Brown's `bookmarks plugin video`_. &lt;br&gt; - Tom Fetherston's `2012 PyOhio talk`_ &lt;br&gt;  &lt;br&gt; More resources: &lt;br&gt;  &lt;br&gt; - Speed Ream's `slashdot article`_ about Leo. &lt;br&gt; - Jacob Peck's `scripting tutorial`_. &lt;br&gt; - Leo's `wikipedia page`_. &lt;br&gt; - A page about `literate programming`_. &lt;br&gt; - Joe Orr's `Leo's resource page`_ containing XSLT stylesheets for Leo. &lt;br&gt; - The `Mind Mapping`_ page. &lt;br&gt; - A `web viewer`_ page for .leo files. &lt;br&gt; - `Icons`_ telling the world that you used Leo. &lt;br&gt; - `Leo in a nutshell`_: A summary Leo's more than one million lines of source code. &lt;br&gt; - Rickard Lindberg's `blog post`_ about how Leo improves computer code. &lt;br&gt;  &lt;br&gt; " id="76" linkTypes="1" links="21" title="@rst html/leoLinks.html " />
<node body="################ &lt;br&gt; Leo screen shots &lt;br&gt; ################ &lt;br&gt;  &lt;br&gt; " id="77" linkTypes="3 3" links="223 224" title="@rst html/screen-shots.html" />
<node body="################ &lt;br&gt; Videos about Leo &lt;br&gt; ################ &lt;br&gt;  &lt;br&gt; .. |br| raw:: html &lt;br&gt;  &lt;br&gt;    &lt;br /&gt; &lt;br&gt;  &lt;br&gt; This page links to videos about Leo.  **Important notes**: &lt;br&gt;  &lt;br&gt; - Videos hosted at screencast.com look a bit clearer than YouTube videos, |br| &lt;br&gt;   but they may not always be available due to bandwidth limits. &lt;br&gt; - screencast.com viewers: click the &quot;Full Size&quot; button. |br| &lt;br&gt; - YouTube viewers: select top quality in the video settings. |br| &lt;br&gt;   YouTube videos typically become clearer after a few seconds. &lt;br&gt;    &lt;br&gt; **Potential screencasters**: please read these &lt;br&gt; `tips for screencast authors &lt;http://leoeditor.com/FAQ.html#how-to-make-a-screencast&gt;`_. &lt;br&gt;  &lt;br&gt; .. list-table:: &lt;br&gt;    :widths: 10 30 10 10 &lt;br&gt;    :header-rows: 1 &lt;br&gt;  &lt;br&gt;    * - Level &lt;br&gt;      - Title &lt;br&gt;      - Screencast &lt;br&gt;      - YouTube &lt;br&gt;    * - Intro &lt;br&gt;      - A Brief Introduction to Leo &lt;br&gt;      - `hi-res &lt;http://www.screencast.com/t/xDZAOqfsAhPZ&gt;`__ &lt;br&gt;      - `regular &lt;http://www.youtube.com/watch?v=tuM8MvI9g6k&gt;`__ &lt;br&gt;    * - Intro &lt;br&gt;      - Leo for Programmers &lt;br&gt;      - `hi-res &lt;http://www.screencast.com/t/lgR6lMhWK&gt;`__ &lt;br&gt;      - `regular &lt;http://www.youtube.com/watch?v=WkUbJAuFfI4&gt;`__ &lt;br&gt;    * - Intro &lt;br&gt;      - Ville Vianio introduces Leo &lt;br&gt;      - &lt;br&gt;      - `regular &lt;http://www.youtube.com/watch?v=Zu6J-J0qFi0&gt;`__ &lt;br&gt;    * - Basic &lt;br&gt;      - Using Leo’s Find pane &lt;br&gt;      - `hi-res &lt;http://www.screencast.com/t/O7915mYD3&gt;`__ &lt;br&gt;      - `regular &lt;https://www.youtube.com/watch?v=K5mmlnSOkLM&gt;`__ &lt;br&gt;    * - Basic &lt;br&gt;      - Using Leo’s minibuffer &lt;br&gt;      - `hi-res &lt;http://www.screencast.com/t/tEQ7brI4n6&gt;`__ &lt;br&gt;      - `regular &lt;https://www.youtube.com/watch?v=dEaGOi6hVpo&gt;`__ &lt;br&gt;    * - Intermediate &lt;br&gt;      - Using abbreviations &lt;br&gt;      - &lt;br&gt;      - `regular &lt;http://www.youtube.com/watch?v=WRoiXO53Aac&gt;`__ &lt;br&gt;    * - Intermediate &lt;br&gt;      - Using clones to speed your work flow &lt;br&gt;      - `hi-res &lt;http://www.screencast.com/t/l8W9H5G8zB&gt;`__ &lt;br&gt;      - `regular &lt;https://www.youtube.com/watch?v=DsHEHNLKi2o&gt;`__ &lt;br&gt;    * - Plugin &lt;br&gt;      - Terry Brown demos bookmarks.py &lt;br&gt;      - &lt;br&gt;      - `regular &lt;https://vimeo.com/77720098&gt;`__ &lt;br&gt;    * - Plugin &lt;br&gt;      - Fidel Perez demos mod_http.py &lt;br&gt;      - &lt;br&gt;      - `regular &lt;http://www.youtube.com/watch?v=9AvbL_0JEMw&amp;feature=youtu.be&gt;`__ &lt;br&gt;    * - Plugin &lt;br&gt;      - mod_ftp.py &lt;br&gt;      - &lt;br&gt;      - `regular &lt;http://www.youtube.com/watch?v=bnj0NQuljQo&gt;`__ &lt;br&gt; " id="78" linkTypes="1" links="21" title="@rst html/screencasts.html" />
<node body="@ @rst-options &lt;br&gt; call_docutils=False &lt;br&gt; stylesheet_path=..\doc &lt;br&gt; write_intermediate_file = True &lt;br&gt; @c &lt;br&gt;  &lt;br&gt; ###### &lt;br&gt; Slides &lt;br&gt; ###### &lt;br&gt;  &lt;br&gt; This is the front page for various slide shows about Leo. &lt;br&gt;  &lt;br&gt; .. links &lt;br&gt; .. _`Clones and views`:         slides/clones-and-views/slide-001.html &lt;br&gt; .. _`External files`:           slides/external-files/slide-005.html &lt;br&gt; .. _`Installation`:             slides/installation/slide-001.html &lt;br&gt; .. _`Leo Basics Step By Step`:  slides/leo-basics-step-by-step/slide-001.html &lt;br&gt; .. _`Scripting Leo`:            slides/scripting-leo/slide-001.html &lt;br&gt; .. _`Using Leo's Minibuffer`:   slides/using-leos-minibuffer/slide-001.html &lt;br&gt;  &lt;br&gt; Basic slide shows &lt;br&gt; ----------------- &lt;br&gt;  &lt;br&gt; `Installation`_  tells how to install Leo. &lt;br&gt;  &lt;br&gt; `Leo Basics Step By Step`_  explains the basics of Leo outlines. &lt;br&gt;  &lt;br&gt; `External Files`_ discusses creating external files with @file, @clean and @edit. &lt;br&gt;  &lt;br&gt; `Clones and views`_ illustrates how clones work and show how they create views. &lt;br&gt;  &lt;br&gt; `Using Leo's Minibuffer`_ tells how to execute Leo's commands by name. &lt;br&gt;  &lt;br&gt; Intermediate slide shows &lt;br&gt; ------------------------ &lt;br&gt;  &lt;br&gt; `Scripting Leo`_ explains how to use Python scripting in Leo. &lt;br&gt; " id="79" linkTypes="1" links="21" title="@rst html/slides.html" />
<node body="To generate .odt or .rtf or .pdf files, you create an intermediate file and ignore the the &quot;official&quot; output file, in this case test.html. The intermediate file contains the rST text corresponding to the @rst tree. &lt;br&gt;  &lt;br&gt; To tell the rst3 plugin to generate an intermediate file, do:: &lt;br&gt;  &lt;br&gt;     write_intermediate_file = True &lt;br&gt;  &lt;br&gt; After you create the intermediate file, in this case, test.html.txt, You can create an odt file as follows:: &lt;br&gt;  &lt;br&gt;     python &lt;path-to-python&gt;/scripts/rst2odt.py test.html.txt test.odt &lt;br&gt;  &lt;br&gt; I a batch file, rst2odt.bat, like this: &lt;br&gt;  &lt;br&gt;     rst2odt test &lt;br&gt;  &lt;br&gt; Note that rst3odt.py is in the tools directory of the DocUtils distribution. &lt;br&gt;  &lt;br&gt; To generate .rtf, you can use PanDoc to convert test.html.txt to RTF. &lt;br&gt;  &lt;br&gt; To generate .pdf files, you would first convert test.html.txt to LaTeX:: &lt;br&gt;  &lt;br&gt;     python rst2newlatex.py test.html.txt test.tex &lt;br&gt;  &lt;br&gt;     -- OR -- &lt;br&gt;  &lt;br&gt;     cd leo\docs\html &lt;br&gt;     make latex &lt;br&gt;  &lt;br&gt; You can then use one of the LaTeX to .pdf converters to create the final .pdf file. See http://docutils.sourceforge.net/docs/user/latex.html#pdf-generation for details. &lt;br&gt; " id="80" linkTypes="3 3" links="225 226" title="How to generate odt/rtf/pdf files" />
<node body="- Select the node &quot;Leo's Documentation&quot; &lt;br&gt;  &lt;br&gt; - Run the make-sphinx command or click the make-sphinx button. &lt;br&gt;  &lt;br&gt;  &lt;br&gt; To generate these docs by hand: &lt;br&gt;  &lt;br&gt;     - From this file, run rst3 on desired tree. &lt;br&gt;     - cd leo\doc\html &lt;br&gt;     - make html &lt;br&gt;  &lt;br&gt; To create pdf (probably easiest on Linux, with necessary latex packages installed): &lt;br&gt;  &lt;br&gt;     - make latex &lt;br&gt;     - cd _build/latex &lt;br&gt;     - make all-pdf &lt;br&gt;      &lt;br&gt; Important files: &lt;br&gt;  &lt;br&gt; - doc\html\conf.py contains settings, including the name of the master toctree &lt;br&gt;   document: leo_toc.html.txt. &lt;br&gt;  &lt;br&gt; " id="81" linkTypes="1" links="22" title="How to generate these docs" />
<node body="############# &lt;br&gt; Preliminaries &lt;br&gt; ############# &lt;br&gt;  &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 2 &lt;br&gt;     &lt;br&gt;    preface &lt;br&gt;    testimonials &lt;br&gt;    acknowledgements &lt;br&gt;    license &lt;br&gt;  &lt;br&gt; .. ..  :titlesonly: " id="82" linkTypes="1" links="23" title="@rst html/preliminaries.html" />
<node body=".. |---| unicode:: U+02015 .. for quotes &lt;br&gt;    :trim: &lt;br&gt;     &lt;br&gt; ####### &lt;br&gt; Preface &lt;br&gt; ####### &lt;br&gt;  &lt;br&gt; .. _`Leo's tutorial`: tutorial.html &lt;br&gt; .. _`ask for help`:   https://groups.google.com/forum/#!forum/leo-editor &lt;br&gt; .. _`Directed Acyclic Graphs`: https://en.wikipedia.org/wiki/Directed_acyclic_graph &lt;br&gt; .. _`group of developers and users`: https://groups.google.com/forum/#!forum/leo-editor &lt;br&gt; .. _`The Leonine World`: leonine-world.html &lt;br&gt;  &lt;br&gt;     &quot;Word outlines are very useful. But Leo makes Word look like a clunky toy.&quot;---Joe Orr &lt;br&gt;  &lt;br&gt; Leo is a fundamentally different way of using and organizing data, programs and scripts. Leo has been under active development for 15 years and has an active `group of developers and users`_. &lt;br&gt;  &lt;br&gt; You won't learn all about Leo in a day or two. `Leo's tutorial`_ explains the basic features. You can learn more advanced features later. Please `ask for help`_ immediately if you get stuck. &lt;br&gt;  &lt;br&gt; Leo has shamelessly stolen the best features of Emacs, including the minibuffer and many Emacs-like commands. But Leo goes *far* beyond other editors: &lt;br&gt;  &lt;br&gt; - Leo *completely integrates* Python scripting and outlines, not just the outline's data, but the outline structure as well. &lt;br&gt;  &lt;br&gt; - Features such as @test nodes and @button nodes can not even be *thought* in traditional editors. Leo implements such features easily; other editors could only simulate them--laboriously and unnaturally. &lt;br&gt;     &lt;br&gt; - Leo's outlines are based `Directed Acyclic Graphs`_. As a result, Leo can organize data in completely new ways. &lt;br&gt;    &lt;br&gt; These features combine to accelerate your work flow in a unique **Leonine** way, described more fully in `The Leonine World`_. &lt;br&gt;    &lt;br&gt; In the next sections, Leo's users tell, in their own words, why they think Leo is something truly special... &lt;br&gt; " id="83" linkTypes="1" links="23" title="@rst html/preface.html" />
<node body=".. |---| unicode:: U+02015 .. for quotes &lt;br&gt;    :trim: &lt;br&gt;     &lt;br&gt; ################################ &lt;br&gt; What People are Saying about Leo &lt;br&gt; ################################ &lt;br&gt;  &lt;br&gt; .. |br| raw:: html &lt;br&gt;  &lt;br&gt;    &lt;br /&gt; &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="84" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3" links="227 228 229 230 231 232 233 234 235 236 237 238 239" title="@rst html/testimonials.html" />
<node body="################ &lt;br&gt; Acknowledgements &lt;br&gt; ################ &lt;br&gt;  &lt;br&gt; From one of my all-time favorite movie scenes, in My Cousin Vinny:: &lt;br&gt;  &lt;br&gt;     Mona Lisa Vito: So what's your problem? &lt;br&gt;     Vinny Gambini: My problem is, I wanted to win my first case &lt;br&gt;     without any help from anybody. &lt;br&gt;     Mona Lisa: Well, I guess that plan's moot. &lt;br&gt;     Vinny : Yeah. &lt;br&gt;     Mona Lisa: You know, this could be a sign of things to come. &lt;br&gt;     You win all your cases, but with somebody else's help, right? &lt;br&gt;     You win case after case, and then afterwards you have to go up &lt;br&gt;     to somebody and you have to say, &quot;thank you.&quot; &lt;br&gt;     [pause] &lt;br&gt;     Oh my God, what a fucking nightmare!  &lt;br&gt;  &lt;br&gt; Leo owes much of its visual design to MORE, possibly the most elegant computer program ever written. Leo's clone nodes are inspired by MORE. &lt;br&gt;  &lt;br&gt; The following people have made generous donations to the Leo project: Robert Low, Nic Cave-Lynch. &lt;br&gt;  &lt;br&gt; The following people reported bugs, answered questions, and made suggestions for improving Leo: &lt;br&gt;  &lt;br&gt; Alex Abacus, Shakeeb Alireze, Steve Allen, Bruce Arnold, Chris Barker, Dennis Benzinger, David Boddie, Jason Breti, Eric Brown, Terry Brown, Darius Clarke, Martin Clifford, Jason Cunliffe, Josef Dalcolmo, Gil Dev, Bill Drissel, Wenshan Du, Allen Edwards, Chris Elliot, Dethe Elza, Mark Engleberg, Roger Erens, Stephen Ferg, Tom Fetherston, Tomaz Ficko, Niklas Frykholm, Fred Gansevles, Jonathan M. Gilligan, Zak Greant, Thomas Guettler, Romain Guy, Dave Hein, Tiago Castro Henriques, Gary Herron, Steve Holden, Klass Holwerda, Matthias Huening, Robert Hustead, John Jacob, Paul Jaros, Christopher P. Jobling, Eric S. Johansson, Garold Johnson, James Kerwin, Nicola Larosa, David LeBlanc, Chris Liechti, Steve Litt, Martin v. Löwis, Robert Low, Fredrik Lundh, Michael Manti, Alex Martelli, Marcus A. Martin, Gidion May, David McNab, Frank Merenda, Martin Montcrieffe, Will Munslow, Chad Netzer, Derick van Niekerk, Jeff Nowland, Naud Olivier, Joe Orr, Marc-Antoine Parent, Paul Paterson, Sean Shaleh Perry, Tim Peters, David Priest, Gary Poster, Scott Powell, Bruce Rafnel, Walter H. Rauser, Olivier Ravard, David Speed Ream, Rich Ries, Aharon Robbins, Guido van Rossum, David Rowe, Davide Salomoni, Steven Schaefer,Johannes Schöön, Wolfram Schwenzer, Casey Wong Kam Shun, Gil Shwartz, Jim Sizelove, Paul Snively, Jurjen Stellingwerff, Phil Straus, David Szent-Györgyi, Kent Tenney, Jeffrey Thompson, Gabriel Valiente, Jim Vickroy, Tony Vignaux, Tom van Vleck, Kevin Walzer, Ying-Chao Wang, Cliff Wells, Dan Wharton, John Wiegley, Wim Wijnders, Dan Winkler, Vadim Zeitlin. &lt;br&gt;  &lt;br&gt; The following have contributed plugins to Leo: &lt;br&gt;  &lt;br&gt; Rodrigo Benenson, Pierre Bidon, Felix Breuer, Terry Brown, Mike Crowe, Josef Dalcolmo, Michael Dawson, e, Roger Erens, Andrea Galimberti, Engelbert Gruber, Timo Honkasalo, Jaakko Kourula, Maxim Krikun, Zhang Le, LeoUser, Frédéric Momméja, Bernhard Mulder, Mark Ng, Alexis Gendron Paquette, Paul Paterson, Jacob Peck, Dan Rahmel, Davide Salomoni, Ed Taekema, Kent Tenney, Brian Theado, Ville M. Vainio, Steve Zatz. &lt;br&gt; " id="85" linkTypes="3" links="240" title="@rst html/acknowledgements.html" />
<node body="################# &lt;br&gt; Leo's MIT license &lt;br&gt; ################# &lt;br&gt;  &lt;br&gt; All parts of Leo are distributed under the following copyright. This is intended to be the same as the MIT license, namely that Leo is absolutely free, even for commercial use, including resale. There is no GNU-like &quot;copyleft&quot; restriction. This license is compatible with the GPL. &lt;br&gt;  &lt;br&gt; **Copyright 1997-2016 by Edward K. Ream. All Rights Reserved.** &lt;br&gt;  &lt;br&gt; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: &lt;br&gt;  &lt;br&gt; The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. &lt;br&gt;  &lt;br&gt; **THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.** &lt;br&gt; " id="86" linkTypes="1" links="23" title="@rst html/license.html" />
<node body="##################################### &lt;br&gt; Downloading, Installing &amp; Running Leo &lt;br&gt; ##################################### &lt;br&gt;  &lt;br&gt; .. This page exists simply to organize the main TOC. &lt;br&gt;  &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 4 &lt;br&gt;  &lt;br&gt;    download &lt;br&gt;    installing &lt;br&gt;    running &lt;br&gt; " id="87" linkTypes="1" links="24" title="@rst html/getting-started.html" />
<node body="@pagewidth 75 &lt;br&gt;  &lt;br&gt; @ @rst-options &lt;br&gt; call_docutils=False &lt;br&gt; stylesheet_path=..\doc &lt;br&gt; write_intermediate_file = True &lt;br&gt; @c &lt;br&gt;  &lt;br&gt; ############### &lt;br&gt; Downloading Leo &lt;br&gt; ############### &lt;br&gt;  &lt;br&gt; .. links &lt;br&gt;  &lt;br&gt; .. _`latest stable release`: https://sourceforge.net/projects/leo/files/Leo/ &lt;br&gt; .. _`nightly snapshot`: http://www.greygreen.org/leo/ &lt;br&gt; .. _`SourceForge`: https://sourceforge.net &lt;br&gt; .. _`Leo's latest sources`: https://github.com/leo-editor/leo-editor &lt;br&gt; .. _`GitHub`: https://github.com/leo-editor &lt;br&gt; .. _`git`: http://git-scm.com/ &lt;br&gt;  &lt;br&gt; Leo's core code is always being improved and developed. Unit-testing ensures that the daily commits are as bug-free as possible. Almost all of the time, downloading `Leo's latest sources`_ from `GitHub`_  is going to give you code that is **more stable** than the most recent `latest stable release`_.  *Stable releases become outdated almost immediately*. &lt;br&gt;  &lt;br&gt; If you are just checking Leo out, feel free to use the `latest stable release`_ download if it makes you feel more secure, but once you've decided to work with Leo on a regular basis, we highly recommend regularly keeping your installation up to date with the most recent `nightly snapshot`_, or even better, `Leo's latest sources`_ from `GitHub`_ . &lt;br&gt;  &lt;br&gt; To summarize, you may get Leo in three ways: &lt;br&gt;  &lt;br&gt; 1. Download the `latest stable release`_ from `SourceForge`_. This release contains an executable installer. This release will usually be a bit out of date. &lt;br&gt;  &lt;br&gt; 2. Download `snapshots`_ (see below) from github. You can get the very latest development version, or a version from from 1, 2, 5, 10, 30 or 90 days ago. &lt;br&gt;     &lt;br&gt; 3. Download `Leo's latest sources`_ from `GitHub`_ using `git`_. Once git is installed, getting the latest version of Leo is very easy:: &lt;br&gt;     &lt;br&gt;         git clone https://github.com/leo-editor/leo-editor.git (http access) &lt;br&gt;      &lt;br&gt;    or:: &lt;br&gt;  &lt;br&gt;         git clone git@github.com:leo-editor/leo-editor.git (ssh access) &lt;br&gt; " id="88" linkTypes="3" links="241" title="@rst html/download.html" />
<node body="############## &lt;br&gt; Installing Leo &lt;br&gt; ############## &lt;br&gt;  &lt;br&gt; .. index:: Installing Leo &lt;br&gt;  &lt;br&gt; .. _`Leo's help forum`: http://groups.google.com/group/leo-editor &lt;br&gt;  &lt;br&gt; This chapter tells how to install and run Leo on Windows or Linux. Leo can be installed on MacOS, but the process is difficult and not recommended. &lt;br&gt;  &lt;br&gt; **Important**: If you have *any* problems installing Leo, please ask for help on `Leo's help forum`_. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 4 &lt;br&gt;      &lt;br&gt; " id="89" linkTypes="3 3 3" links="242 243 244" title="@rst html/installing.html" />
<node body="############## &lt;br&gt; Running Leo &lt;br&gt; ############## &lt;br&gt;  &lt;br&gt; .. index:: Running Leo &lt;br&gt;  &lt;br&gt; This chapter tells how to run Leo and discusses Leo's command-line options. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt;      &lt;br&gt; " id="90" linkTypes="3 3 3 3" links="245 246 247 248" title="@rst html/running.html" />
<node body="#### &lt;br&gt; FAQ &lt;br&gt; #### &lt;br&gt;  &lt;br&gt; This is Leo's Frequently Asked Questions document. &lt;br&gt;  &lt;br&gt; .. index:: FAQ &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 4 &lt;br&gt; " id="91" linkTypes="3 3 3 3 3 3 3 3 3 3 3" links="249 250 251 252 253 254 255 256 257 258 259" title="@rst html\FAQ.html" />
<node body=".. |---| unicode:: U+02015 .. for quotes &lt;br&gt;    :trim: &lt;br&gt;  &lt;br&gt; ############### &lt;br&gt; Leo's Tutorials &lt;br&gt; ############### &lt;br&gt;  &lt;br&gt; .. index:: Leo's tutorial &lt;br&gt;  &lt;br&gt; .. _`Python`: http://www.python.org/ &lt;br&gt;  &lt;br&gt;     &quot;Leo should either replace or greatly augment the development tools &lt;br&gt;     that I use.&quot;---Zak Greant &lt;br&gt;  &lt;br&gt;     &quot;Leo is a quantum leap for me in terms of how many projects I can manage &lt;br&gt;     and how much information I can find and organize and store in a &lt;br&gt;     useful way.&quot;---Dan Winkler &lt;br&gt;  &lt;br&gt; Leo looks like other outlining programs, but it is not. This tutorial will get you using Leo quickly, acquainting you with its unique features in one or two hours. It has five parts. &lt;br&gt;  &lt;br&gt; The first three parts are for all users. They will take about an hour to complete. Part one introduces Leo's basic operations for creating and changing outlines. Part two tells how to use Leo as a Personal Information Manager. Part three tells how to create HTML, PDF, LaTeX and other documents. &lt;br&gt;  &lt;br&gt; The last two parts are for computer programmers; they assume some familiarity with `Python`_ programming. They will take another hour to complete. Part four tells how to create external files (files on your file system) from Leo outlines. Part five tells how to write Leo scripts, Python scripts run from any Leo node. &lt;br&gt;      &lt;br&gt; .. toctree:: &lt;br&gt;     :maxdepth: 1 &lt;br&gt;      &lt;br&gt;     tutorial-basics &lt;br&gt;     tutorial-pim &lt;br&gt;     tutorial-rst3 &lt;br&gt;     tutorial-programming &lt;br&gt;     tutorial-scripting &lt;br&gt; " id="92" linkTypes="1" links="26" title="@rst html\tutorial.html" />
<node body=".. |---| unicode:: U+02015 &lt;br&gt;    :trim: &lt;br&gt;     &lt;br&gt; .. |br| raw:: html &lt;br&gt;  &lt;br&gt;    &lt;br /&gt; &lt;br&gt;  &lt;br&gt; ################## &lt;br&gt; The Basics of Leo &lt;br&gt; ################## &lt;br&gt;  &lt;br&gt;     &quot;Edward... you've come up with perhaps the most powerful new concept in &lt;br&gt;     code manipulation since VI and Emacs.&quot;---David McNab &lt;br&gt;  &lt;br&gt; This chapter introduces Leo's basic operations for creating and changing outlines. Commands can be executed using keystrokes, or by name. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 2 &lt;br&gt; " id="93" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276" title="@rst html\tutorial-basics.html" />
<node body=".. |---| unicode:: U+02015 .. for quotes &lt;br&gt;    :trim: &lt;br&gt;     &lt;br&gt; ########################################### &lt;br&gt; Using Leo as a Personal Information Manager &lt;br&gt; ########################################### &lt;br&gt;  &lt;br&gt;     &quot;Cloning is pure genius!&quot;---Michael Manti &lt;br&gt;  &lt;br&gt;     &quot;If you are like me, you have a kind of knowledge base with infos &lt;br&gt;     gathered over time. And you have projects, where you use some of those &lt;br&gt;     infos. Now, with conventional outliners you begin to double these &lt;br&gt;     infos, because you want to have the infos needed for the project with &lt;br&gt;     your project. With Leo you can do this too, but if you change text in &lt;br&gt;     one place **it is updated in the other place too!** This is a feature I &lt;br&gt;     did not see with any other outliner (and I tried a few). Amazing! Leo &lt;br&gt;     directly supports the way I work!&quot;---F. Geiger &lt;br&gt;  &lt;br&gt; This chapter tells how you can use Leo as a Personal Information Manager. It introduces `clones`_: one of Leo's most unusual and powerful features for organizing data. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 2 &lt;br&gt; " id="94" linkTypes="3 3 3 3 3" links="277 278 279 280 281" title="@rst html\tutorial-pim.html" />
<node body=".. |---| unicode:: U+02015 .. for quotes &lt;br&gt;    :trim: &lt;br&gt;     &lt;br&gt; .. |br| raw:: html &lt;br&gt;  &lt;br&gt;    &lt;br /&gt; &lt;br&gt;  &lt;br&gt; ######################################## &lt;br&gt; Creating Documents with the rst3 Command &lt;br&gt; ######################################## &lt;br&gt;  &lt;br&gt; .. _`LaTeX`:    http://www.latex-project.org/ &lt;br&gt; .. _`Python's`: http://www.python.org/ &lt;br&gt; .. _`Sphinx`:   http://sphinx-doc.org/ &lt;br&gt; .. _`Sphinx documentation`: http://sphinx-doc.org/contents.html &lt;br&gt; .. _`docutils`: http://docutils.sourceforge.net &lt;br&gt; .. _`reStructuredText`: http://docutils.sourceforge.net/rst.html &lt;br&gt; .. _`rST primer`: http://sphinx-doc.org/rest.html &lt;br&gt; .. _`first tutorial`: tutorial-basics.html &lt;br&gt;  &lt;br&gt;     &quot;I am a huge fan of Leo. I think it's quite possibly the most &lt;br&gt;     revolutionary programming tool I have ever used and it (along with the &lt;br&gt;     Python language) has utterly changed my view of programming (indeed of &lt;br&gt;     writing) forever.&quot;---Shakeeb Alireza &lt;br&gt;      &lt;br&gt; Leo's rst3 command converts Leo trees containing `reStructuredText`_ (rST) or `Sphinx`_ markup to HTML, PDF, `LaTeX`_ and other kinds of output files. This tutorial gives step-by-step instructions for using the rst3 command. &lt;br&gt;  &lt;br&gt; **Prerequisites**: Please make sure you have read the `first tutorial`_ before reading this one. If you are new to rST, please read the `rST primer`_. For full information about Sphinx, please read the `Sphinx documentation`_. &lt;br&gt;  &lt;br&gt; The rst3 command makes using rST or Sphinx *much* easier by automatically creating underlining for rST sections. To reorganize a document, just reorganize the corresponding Leo outline: you don't have to change underlining characters by hand. &lt;br&gt;  &lt;br&gt; The tutorial covers only the basic features of the rst3 command. This is enough to generate all of Leo's documentation! &lt;br&gt;  &lt;br&gt; CheatSheet.leo contains an expanded version of the example used in this tutorial. You can open CheatSheet.leo from Leo's help menu. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="95" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3" links="282 283 284 285 286 287 288 289 290 291 292 293 294" title="@rst html\tutorial-rst3.html" />
<node body="@wrap &lt;br&gt;  &lt;br&gt; .. |---| unicode:: U+02015 .. for quotes &lt;br&gt;    :trim: &lt;br&gt;     &lt;br&gt; #################### &lt;br&gt; Programming with Leo &lt;br&gt; #################### &lt;br&gt;  &lt;br&gt;     &quot;We who use Leo know that it is a breakthrough tool and a whole new way &lt;br&gt;     of writing code.&quot;---Joe Orr &lt;br&gt;  &lt;br&gt; Now we come to the programming features that distinguish Leo from all other programming environments. Several kinds of nodes create external files. This tutorial discusses four of them: @clean, @file, @edit and @auto. @clean is recommended for most purposes. &lt;br&gt;  &lt;br&gt; Please study this section carefully if you intend to use Leo for programming. If you get stuck, please `ask for help &lt;https://groups.google.com/forum/#!forum/leo-editor&gt;`_ immediately. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 2 &lt;br&gt; " id="96" linkTypes="3 3 3 3 3 3 3" links="295 296 297 298 299 300 301" title="@rst html\tutorial-programming.html" />
<node body="@ @rst-options &lt;br&gt; .. A very cool option: doc parts will be rendered properly, &lt;br&gt; .. but will be ignored by the Execute script command. &lt;br&gt; .. &lt;br&gt; show_doc_parts_as_paragraphs = True &lt;br&gt; @c &lt;br&gt;  &lt;br&gt; .. |---| unicode:: U+02015 .. for quotes &lt;br&gt;    :trim: &lt;br&gt;  &lt;br&gt; ######################### &lt;br&gt; Scripting Leo with Python &lt;br&gt; ######################### &lt;br&gt;  &lt;br&gt;     &quot;Leo a way to make a &quot;living&quot; document. A document built out of &lt;br&gt;     discrete parts that can be re-organized on the fly to meet the needs of &lt;br&gt;     a varying audience... just the possibility of keeping system &lt;br&gt;     maintenance scripts in the IT manual is mind boggling.&quot;---David Nichols &lt;br&gt;  &lt;br&gt; This chapter tells how to write **Leo scripts**, Python scripts run from &lt;br&gt; any Leo node. This chapter also discusses several topics related to &lt;br&gt; scripting: autocompletion, @button and @test. &lt;br&gt;  &lt;br&gt; This chapter is intended for those fairly comfortable with Python &lt;br&gt; scripting. If you are not, please study the excellent `Python Tutorial &lt;http://docs.python.org/2/tutorial/&gt;`_. &lt;br&gt;  &lt;br&gt; As an alternative to this chapter, Jacob Peck has written a more `informal scripting tutorial &lt;http://blog.suspended-chord.info/2014/01/28/intro-to-leo-scripting/&gt;`_. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="97" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317" title="@rst html\tutorial-scripting.html" />
<node body=".. |---| unicode:: U+02015 &lt;br&gt;    :trim: &lt;br&gt;  &lt;br&gt; ################# &lt;br&gt; Leo's Users Guide &lt;br&gt; ################# &lt;br&gt;  &lt;br&gt; .. _`Leo Tutorial`: tutorial.html &lt;br&gt;  &lt;br&gt;     &quot;I have been absolutely seduced by Leo over the past few days. I tell &lt;br&gt;     you, I can not put it down. I feel like a kid with a shiny new &lt;br&gt;     bike...I'm already bursting with new ways I'd like to use the tool in &lt;br&gt;     the future.&quot;---Lyn Adams Headley &lt;br&gt;  &lt;br&gt;      &lt;br&gt; This is Leo's Users Guide. It covers additional material not covered in the &lt;br&gt; `Leo Tutorial`_. &lt;br&gt;  &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 2 &lt;br&gt;  &lt;br&gt;    customizing &lt;br&gt;    rstplugin3 &lt;br&gt;    plugins &lt;br&gt;    commands &lt;br&gt;    directives &lt;br&gt;  &lt;br&gt; " id="98" linkTypes="1" links="27" title="@rst html/usersguide.html" />
<node body="" id="99" linkTypes="3" links="318" title="Customizing Leo" />
<node body="" id="100" linkTypes="3" links="319" title="Creating documents with the rst3 Command" />
<node body="" id="101" linkTypes="3" links="320" title="Plugins" />
<node body="" id="102" linkTypes="3 3" links="321 322" title="Commands Reference" />
<node body="This is a reference for all of Leo's directives. &lt;br&gt;  &lt;br&gt; This sections assumes you are *thoroughly* familiar with `Leo's tutorial`_. &lt;br&gt;  &lt;br&gt; " id="103" linkTypes="3" links="323" title="Directives Reference" />
<node body="###################### &lt;br&gt; Leo and Other Programs &lt;br&gt; ###################### &lt;br&gt;  &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 2 &lt;br&gt;  &lt;br&gt;    emacs &lt;br&gt;    vimBindings &lt;br&gt;    leoBridge &lt;br&gt;    IPythonBridge &lt;br&gt;    zodb &lt;br&gt;  &lt;br&gt; " id="104" linkTypes="1" links="28" title="@rst html/leoandotherprograms.html" />
<node body="" id="105" linkTypes="3" links="324" title="Leo and Emacs" />
<node body="" id="106" linkTypes="3" links="325" title="Leo and Vim" />
<node body="" id="107" linkTypes="3" links="326" title="ILeo - the IPython bridge" />
<node body="" id="108" linkTypes="3" links="327" title="Embedding Leo with the leoBridge module" />
<node body="" id="109" linkTypes="3" links="328" title="Leo and ZODB" />
<node body="################### &lt;br&gt; Advanced Topics &lt;br&gt; ################### &lt;br&gt;  &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 2 &lt;br&gt;  &lt;br&gt;    coloring &lt;br&gt;    writingPlugins &lt;br&gt;    unitTesting &lt;br&gt;    debuggers &lt;br&gt;     &lt;br&gt; .. toctree:: &lt;br&gt;    :maxdepth: 1 &lt;br&gt;  &lt;br&gt;    scripting-miscellany &lt;br&gt;    theory &lt;br&gt;    vim-theory &lt;br&gt;    leonine-world &lt;br&gt;  &lt;br&gt; .. atShadow" id="110" linkTypes="1" links="29" title="@rst html/intermediatetopics.html" />
<node body="" id="111" linkTypes="3" links="329" title="Controlling syntax coloring" />
<node body=".. Most of this has nothing to do with *writing* plugins." id="112" linkTypes="3" links="330" title="Writing Plugins" />
<node body="" id="113" linkTypes="3" links="331" title="Unit testing with Leo" />
<node body="" id="114" linkTypes="3" links="332" title="Debugging with Leo" />
<node body="" id="115" linkTypes="3" links="333" title="A scripting miscellany" />
<node body="" id="116" linkTypes="3" links="334" title="Exploring Leo's Code Base" />
<node body="" id="117" linkTypes="3" links="335" title="Vim Mode Theory of Operation" />
<node body="" id="118" linkTypes="3" links="336" title="The Leonine world" />
<node body="################# &lt;br&gt; Leo's Cheat Sheet &lt;br&gt; ################# &lt;br&gt;  &lt;br&gt; .. |br| raw:: html &lt;br&gt;  &lt;br&gt;    &lt;br /&gt; &lt;br&gt;     &lt;br&gt; **Important**: The easiest way to find documentation is to search LeoDocs.leo. &lt;br&gt;     &lt;br&gt; .. _`Directives reference`: directives.html &lt;br&gt; .. _`Commands Reference`: commands.html &lt;br&gt; .. _`userAttributes`: customizing.html#adding-extensible-attributes-to-nodes-and-leo-files &lt;br&gt; .. _`Customizing Leo`: customizing.html &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 4 &lt;br&gt; " id="119" linkTypes="3 3 3 3 3 3 3 3 3 3 3" links="337 338 339 340 341 342 343 344 345 346 347" title="@rst html\cheatsheet.html" />
<node body="############## &lt;br&gt; History of Leo &lt;br&gt; ############## &lt;br&gt;  &lt;br&gt; This chapter discusses the most important milestones in history of Leo and summarizes each of Leo's public releases.  The focus is on the *important* and *interesting* developments.  It is not a chronicle of every change made to Leo. &lt;br&gt;  &lt;br&gt; One of Leo's most important developments, @button, came directly from e's dyna_menu plugin. The exact date seems lost, but it certainly existed by Leo 4.3. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="120" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371" title="@rst html/history.html" />
<node body="########## &lt;br&gt; Appendices &lt;br&gt; ########## &lt;br&gt;  &lt;br&gt; .. |br| raw:: html &lt;br&gt;  &lt;br&gt;    &lt;br /&gt; &lt;br&gt;     &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="121" linkTypes="3 3 3 3 3 3" links="372 373 374 375 376 377" title="@rst html/appendices.html" />
<node body="######### &lt;br&gt; Glossary &lt;br&gt; ######### &lt;br&gt;  &lt;br&gt; .. Links &lt;br&gt; .. _`Customizing Leo`:              customizing.html &lt;br&gt; .. _`Writing plugins and hooks`:    writingPlugins.html &lt;br&gt; .. _`Leo's reference`:              directives.html &lt;br&gt; .. _`leo's tutorial`:               tutorial.html &lt;br&gt;  &lt;br&gt; This is a short glossary of important terms in Leo's world. For more information about terms, look in the index for links to discussions in other places, especially in `Leo's Tutorial`_ and `Leo's Reference`_. &lt;br&gt;  &lt;br&gt; .. glossary:: &lt;br&gt;     :sorted: &lt;br&gt; " id="122" linkTypes="3 3 3 3 3 3 3" links="378 379 380 381 382 383 384" title="@rst html/glossary.html" />
<node body="################## &lt;br&gt; What's New in Leo &lt;br&gt; ################## &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 2 &lt;br&gt; " id="123" linkTypes="3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="385 6 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404" title="@rst html/what-is-new.html" />
<node body="Changed ClassDef, do_arg, do_arguments, FunctionDef, With nodes." id="124" linkTypes="1" links="37" title="Added support for Python-3 ast nodes" />
<node body="Directives are now recognized at end of body text. &lt;br&gt;  &lt;br&gt; Changed g.get_directives_dict." id="125" linkTypes="1" links="37" title="Cleaned up use of regex to discover Leo directives" />
<node body="The old way made it almost impossible to delete stylesheet element. &lt;br&gt;  &lt;br&gt; The change was to fc.putStyleSheetLine. &lt;br&gt; " id="126" linkTypes="1" links="37" title="Create xml stylesheet elements only from settings" />
<node body="Section Reference causes clone on Leo-Editor file open &lt;br&gt; https://github.com/leo-editor/leo-editor/issues/132 &lt;br&gt;  &lt;br&gt; Removed @+middle and @-middle sentinels. &lt;br&gt;  &lt;br&gt; This is a duplicate: &lt;br&gt; #89: Spontaneous clones when using &lt;&lt;sections&gt;&gt; &lt;br&gt; https://github.com/leo-editor/leo-editor/issues/89 &lt;br&gt; " id="127" linkTypes="1" links="37" title="Fixed #132: Section Reference causes clone on Leo-Editor file open" />
<node body="https://github.com/leo-editor/leo-editor/issues/156 &lt;br&gt;  &lt;br&gt; " id="128" linkTypes="1" links="37" title="Fixed #156: ILeo errors not piped to Log and Do not show in Ipython console" />
<node body="https://github.com/leo-editor/leo-editor/issues/180 &lt;br&gt;  &lt;br&gt; Terry: &lt;br&gt; I suspect this is not really a bookmark specific problem. Rather, the point in code execution where visited positions are recorded for goto-prev-history-node is too &quot;high&quot;, so that a lot of things which change the selected node are missed by it. &lt;br&gt;  &lt;br&gt; What is the definition of visiting a node? It could be giving focus to the body editor, but that would be confusing, so it seems it should be having the tree drawn with a node selected counts as visiting the node. &lt;br&gt; " id="129" linkTypes="1" links="37" title="Fixed #180: goto-prev-history-node bugged with bookmarks" />
<node body="https://github.com/leo-editor/leo-editor/issues/221 &lt;br&gt;  &lt;br&gt; Also #251: goto-global-line is inaccurate with @clean &lt;br&gt; https://github.com/leo-editor/leo-editor/issues/251 &lt;br&gt; " id="130" linkTypes="1" links="37" title="Fixed #221: goto-global-line navigating to wrong line reported by PyLint" />
<node body="https://github.com/leo-editor/leo-editor/issues/241 &lt;br&gt;  &lt;br&gt; Changed replaceClipboardWith." id="131" linkTypes="1" links="37" title="Fixed #241: QMimeData..." />
<node body="https://github.com/leo-editor/leo-editor/issues/242 &lt;br&gt;  &lt;br&gt; The fix was to rstw.write in plugins/writers/leo_rst.py &lt;br&gt; " id="132" linkTypes="1" links="37" title="Fixed #242: @auto-rst open/save error" />
<node body="https://github.com/leo-editor/leo-editor/issues/245 &lt;br&gt;  &lt;br&gt; The fix was to LM.computeFilesList. &lt;br&gt; " id="133" linkTypes="1" links="37" title="Fixed #245: Specifying a new Leo-Editor file on the command line no longer works" />
<node body="https://github.com/leo-editor/leo-editor/issues/247 &lt;br&gt;  &lt;br&gt; The fix was to get_external_file_with_sentinels: &lt;br&gt; it must not force Python sentinels. &lt;br&gt; " id="134" linkTypes="1" links="37" title="Fixed #247: @language c breaks goto-global-line" />
<node body="https://github.com/leo-editor/leo-editor/issues/249 &lt;br&gt;  &lt;br&gt; As noted in the checkin log for this bug, I can not recommend the stickynote plugin as it is, even with the bug fixed. &lt;br&gt; " id="135" linkTypes="1" links="37" title="Fixed #249: Leo and Stickynote plugin do not request to save" />
<node body="https://github.com/leo-editor/leo-editor/issues/251" id="136" linkTypes="1" links="37" title="Fixed #251: goto-global-line is inaccurate with @clean" />
<node body="https://github.com/leo-editor/leo-editor/issues/252 &lt;br&gt; " id="137" linkTypes="1" links="37" title="Fixed #252: goto-next clone activate chapter view" />
<node body="https://github.com/leo-editor/leo-editor/issues/258 &lt;br&gt; " id="138" linkTypes="1" links="37" title="Fixed #258: leoBridge does not work with @auto-md" />
<node body="# https://github.com/leo-editor/leo-editor/issues/261 &lt;br&gt; " id="139" linkTypes="1" links="37" title="Fixed #261: exception executing equal-sized-panes" />
<node body="https://groups.google.com/d/msg/leo-editor/9KnhXmusJVY/BiNFmyPcBwAJ &lt;br&gt; @string initial_split_orientation = horizontal no effect. &lt;br&gt;  &lt;br&gt; #264: Solution to #261 needs improvement &lt;br&gt; https://github.com/leo-editor/leo-editor/issues/264 &lt;br&gt;  &lt;br&gt; If you go from the initial layout to a custom layout and then back to &quot;Default&quot;, you get a layout the *looks* like the default, but has no splitter 'splitter_2'. The splitters are unnamed. &lt;br&gt;  &lt;br&gt; So rather than searching for the splitter called splitter_2, you'd need to search for the splitter containing the two panes usually separated by splitter 2. &lt;br&gt; " id="140" linkTypes="1" links="37" title="Fixed #264: Solution to #261 needs improvement" />
<node body="https://github.com/leo-editor/leo-editor/issues/265 &lt;br&gt;  &lt;br&gt; Discussion &lt;br&gt; https://groups.google.com/forum/#!topic/leo-editor/Tlf4FVwDDSY &lt;br&gt; " id="141" linkTypes="1" links="37" title="Fixed #265: Erratic scrolling bug" />
<node body="https://github.com/leo-editor/leo-editor/issues/268 &lt;br&gt; " id="142" linkTypes="1" links="37" title="Fixed #268: cff &amp; cfa could search some @all trees" />
<node body="Leo's keyboard events doesn't work after &quot;Insert&quot; on headline and Alt+Tab Alt+Tab. &lt;br&gt; https://github.com/leo-editor/leo-editor/issues/270 &lt;br&gt;  &lt;br&gt; Strange behavior when I leave Leo (Alt+Tab) after &quot;Insert&quot; on headline node. &lt;br&gt;  &lt;br&gt; When I come back (Alt+Tab) to Leo only the menu works (Alt+F, ...) and the mouse. &lt;br&gt;  &lt;br&gt; Other unusual behavior: &lt;br&gt; left-arrow, right-arrow changes between Leo documents (like Ctrl+Tab in normal behavior) &lt;br&gt; " id="143" linkTypes="1" links="37" title="Fixed #270: Leo's keyboard events don't work after..." />
<node body="https://github.com/leo-editor/leo-editor/issues/279 &lt;br&gt;  &lt;br&gt; - Revert moves the reverted tab to the right. &lt;br&gt; - Leo hangs afterwards when closing! &lt;br&gt; " id="144" linkTypes="1" links="37" title="Fixed #279: Revert bugs with tabs" />
<node body="https://groups.google.com/d/msg/leo-editor/2fd69lLvPV4/RPIn7AQdBgAJ &lt;br&gt;  &lt;br&gt; At startup only, if the QTreeWidget needs to scroll to show a node near the end of the outline, the widget doesn't scroll far enough! The bug only happens on the initial draw of an outline.  Once a new node is selected, the bug goes away permanently. &lt;br&gt;  &lt;br&gt; Fixed at a039305. &lt;br&gt; " id="145" linkTypes="1" links="37" title="Fixed an ancient scrolling problem" />
<node body="The fix was in u.undoInsertNode &lt;br&gt; " id="146" linkTypes="1" links="37" title="Fixed bug: Undo paste-node selected the wrong node" />
<node body="LeoQtGui.destroySelf now calls qtApp.quit, not exit. &lt;br&gt; closeLeoWindow now calls g.app.windowList.remove(frame). &lt;br&gt; (It used to be done in destroyWindow)." id="147" linkTypes="1" links="37" title="Fixed shutdown hard crash on Python 3" />
<node body="https://groups.google.com/d/msg/leo-editor/1eNTdxLUXJs/y6xUsxdvBwAJ &lt;br&gt;  &lt;br&gt; The problem was an apparent reversion. VimEvent's now need a &quot;c&quot; ivar. &lt;br&gt; " id="148" linkTypes="1" links="37" title="Fixed vim-mode problems" />
<node body="Leo reading CheatSheet settings &lt;br&gt; https://groups.google.com/forum/#!topic/leo-editor/cicfbqZn1lQ &lt;br&gt;  &lt;br&gt; https://github.com/leo-editor/leo-editor/issues/129 &lt;br&gt; Font setting overridden by new workbook &lt;br&gt; " id="149" linkTypes="1" links="37" title="Investigated #129: Font setting overridden by new workbook" />
<node body="https://github.com/leo-editor/leo-editor/issues/205 &lt;br&gt; " id="150" linkTypes="1" links="37" title="Investigated #205: @ or @doc does't work perfectly in @clean" />
<node body="https://github.com/leo-editor/leo-editor/issues/248 &lt;br&gt; " id="151" linkTypes="1" links="37" title="Investigated #248:  Empty lines in @file/@clean trees" />
<node body="- @data qt-scintilla-styles *only* works in leoSetting.leo, not myLeoSettings.leo. &lt;br&gt; " id="152" linkTypes="1" links="37" title="Investigated #280: @data qt-scintilla-styles only works in leoSetting.leo" />
<node body="Names in docstrings cause trouble in Python 2. &lt;br&gt;  &lt;br&gt; Rather than trying to figure out workarounds, @button jEdit2Py now refuses to run on Python 2. &lt;br&gt; " id="153" linkTypes="1" links="37" title="jEdit2py now runs only on Python 3" />
<node body="Changed k.strokeFromSetting." id="154" linkTypes="1" links="37" title="Leo now allows bindings to numbers!" />
<node body="Call c.initialFocusHelper in several places." id="155" linkTypes="1" links="37" title="Leo now honors @bool outline_pane_has_initial_focus" />
<node body="fc.getLeoFile queues the second redraw at idle time!" id="156" linkTypes="1" links="37" title="The last outline node is now always visible." />
<node body="@chapter is now allowed anywhere. No need for @chapters. &lt;br&gt;  &lt;br&gt; The 'main' chapter is simply a synonym for the entire outline. &lt;br&gt;  &lt;br&gt; At present, the NEW switch in leoChapters.leo enables the new code. &lt;br&gt;  &lt;br&gt; Proposal: remove/improve all chapter commands &lt;br&gt; https://groups.google.com/d/msg/leo-editor/-mv2x_6TAdM/Bgntt7b9AgAJ &lt;br&gt;  &lt;br&gt; Done: &lt;br&gt; - Removed most @chapters commands &amp; helpers. &lt;br&gt; - Removed new_code switch. &lt;br&gt; - Enable/disable Chapters icon based on @bool use_chapter_tabs. &lt;br&gt; - Fixed bug in Chapter.unselect: examine the hoist stack. &lt;br&gt; - Create chapter-select-&lt;chapter-name&gt; commands. &lt;br&gt; - Allow @key convention in @chapter nodes. &lt;br&gt;  &lt;br&gt;  &lt;br&gt; " id="157" linkTypes="1" links="38" title="Improved chapters" />
<node body="- Properly spelled words are never looked up more than once in the main dictionary. &lt;br&gt; - A regex finds all words quickly. Underscores are not part of words. &lt;br&gt; " id="158" linkTypes="1" links="38" title="Improved Leo's spell tab" />
<node body="Announcement: https://groups.google.com/d/msg/leo-editor/nzat_RHqRxQ/HLz7fBolAQAJ &lt;br&gt; Json schema: site-packages\nbformat\v4\nbformat.v4.schema.json &lt;br&gt;  &lt;br&gt; Added support for @auto x.ipynb. &lt;br&gt;  &lt;br&gt; Kent: It would be great to be able to jump between Leo's nodes and IPython's cells, each offering a different set of cool functionality. &lt;br&gt;  &lt;br&gt; Alia K: Leo + Ipython notebook integration is a killer app indeed. &lt;br&gt;  &lt;br&gt;  &lt;br&gt; - Added leo/plugins/importer/ipynb.py &amp; leo/plugins/writers/ipynb.py &lt;br&gt;  &lt;br&gt; How to use sphinx with markdown: &lt;br&gt; - https://github.com/spatialaudio/nbsphinx/ &lt;br&gt; - http://nbsphinx.readthedocs.org/en/0.2.5/usage.html#Sphinx-Setup &lt;br&gt; " id="159" linkTypes="1" links="38" title="Leo now supports Jupyter (.ipynb) files" />
<node body="" id="160" linkTypes="1" links="38" title="Leo now allows plain keys to be found in the outline pane" />
<node body="Wishlist item: &lt;br&gt; https://github.com/leo-editor/leo-editor/issues/255 &lt;br&gt;  &lt;br&gt; Announcement: &lt;br&gt; https://groups.google.com/d/msg/leo-editor/eYhXWok6jck/4KwtpiRyBgAJ &lt;br&gt;  &lt;br&gt; Added @rst-table and related code. &lt;br&gt; " id="161" linkTypes="1" links="38" title="The rst3 command now supports @rst-table" />
<node body="The qt show-invisibles code initially affected word-wrap." id="162" linkTypes="1" links="38" title="The show-invisibles command uses Qt characters" />
<node body="Path to inkscape template file &lt;br&gt; " id="163" linkTypes="1" links="47" title="@string inkscape-template = ../docs/inkscape-template.svg" />
<node body="Path to Inkscape executable &lt;br&gt; " id="164" linkTypes="1" links="47" title="@string inkscape-bin = &quot;c:\Program Files (x86)\Inkscape\inkscape.exe&quot;" />
<node body="This option applies to directories specified in filenames in all kinds of @file trees, and to filenames specified in the @path directive. &lt;br&gt;  &lt;br&gt; True:  Leo attempts to create directories if they do not exist. &lt;br&gt; False: Leo never attempts to create directories. &lt;br&gt; " id="165" linkTypes="1" links="48" title="@@bool create_nonexistent_directories = True" />
<node body="" id="166" linkTypes="1" links="48" title="@bool fixedWindow = False" />
<node body="@nocolor-node &lt;br&gt;  &lt;br&gt; Formerly, this had to be on because the expansion bits &lt;br&gt; of @screenshot trees were significant. &lt;br&gt;  &lt;br&gt; Happily, this is no longer true. &lt;br&gt;  &lt;br&gt; True (recommended): &lt;br&gt;     Write &quot;E&quot; attribute bits in &lt;v&gt; elements. &lt;br&gt;     Leo outlines will record the expansion state of all nodes. &lt;br&gt;  &lt;br&gt; False: &lt;br&gt;     (Good for files like unitTest.leo) &lt;br&gt;     Suppress &quot;E&quot; attribute bits in &lt;v&gt; elements. &lt;br&gt;     Only the ancestors of the presently selected node will &lt;br&gt;     be expanded when Leo opens an outline. &lt;br&gt; " id="167" linkTypes="1" links="48" title="@bool put_expansion_bits_in_leo_files = False" />
<node body="" id="168" linkTypes="1" links="49" title="@bool http_active = False" />
<node body="" id="169" linkTypes="1" links="49" title="@int  port = 8080" />
<node body="" id="170" linkTypes="1" links="49" title="@string rst_http_attributename = rst_http_attribute" />
<node body="" id="171" linkTypes="1" links="50" title="@bool rst3_call_docutils = False" />
<node body="# True: generate rst markup from @code and @doc parts." id="172" linkTypes="1" links="50" title="@bool rst3_code_mode = False" />
<node body="" id="173" linkTypes="1" links="50" title="@bool rst3_debug = False" />
<node body="Used differently.  See rst2_pure_document. &lt;br&gt; " id="174" linkTypes="1" links="50" title="@bool rst3_format_headlines = True" />
<node body="# True: generate rst markup. False: generate plain text." id="175" linkTypes="1" links="50" title="@bool rst3_generate_rst = True" />
<node body="" id="176" linkTypes="1" links="50" title="@bool rst3_http_server_support = False" />
<node body="True: call body_filter to massage text. &lt;br&gt;  &lt;br&gt; Removes @ignore, @nocolor, @wrap directives. &lt;br&gt; " id="177" linkTypes="1" links="50" title="@bool rst3_massage_body = False" />
<node body="# Can be set by @rst-no-head headlines." id="178" linkTypes="1" links="50" title="@bool rst3_show_headlines = True" />
<node body="" id="179" linkTypes="1" links="50" title="@bool rst3_show_leo_directives = True" />
<node body="" id="180" linkTypes="1" links="50" title="@bool rst3_show_organizer_nodes = True" />
<node body="# True: suppress all output from rst.report()" id="181" linkTypes="1" links="50" title="@bool rst3_silent = True" />
<node body="# True: rst.report() sends output to log pane and the console pane." id="182" linkTypes="1" links="50" title="@bool rst3_verbose = False" />
<node body="# Used only if generate_rst is True." id="183" linkTypes="1" links="50" title="@bool rst3_write_intermediate_file = True" />
<node body="" id="184" linkTypes="1" links="50" title="@string rst3_default_path =" />
<node body="" id="185" linkTypes="1" links="50" title="@string rst3_stylesheet_path = ..\doc" />
<node body="" id="186" linkTypes="1" links="50" title="@string rst3_write_intermediate_extension = .txt" />
<node body="" id="187" linkTypes="3 3 3 3" links="405 406 407 408" title="Http options..." />
<node body="''' &lt;br&gt; Copy the @screenshot node (a child of this node) &lt;br&gt; to all @slide nodes under p, (an @slideshow node), &lt;br&gt; that do not contain an @screenshot node. &lt;br&gt; ''' &lt;br&gt;  &lt;br&gt; error = None &lt;br&gt; # Find this node: &lt;br&gt; h = '@button copy-@screenshot-node' &lt;br&gt; p2 = g.findNodeAnywhere(c,h) &lt;br&gt; if not p2: &lt;br&gt;     error = 'Can not find',p.h &lt;br&gt; # Find the @screenshot tree and the optional @select node. &lt;br&gt; if not error: &lt;br&gt;     select,template = None,None &lt;br&gt;     for child in p2.children(): &lt;br&gt;         if g.match_word(child.h,0,'@screenshot'): &lt;br&gt;             template = child.copy() &lt;br&gt;         if g.match_word(child.h,0,'@select'): &lt;br&gt;             select = child.copy() &lt;br&gt;     if not template: &lt;br&gt;         error = 'No template @slideshow node in %s' % p2.h &lt;br&gt; if not error: &lt;br&gt;     if not g.match_word(p.h,0,'@slideshow'): &lt;br&gt;         error = 'not an @slideshow node',p.h &lt;br&gt; if error: &lt;br&gt;     g.error(error) &lt;br&gt; else: &lt;br&gt;     c.selectPosition(template) &lt;br&gt;     c.copyOutline() &lt;br&gt;     changed = False &lt;br&gt;     b = c.undoer.beforeChangeTree(p) &lt;br&gt;     for child in p.children(): &lt;br&gt;         if not g.match_word(child.h,0,'@slide'): &lt;br&gt;             continue &lt;br&gt;         for grandChild in child.children(): &lt;br&gt;             if g.match_word(grandChild.h,0,'@screenshot'): &lt;br&gt;                 break &lt;br&gt;         else: &lt;br&gt;             changed = True &lt;br&gt;             p3 = child.insertAsLastChild() &lt;br&gt;             c.selectPosition(p3) &lt;br&gt;             c.pasteOutline() &lt;br&gt;             g.note('copied @screenshot to %s' % child.h) &lt;br&gt;             if select: &lt;br&gt;                 c.selectPosition(p3) &lt;br&gt;                 p4 = child.insertAsLastChild() &lt;br&gt;                 p4.h = select.h &lt;br&gt;                 g.note('copied %s to %s' % (select.h,child.h)) &lt;br&gt;             c.selectPosition(p3) &lt;br&gt;             c.deleteOutline(p3) &lt;br&gt;             child.contract() &lt;br&gt;     if changed: &lt;br&gt;         c.undoer.afterChangeTree(p,'copy-@screenshot',b) &lt;br&gt;     c.redraw() &lt;br&gt; " id="188" linkTypes="3 3 3 3 3 3 3" links="409 410 411 412 413 414 415" title="@@button copy-@screenshot-node" />
<node body="@language python &lt;br&gt;  &lt;br&gt; changed = 0 &lt;br&gt; b = c.undoer.beforeChangeTree(p) &lt;br&gt;  &lt;br&gt; for child in p.children(): &lt;br&gt;     s = child.b &lt;br&gt;     i = s.find('.. image::') &lt;br&gt;     if i &gt; -1: &lt;br&gt;         i,j = g.getLine(s,i) &lt;br&gt;         child.b = s[:i] + s[j+1:] &lt;br&gt;         # g.es(child.h) &lt;br&gt;         changed += 1 &lt;br&gt;  &lt;br&gt; if changed: &lt;br&gt;     g.es('changed %s nodes' % changed) &lt;br&gt;     c.undoer.afterChangeTree(p,'remove-image-directives',b) &lt;br&gt;  &lt;br&gt; " id="189" linkTypes="1" links="51" title="@@button remove-image-directives" />
<node body="@language python &lt;br&gt;  &lt;br&gt; changed = 0 &lt;br&gt; b = c.undoer.beforeChangeTree(p) &lt;br&gt; for child in p.children(): &lt;br&gt;     for child2 in child.children(): &lt;br&gt;         if g.match_word(child2.h,0,'@url built slide'): &lt;br&gt;             child2.doDelete() &lt;br&gt;             changed += 1 &lt;br&gt;             break &lt;br&gt;  &lt;br&gt; if changed: &lt;br&gt;     g.es('deleted %s nodes' % (changed)) &lt;br&gt;     c.undoer.afterChangeTree(p,'remove-@url-built-slide',b) &lt;br&gt;     c.redraw() &lt;br&gt; " id="190" linkTypes="1" links="51" title="@@button remove-built-slides" />
<node body="@language python &lt;br&gt;  &lt;br&gt; changed = 0 &lt;br&gt; b = c.undoer.beforeChangeTree(p) &lt;br&gt; for child in p.children(): &lt;br&gt;     for child2 in child.children(): &lt;br&gt;         if g.match_word(child2.h,0,'@url final output file'): &lt;br&gt;             child2.doDelete() &lt;br&gt;             changed += 1 &lt;br&gt;             break &lt;br&gt;  &lt;br&gt; if changed: &lt;br&gt;     g.es('deleted %s nodes' % (changed)) &lt;br&gt;     c.undoer.afterChangeTree(p,'remove-@url-final-output',b) &lt;br&gt;     c.redraw() &lt;br&gt; " id="191" linkTypes="1" links="51" title="@@button remove-final-output" />
<node body="d = c.scanAllDirectives(p) &lt;br&gt; mandir = d.get('path') + &quot;/html&quot; &lt;br&gt; g.es(mandir) &lt;br&gt; os.chdir(mandir) &lt;br&gt; os.system('make html') &lt;br&gt; " id="192" linkTypes="1" links="53" title="&lt;&lt; html manual &gt;&gt;" />
<node body="# you probably need to install several packages  &lt;br&gt; # to create pdf (e.g. jadetex) &lt;br&gt; mandir = d.get('path') + &quot;/html&quot; &lt;br&gt; g.es(mandir) &lt;br&gt; os.chdir(mandir) &lt;br&gt; os.system('make latex') &lt;br&gt; os.chdir('_build/latex') &lt;br&gt; os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex') &lt;br&gt; os.system('make LeoDoc.pdf') &lt;br&gt; " id="193" linkTypes="1" links="53" title="&lt;&lt; pdf manual &gt;&gt;" />
<node body="mandir = g.app.leoDir + &quot;/doc/html&quot; &lt;br&gt; g.es(mandir) &lt;br&gt; os.chdir(mandir) &lt;br&gt; os.system('make html') &lt;br&gt; " id="194" linkTypes="1" links="54" title="&lt;&lt; html manual &gt;&gt;" />
<node body="# you probably need to install several packages  &lt;br&gt; # to create pdf (e.g. jadetex) &lt;br&gt; mandir = g.app.leoDir + &quot;/doc/html&quot; &lt;br&gt; g.es(mandir) &lt;br&gt; os.chdir(mandir) &lt;br&gt; os.system('make latex') &lt;br&gt; os.chdir('_build/latex') &lt;br&gt; os.system('make all-pdf') &lt;br&gt; " id="195" linkTypes="1" links="54" title="&lt;&lt; pdf manual &gt;&gt;" />
<node body="class controller: &lt;br&gt;  &lt;br&gt;     def __init__ (self,c): &lt;br&gt;         self.c = c &lt;br&gt;         self.trace = False &lt;br&gt;  &lt;br&gt;     @others &lt;br&gt; " id="196" linkTypes="3 3 3 3 3 3 3 3" links="416 417 418 419 420 421 422 423" title="class controller" />
<node body="From Writers Workshop: https://groups.google.com/forum/#!topic/leo-editor/6zR9WK66Nz4s &lt;br&gt;  &lt;br&gt; I still think the best way to do is to put examples. I was not able to &lt;br&gt; realize how to -clearly- say this until I read a recent post talking about &lt;br&gt; how tutorials are right now regarding the hello world, and how they should be. &lt;br&gt;  &lt;br&gt; That made me realize that that is exactly what I have being missing so far: &lt;br&gt; A step by step guide of the cool things Leo can do. &lt;br&gt;  &lt;br&gt; I wish I could get a step by step guide on how to transform an outline or a &lt;br&gt; subtree into a website html and open it. That is cool but I don't know how &lt;br&gt; to do that. How to post a node into a blog How to call and run an R file &lt;br&gt; from Leo Use RST properly &lt;br&gt;  &lt;br&gt; By step by step, I mean, literally, &quot;write this in a new node&quot; &quot;write this &lt;br&gt; other thing in a sub-node&quot; &quot;Select the first node, then execute command...&quot; &lt;br&gt;  &lt;br&gt; Heck, for pretty much any export file Leo can transform an outline into, I &lt;br&gt; would actually do something like that, in a &quot;Leo quick examples&quot; so within &lt;br&gt; a few examples and step-by-step guides as the ones mentioned, the users &lt;br&gt; will see how easy is to just write information once and have it as a &lt;br&gt; website, as a document, posted into a blog, etc. &lt;br&gt;  &lt;br&gt; Thanks to the new changes in the tutorial, now I clearly know how to find &lt;br&gt; strings, but it got me some months to be able to easily do something as &lt;br&gt; simple as that. But since the new tutorial explains that step by step (copy &lt;br&gt; this, insert text etc) as soon as I read that I could do that. There are &lt;br&gt; more Leo skills that don't come to mind but often find myself wandering &lt;br&gt; about when will I be able to do those, that is why I often ask for examples &lt;br&gt; on how do you guys use things, because without those, the new user has to &lt;br&gt; figure out how are the steps by himself without guides, and even though &lt;br&gt; they are very simple, you only know how simple those are after you see them &lt;br&gt; done, before, its just something you cant even imagine that is there. &lt;br&gt; " id="197" linkTypes="1" links="63" title="Request" />
<node body="- Leo has shamelessly stolen all of Emacs's most important features: long &lt;br&gt;   command names, the minibuffer, typing completion and flexible key &lt;br&gt;   bindings. &lt;br&gt;    &lt;br&gt; - One set of Leo's default key bindings are similar to Emacs's defaults. If &lt;br&gt;   you like, editing text in Leo can feel exactly like editing text in &lt;br&gt;   Emacs. &lt;br&gt;  &lt;br&gt; - You script Leo in Python, not elisp. &lt;br&gt;  &lt;br&gt; - Emacs has no notion of nodes, cloned or otherwise. Emacs will never have &lt;br&gt;   anything like @file, @test, @button, @command or @url nodes (etc.!), not &lt;br&gt;   even in Emacs org-mode. &lt;br&gt;    &lt;br&gt; - Leo scripts have *easy* access all nodes via Leo's Document Object Model &lt;br&gt;   (DOM). Emacs has no DOM at all. In Emacs, everything is just text. &lt;br&gt;    &lt;br&gt; - Leo has no dired mode because it isn't needed. Once you have created an &lt;br&gt;   @file node (or @auto or @edit node), there is no need to drill down to &lt;br&gt;   that file. &lt;br&gt; " id="198" linkTypes="3" links="424" title="Leo vs Emacs" />
<node body="Leo's read code parses text into true Python objects: Leo's positions and vnodes. &lt;br&gt;  &lt;br&gt; As a result, Leo scripts will be **orders of magnitude faster** than similar code in vim or emacs. &lt;br&gt;  &lt;br&gt; Leo scripts will also be **orders of magnitude simpler** than similar code in vim or emacs. &lt;br&gt;  &lt;br&gt; As a result, Leo has major subsystems, such as the rst3 command, that are virtually unthinkable &lt;br&gt; in text-oriented worlds such as vim or Emacs.  It would require emulating all of Leo's &lt;br&gt; fundamental, behind-the-scenes, data structures: generators, positions, and vnodes, including &lt;br&gt; the code that creates those data structures from both .leo files (xml readers and writers)  &lt;br&gt; and external files (code that creates vnodes from sentinel comments). &lt;br&gt;  &lt;br&gt; ..  It would be easier in emacs, because elisp is more capable than the vim scripting language, &lt;br&gt; ..  but neither elisp nor vimscript is anywhere near as easy to use as Python. &lt;br&gt;  &lt;br&gt; Emulating Leo in emacs or vim would have one advantage, it would not have to duplicate &lt;br&gt; the 15+ year process of improvement in Leo's read code (sentinels), data structures (vnodes) &lt;br&gt; and support code (generators).  But this would be a gigantic effort: to get the benefits of Leo &lt;br&gt; in either vim or Emacs the leoFileCommands, leoAtFileCommands and leoNodes modules would have to &lt;br&gt; be emulated. &lt;br&gt; " id="199" linkTypes="1" links="64" title="Leo vs emacs &amp; vim" />
<node body="" id="200" linkTypes="1" links="64" title="Leo vs IPython" />
<node body="- One set of Leo's default key bindings are similar to Vim's defaults. If &lt;br&gt;   you like, editing text in Leo can feel somewhat (not exactly) like &lt;br&gt;   editing text in Emacs.  Leo has a vim-like command mode, but it's &lt;br&gt;   still a work in progress. &lt;br&gt;  &lt;br&gt; - You script Leo in Python, not Vim's scripting language. &lt;br&gt;  &lt;br&gt; - Vim has no notion of nodes, cloned or otherwise. Vim will never have &lt;br&gt;   anything like @file, @test, @button, @command or @url nodes (etc.!), not &lt;br&gt;   even in Vim's outline-mode. &lt;br&gt;    &lt;br&gt; - Leo scripts have *easy* access all nodes via Leo's Document Object Model &lt;br&gt;   (DOM). Vim has no DOM at all; everything is just text. &lt;br&gt; " id="201" linkTypes="1" links="64" title="Leo vs Vim" />
<node body="def __init__(self, opt): &lt;br&gt;  &lt;br&gt;     &quot;&quot;&quot;opt - see make_parser() or --help&quot;&quot;&quot; &lt;br&gt;  &lt;br&gt;     self.opt = opt &lt;br&gt;     self.id_num = 0  # for generating ids for the doctree &lt;br&gt;     self.document = None &lt;br&gt; " id="202" linkTypes="1" links="71" title="__init__" />
<node body="def add_ids(self, node, depth=0): &lt;br&gt;  &lt;br&gt;     &quot;&quot;&quot;Recursively add ids starting with 'lid' to doctree node. &lt;br&gt;  &lt;br&gt;     Always id the top level node, and also document, section, and topic &lt;br&gt;     nodes below it.&quot;&quot;&quot; &lt;br&gt;  &lt;br&gt;     if hasattr(node, 'tagname'): &lt;br&gt;         if depth == 0 or node.tagname in ('document', 'section', 'topic'): &lt;br&gt;             if True or not node['ids']: &lt;br&gt;                 self.id_num += 1 &lt;br&gt;                 node['ids'].append('lid'+str(self.id_num)) &lt;br&gt;         for child in node: &lt;br&gt;             self.add_ids(child, depth+1) &lt;br&gt; " id="203" linkTypes="1" links="71" title="add_ids" />
<node body="def first_text(self, node): &lt;br&gt;  &lt;br&gt;     &quot;&quot;&quot;find first paragraph to use as a summary&quot;&quot;&quot; &lt;br&gt;  &lt;br&gt;     if node.tagname == 'paragraph': &lt;br&gt;         return deepcopy(node) &lt;br&gt;     else: &lt;br&gt;         for child in node: &lt;br&gt;             if hasattr(child, 'tagname'): &lt;br&gt;                 ans = self.first_text(child) &lt;br&gt;                 if ans: &lt;br&gt;                     return ans &lt;br&gt;  &lt;br&gt;     return None &lt;br&gt; " id="204" linkTypes="1" links="71" title="first_text" />
<node body="def get_doc_strings(self): &lt;br&gt;  &lt;br&gt;     &quot;&quot;&quot;collect docstrings in .py files in specified locations&quot;&quot;&quot; &lt;br&gt;  &lt;br&gt;     doc_strings = [] &lt;br&gt;     cnt = 0 &lt;br&gt;     opt = self.opt   &lt;br&gt;  &lt;br&gt;     for loc in opt.location: &lt;br&gt;  &lt;br&gt;         for path, dummy, files in os.walk(loc): &lt;br&gt;             break  # only want the first answer &lt;br&gt;  &lt;br&gt;         for file_name in sorted(files, key=lambda x:x.lower()): &lt;br&gt;             if not file_name.lower().endswith('.py'): &lt;br&gt;                 continue &lt;br&gt;  &lt;br&gt;             file_path = os.path.join(path, file_name) &lt;br&gt;  &lt;br&gt;             doc_string = None &lt;br&gt;  &lt;br&gt;             src = open(file_path).read() &lt;br&gt;             src = src.replace('\r\n', '\n').replace('\r','\n')+'\n' &lt;br&gt;             try: &lt;br&gt;                 ast_info = ast.parse(src) &lt;br&gt;                 doc_string = ast.get_docstring(ast_info) &lt;br&gt;             except SyntaxError: &lt;br&gt;                 doc_string = &quot;**SYNTAX ERROR IN MODULE SOURCE**&quot; &lt;br&gt;  &lt;br&gt;             if not doc_string and file_name != '__init__.py': &lt;br&gt;                 doc_string = &quot;**NO DOCSTRING**&quot; &lt;br&gt;  &lt;br&gt;             if not doc_string: &lt;br&gt;                 continue  # don't whine about __init__.py &lt;br&gt;  &lt;br&gt;             if opt.show_paths: &lt;br&gt;                 err(&quot;Processing: '%s'\n&quot; % file_path) &lt;br&gt;             try: &lt;br&gt;                 doc_tree = publish_doctree(doc_string) &lt;br&gt;             except SystemMessage: &lt;br&gt;                 doc_tree = publish_doctree(&quot;&quot;&quot; &lt;br&gt;                 Docutils could not parse docstring &lt;br&gt;  &lt;br&gt;                 RST error level SEVERE/4 or higher in '%s'&quot;&quot;&quot; % &lt;br&gt;                     file_path) &lt;br&gt;  &lt;br&gt;             doc_strings.append( (file_name, file_path, doc_tree) ) &lt;br&gt;  &lt;br&gt;             cnt += 1 &lt;br&gt;             if opt.max_files and cnt == opt.max_files: &lt;br&gt;                 break &lt;br&gt;  &lt;br&gt;     return doc_strings &lt;br&gt; " id="205" linkTypes="1" links="71" title="get_doc_strings" />
<node body="def make_document(self, doc_strings): &lt;br&gt;      &lt;br&gt;     &quot;&quot;&quot;make doctree representation of collected fragments&quot;&quot;&quot; &lt;br&gt;  &lt;br&gt;     opt = self.opt   &lt;br&gt;  &lt;br&gt;     big_doc = publish_doctree(&quot;&quot;) &lt;br&gt;     self.document = big_doc &lt;br&gt;     big_doc += nodes.title(text=&quot;Plugins listing generated %s&quot; % &lt;br&gt;         time.asctime()) &lt;br&gt;  &lt;br&gt;     contents = nodes.container() &lt;br&gt;     if opt.include_contents: &lt;br&gt;         big_doc += nodes.topic('', nodes.title(text='Contents'), contents) &lt;br&gt;  &lt;br&gt;     if not opt.no_summary: &lt;br&gt;         def_list = nodes.definition_list() &lt;br&gt;         alpha_list = nodes.paragraph() &lt;br&gt;         big_doc += nodes.section('', nodes.title(text=&quot;Plugins summary&quot;), &lt;br&gt;             alpha_list, def_list) &lt;br&gt;  &lt;br&gt;     last_alpha = '' &lt;br&gt;  &lt;br&gt;     for doc in doc_strings: &lt;br&gt;          &lt;br&gt;         section = nodes.section() &lt;br&gt;         big_doc += section &lt;br&gt;         section += nodes.title(text=doc[0]) &lt;br&gt;  &lt;br&gt;         self.add_ids(section) &lt;br&gt;  &lt;br&gt;         if not opt.no_summary: &lt;br&gt;             firstpara = (self.first_text(doc[2]) or &lt;br&gt;                 nodes.paragraph(text='No summary found')) &lt;br&gt;             reference = nodes.reference('', refid=section['ids'][0], &lt;br&gt;                 name = doc[0], anonymous=1) &lt;br&gt;             reference += nodes.Text(doc[0]) &lt;br&gt;             def_list += nodes.definition_list_item('', &lt;br&gt;                 nodes.term('', '', reference), &lt;br&gt;                 nodes.definition('', firstpara) &lt;br&gt;             ) &lt;br&gt;  &lt;br&gt;             # add letter quick index entry if needed &lt;br&gt;             if doc[0][0].upper() != last_alpha: &lt;br&gt;                 last_alpha = doc[0][0].upper() &lt;br&gt;                 self.add_ids(reference) &lt;br&gt;                 alpha_list += nodes.reference('', &lt;br&gt;                     nodes.Text(last_alpha+' '), &lt;br&gt;                     refid=reference['ids'][0], name = doc[0], anonymous=1) &lt;br&gt;  &lt;br&gt;         for element in doc[2]: &lt;br&gt;             # if the docstring has titles, we need another level &lt;br&gt;             if element.tagname == 'title': &lt;br&gt;                 subsection = nodes.section()  &lt;br&gt;                 section += subsection &lt;br&gt;                 section = subsection &lt;br&gt;                 break &lt;br&gt;  &lt;br&gt;         for element in doc[2]: &lt;br&gt;             try: &lt;br&gt;                 section += element.deepcopy() &lt;br&gt;             except TypeError: &lt;br&gt;                 err( &lt;br&gt;                     'Element.deepcopy() failed, dropped element for %s\n' % &lt;br&gt;                     doc[0]) &lt;br&gt;  &lt;br&gt;     if opt.include_contents: &lt;br&gt;         contents.details = {'text': 'Contents here'} &lt;br&gt;  &lt;br&gt;         self.add_ids(big_doc) &lt;br&gt;         transform = Contents(big_doc, contents) &lt;br&gt;         transform.apply() &lt;br&gt;  &lt;br&gt;     return big_doc &lt;br&gt;      &lt;br&gt; " id="206" linkTypes="1" links="71" title="make_document" />
<node body="@staticmethod &lt;br&gt; def make_parser(): &lt;br&gt;     &quot;&quot;&quot;Return an optparse.OptionParser&quot;&quot;&quot; &lt;br&gt;  &lt;br&gt;     parser = optparse.OptionParser(&quot;Usage: plug_catalog.py [options] dir1 [dir2 ...] output.html&quot;) &lt;br&gt;  &lt;br&gt;     parser.add_option(&quot;--location&quot;, action=&quot;append&quot;, type=&quot;string&quot;, &lt;br&gt;         help=&quot;Add a location to the list to search&quot;, default=[]) &lt;br&gt;     parser.add_option(&quot;--css-file&quot;, type=&quot;string&quot;, &lt;br&gt;         help=&quot;Use this CSS file in the HTML output&quot;) &lt;br&gt;     parser.add_option(&quot;--max-files&quot;, type=&quot;int&quot;, &lt;br&gt;         help=&quot;Stop after this many files, mainly for testing&quot;) &lt;br&gt;     parser.add_option(&quot;--include-contents&quot;, action=&quot;store_true&quot;,  &lt;br&gt;         default=False, &lt;br&gt;         help=&quot;Include table of contents (the summary is more useful)&quot;) &lt;br&gt;     parser.add_option(&quot;--no-summary&quot;, action=&quot;store_true&quot;, default=False, &lt;br&gt;         help=&quot;Don't generate the summary&quot;) &lt;br&gt;     parser.add_option(&quot;--show-paths&quot;, action=&quot;store_true&quot;, default=False, &lt;br&gt;         help=&quot;Show paths to .py files, useful for resolving RST errors&quot;) &lt;br&gt;     parser.add_option(&quot;--output&quot;, type=&quot;string&quot;, default=None, &lt;br&gt;         help=&quot;Filename for the html output&quot;) &lt;br&gt;     parser.add_option(&quot;--xml-output&quot;, type=&quot;string&quot;, default=None, &lt;br&gt;         help=&quot;Filename for optional xml output, mainly for testing&quot;) &lt;br&gt;  &lt;br&gt;     return parser &lt;br&gt; " id="207" linkTypes="1" links="71" title="make_parser" />
<node body="def run(self): &lt;br&gt;  &lt;br&gt;     &quot;&quot;&quot;run with the supplied options, see make_parser()&quot;&quot;&quot; &lt;br&gt;  &lt;br&gt;     opt = self.opt   &lt;br&gt;  &lt;br&gt;     doc_strings = self.get_doc_strings() &lt;br&gt;  &lt;br&gt;     big_doc = self.make_document(doc_strings) &lt;br&gt;  &lt;br&gt;     settings_overrides = {} &lt;br&gt;     if opt.css_file: &lt;br&gt;         settings_overrides['stylesheet_path'] = opt.css_file &lt;br&gt;  &lt;br&gt;     open(opt.output, 'wb').write( &lt;br&gt;         publish_from_doctree(big_doc, writer_name='html', &lt;br&gt;             settings_overrides = settings_overrides) &lt;br&gt;     ) &lt;br&gt;     err(&quot;Wrote '%s'\n&quot; % opt.output) &lt;br&gt;  &lt;br&gt;     if opt.xml_output: &lt;br&gt;         open(opt.xml_output, 'wb').write( &lt;br&gt;             publish_from_doctree(big_doc, writer_name='xml', &lt;br&gt;                 settings_overrides = {'indents': True}) &lt;br&gt;         ) &lt;br&gt;         err(&quot;Wrote '%s'\n&quot; % opt.xml_output) &lt;br&gt; " id="208" linkTypes="1" links="71" title="run" />
<node body="&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;br&gt;  &lt;br&gt; &lt;title&gt;Leo's Home Page&lt;/title&gt; &lt;br&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;_static/default.css&quot; type=&quot;text/css&quot; /&gt; &lt;br&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;_static/pygments.css&quot; type=&quot;text/css&quot; /&gt; &lt;br&gt;  &lt;br&gt; &lt;!-- scale screen-shot to fit parent container --&gt; &lt;br&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;br&gt; img { max-width:100%; max-height:100%; } &lt;br&gt; &lt;/style&gt; &lt;br&gt;  &lt;br&gt; &lt;!-- &lt;br&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;br&gt;   var DOCUMENTATION_OPTIONS = { &lt;br&gt;     URL_ROOT:    '', &lt;br&gt;     VERSION:     '5.3', &lt;br&gt;     COLLAPSE_MODINDEX: false, &lt;br&gt;     FILE_SUFFIX: '.html', &lt;br&gt;     HAS_SOURCE:  false &lt;br&gt;   }; &lt;br&gt; &lt;/script&gt; &lt;br&gt; --&gt; &lt;br&gt; &lt;&lt; flattr head &gt;&gt; &lt;br&gt;  &lt;br&gt; &lt;&lt; feed2js stylesheet &gt;&gt; &lt;br&gt;  &lt;br&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;_static/jquery.js&quot;&gt;&lt;/script&gt;--&gt; &lt;br&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;_static/doctools.js&quot;&gt;&lt;/script&gt;--&gt; &lt;br&gt; &lt;link rel=&quot;top&quot; title=&quot;Leo 5.3 documentation&quot; href=&quot;index.html&quot; /&gt; &lt;br&gt; &lt;link rel=&quot;Users Guide&quot; title=&quot;Leo&amp;#8217;s Users Guide&quot; href=&quot;leo_toc.html&quot; /&gt; &lt;br&gt; &lt;!-- &lt;link rel=&quot;prev&quot; title=&quot;Using Leo's Commands&quot; href=&quot;commands.html&quot; /&gt;--&gt;  &lt;br&gt;  &lt;br&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;br&gt; function search(event) { &lt;br&gt;   if (event === null || (event.keyCode || event.which) === 13) { &lt;br&gt;     window.open('http://www.google.com/search?q=site:leoeditor.com+'+document.getElementById('q').value); &lt;br&gt;   } &lt;br&gt; } &lt;br&gt; &lt;/script&gt; &lt;br&gt; " id="209" linkTypes="3 3" links="425 426" title="&lt;&lt; head &gt;&gt; (home page)" />
<node body="&lt;div class=&quot;related&quot;&gt; &lt;br&gt;   &lt;h3&gt;Navigation&lt;/h3&gt; &lt;br&gt;   &lt;ul&gt; &lt;br&gt;     &lt;li class=&quot;right&quot; style=&quot;margin-right: 10px&quot;&gt; &lt;br&gt;       &lt;a href=&quot;genindex.html&quot; title=&quot;General Index&quot; &lt;br&gt;          accesskey=&quot;I&quot;&gt;index&lt;/a&gt;&lt;/li&gt; &lt;br&gt;     &lt;li class=&quot;right&quot; &gt; &lt;br&gt;       &lt;a href=&quot;glossary.html&quot; title=&quot;Glossary&quot; &lt;br&gt;          accesskey=&quot;G&quot;&gt;glossary&lt;/a&gt; |&lt;/li&gt; &lt;br&gt;     &lt;li class=&quot;right&quot; &gt; &lt;br&gt;       &lt;a href=&quot;leo_toc.html&quot; title=&quot;Users Guide&quot; &lt;br&gt;          accesskey=&quot;N&quot;&gt;contents&lt;/a&gt; |&lt;/li&gt; &lt;br&gt;     &lt;li&gt;&lt;a href=&quot;leo_toc.html&quot;&gt;Leo 5.3 documentation&lt;/a&gt;&lt;/li&gt; &lt;br&gt;     &lt;!--  &amp;raquo; --&gt; &lt;br&gt;   &lt;/ul&gt; &lt;br&gt; &lt;/div&gt; &lt;br&gt; " id="210" linkTypes="1" links="73" title="&lt;&lt; div top nav &gt;&gt;" />
<node body="&lt;div class=&quot;section&quot; id=&quot;Leo&amp;#8217;s Home page&quot;&gt; &lt;br&gt;  &lt;br&gt;     &lt;h1&gt;Leo&amp;#8217;s Home Page&lt;/h1&gt; &lt;br&gt;     &lt;&lt; Leo is... &gt;&gt; &lt;br&gt;     &lt;&lt; Leo Google group &amp; postcard &gt;&gt; &lt;br&gt;     &lt;&lt; screenshot &gt;&gt; &lt;br&gt;     &lt;&lt; embed leo-editor &gt;&gt; &lt;br&gt; &lt;/div&gt; &lt;br&gt; " id="211" linkTypes="3 3 3 3" links="427 428 429 430" title="&lt;&lt; div main section &gt;&gt; (home page)" />
<node body="&lt;div class=&quot;sphinxsidebar&quot;&gt; &lt;br&gt;     &lt;div class=&quot;sphinxsidebarwrapper&quot;&gt; &lt;br&gt;         &lt;&lt; sidebar contents &gt;&gt; &lt;br&gt;     &lt;/div&gt; &lt;br&gt; &lt;/div&gt; &lt;br&gt; " id="212" linkTypes="3" links="431" title="&lt;&lt; sidebar &gt;&gt; (home page)" />
<node body="&lt;div class=&quot;related&quot;&gt; &lt;br&gt;   &lt;h3&gt;Navigation&lt;/h3&gt; &lt;br&gt;   &lt;ul&gt; &lt;br&gt;     &lt;li class=&quot;right&quot; style=&quot;margin-right: 10px&quot;&gt; &lt;br&gt;       &lt;a href=&quot;genindex.html&quot; title=&quot;General Index&quot; &lt;br&gt;          &gt;index&lt;/a&gt;&lt;/li&gt; &lt;br&gt;     &lt;li class=&quot;right&quot; &gt; &lt;br&gt;       &lt;a href=&quot;glossary.html&quot; title=&quot;Glossary&quot; &lt;br&gt;          accesskey=&quot;G&quot;&gt;glossary&lt;/a&gt; |&lt;/li&gt; &lt;br&gt;     &lt;li class=&quot;right&quot; &gt; &lt;br&gt;       &lt;a href=&quot;leo_toc.html&quot; title=&quot;Users Guide&quot; &lt;br&gt;          &gt;contents&lt;/a&gt; |&lt;/li&gt; &lt;br&gt;  &lt;br&gt;     &lt;li&gt;&lt;a href=&quot;leo_toc.html&quot;&gt;Leo 5.3 documentation&lt;/a&gt;&lt;/li&gt;  &lt;br&gt;   &lt;/ul&gt; &lt;br&gt; &lt;/div&gt; &lt;br&gt; " id="213" linkTypes="1" links="73" title="&lt;&lt; div bottom nav &gt;&gt;" />
<node body="&lt;div class=&quot;footer&quot;&gt; &lt;br&gt;   &amp;copy; Copyright 2001-2016, Edward K. Ream. &lt;br&gt;   Last updated on May 1, 2016. &lt;br&gt;   Created using &lt;a href=&quot;http://sphinx.pocoo.org/&quot;&gt;Sphinx&lt;/a&gt; 1.1. &lt;br&gt; &lt;/div&gt; &lt;br&gt; " id="214" linkTypes="1" links="73" title="&lt;&lt; div footer &gt;&gt;" />
<node body="To create a slideshow with sphinx: &lt;br&gt;  &lt;br&gt; cd leo\doc\html\slides\slideshow-name &lt;br&gt; make html &lt;br&gt;  &lt;br&gt; To generate screenshots from Wink &amp; meld-slides &amp; make-slide: &lt;br&gt;  &lt;br&gt; 1. Plan slides carefully.  Insert @no-screenshot nodes for @slide &lt;br&gt;    nodes that will not have screenshots. &lt;br&gt;  &lt;br&gt;    Know the numbering of slides. I use the following kinds of comments &lt;br&gt;    to keep track of expected screenshots: &lt;br&gt;  &lt;br&gt;         .. no screenshot &lt;br&gt;         .. sc 5: description &lt;br&gt;  &lt;br&gt; 2. Using the script in @slide nodes, take the screenshots in Wink. &lt;br&gt;  &lt;br&gt;    I use a **screenshots.bat** script that starts screenshots.leo with &lt;br&gt;    a standard size (900x700) window. &lt;br&gt;  &lt;br&gt; 3. Create the screenshots using Wink's Export As Html command. &lt;br&gt;    The exact file names don't matter, but they should be .png files. &lt;br&gt;  &lt;br&gt; 4. Create an @wink_path node in the @slideshow tree pointing &lt;br&gt;    to the screenshot folder. &lt;br&gt;  &lt;br&gt; 5. Run the meld-slides command to create @url final output file nodes. &lt;br&gt;  &lt;br&gt; 6. Double-click @url final output nodes to edit them in InkScape. &lt;br&gt;  &lt;br&gt; 7. Run the make-slide command on the individual @slide nodes. &lt;br&gt;    The creates the @url built slide node and runs the actual make, &lt;br&gt;    which creates the _build directory in the slideshow directory. &lt;br&gt;  &lt;br&gt; 8. The make-slide-show command is useful for quickly generating &lt;br&gt;    @url built slide nodes in batches. &lt;br&gt;  &lt;br&gt; 9. Copy the *contents* of the *slideshow's* _build/html directory to &lt;br&gt;    the proper slideshow directory of the server. Do *not* just copy &lt;br&gt;    the entire _build directory to the server. &lt;br&gt; " id="215" linkTypes="1" links="74" title="How to create slideshows" />
<node body="" id="216" linkTypes="3 3" links="432 433" title="To do: slideshows" />
<node body="" id="217" linkTypes="3 3 3 3 3 3" links="434 435 436 437 438 439" title="@slideshow Installation" />
<node body="@pagewidth 50 &lt;br&gt; " id="218" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465" title="@slideshow Leo basics step by step" />
<node body="@pagewidth 50 &lt;br&gt;  &lt;br&gt; .. This slideshow will have no screenshots. &lt;br&gt;  &lt;br&gt; " id="219" linkTypes="3 3 3 3 3 3 3 3 3 3 3" links="466 467 468 469 470 471 472 473 474 475 476" title="@slideshow Scripting Leo" />
<node body="@pagewidth 60 &lt;br&gt; " id="220" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3" links="477 478 479 480 481 482 483 484 485 486 487 488" title="@slideshow Using Leo's minibuffer" />
<node body="@pagewidth 60 &lt;br&gt; " id="221" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3" links="489 490 491 492 493 494 495 496 497 498 499 500 501" title="@slideshow Clones and views" />
<node body="@pagewidth 60 &lt;br&gt; " id="222" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524" title="@slideshow External files" />
<node body=".. |leoQtMainWindow|    image:: screen-shots/leo-main-window.png &lt;br&gt;  &lt;br&gt; Here is Leo's main window on Windows 7 showing &lt;br&gt; the outline pane (1), &lt;br&gt; the body pane (2), &lt;br&gt; the minibuffer (3), &lt;br&gt; the log pane, showing the find tab (4). &lt;br&gt;  &lt;br&gt; The body pane shows the contents of the presently selected node in the outline pane. &lt;br&gt;  &lt;br&gt; |leoQtMainWindow| &lt;br&gt;  &lt;br&gt; .. _`reStructuredText`: http://docutils.sourceforge.net/rst.html &lt;br&gt;  &lt;br&gt; .. |renderRST|      image:: screen-shots/render-rst.png &lt;br&gt; .. |renderSVGref|   image:: screen-shots/render-svg-movie.png &lt;br&gt; .. |renderSVGsrc|   image:: screen-shots/render-svg-sources.png &lt;br&gt; .. |renderSplash|   image:: screen-shots/render-splash-screen.png &lt;br&gt;  &lt;br&gt; The following screenshots show Leo's rendering pane.  It can render `reStructuredText`_: &lt;br&gt;  &lt;br&gt; |renderRST| &lt;br&gt;  &lt;br&gt; The rendering pane can render svg pictures, including animated pictures.  Here we see &lt;br&gt; an .svg file included by reference: &lt;br&gt;  &lt;br&gt; |renderSVGref| &lt;br&gt;  &lt;br&gt; The rendering pane can also render svg sources contained in the body pane: &lt;br&gt;  &lt;br&gt; |renderSVGsrc| &lt;br&gt;  &lt;br&gt; The rendering pane can show pictures, music and movies.  Here we see Leo's splash screen: &lt;br&gt;  &lt;br&gt; |renderSplash| &lt;br&gt; " id="223" linkTypes="1" links="77" title="Windows screen shots" />
<node body=".. |LinuxMainWindow| image:: screen-shots/leo-qt-main-window-linux.png &lt;br&gt;  &lt;br&gt; Here is Leo's main window as it appears on Linux: &lt;br&gt;  &lt;br&gt; |LinuxMainWindow| &lt;br&gt; " id="224" linkTypes="1" links="77" title="Linux screen shots" />
<node body="I just tweaked conf.py a bit to enable pdf generation. &lt;br&gt;  &lt;br&gt; Howto: &lt;br&gt;  &lt;br&gt; QQQ &lt;br&gt;  &lt;br&gt; 4. To create pdf (probably easiest on Linux, with necessary latex &lt;br&gt; packages installed): &lt;br&gt;  &lt;br&gt; - make latex &lt;br&gt; - cd _build/latex &lt;br&gt; - make all-pdf &lt;br&gt;  &lt;br&gt; QQQ &lt;br&gt;  &lt;br&gt; There were several errors in the pdf generation process. Notably, &lt;br&gt; there are probably lots of unicode errors (and toc doesn't appear). &lt;br&gt; Nevertheless, you can steal a peek at the doc here: &lt;br&gt;  &lt;br&gt; http://vvtools.googlecode.com/files/Leodocumentation.pdf  &lt;br&gt; " id="225" linkTypes="1" links="80" title="Post from ville" />
<node body="==== &lt;br&gt; Test &lt;br&gt; ==== &lt;br&gt;  &lt;br&gt; This is a test. &lt;br&gt; " id="226" linkTypes="3" links="525" title="@rst c:/test/test.html" />
<node body="&quot;I am using Leo since a few weeks and I brim over with enthusiasm for it. I think it is the most amazing software since the invention of the spreadsheet.&quot;---Anon. &lt;br&gt;  &lt;br&gt; &quot;We who use Leo know that it is a breakthrough tool and a whole new way of writing code.&quot;---Joe Orr &lt;br&gt;  &lt;br&gt; &quot;I am a huge fan of Leo. I think it's quite possibly the most revolutionary programming tool I have ever used and it (along with the Python language) has utterly changed my view of programming (indeed of writing) forever.&quot;---Shakeeb Alireza &lt;br&gt;  &lt;br&gt; &quot;Thank you very much for Leo. I think my way of working with data will change forever... I am certain [Leo] will be a revolution. The revolution is as important as the change from sequential linear organization of a book into a web-like hyperlinked pages. The main concept that impress me is that the source listing isn't the main focus any more. You focus on the non-linear, hierarchical, collapsible outline of the source code.&quot;---Korakot Chaovavanich &lt;br&gt;  &lt;br&gt; &quot;Leo is a quantum leap for me in terms of how many projects I can manage and how much information I can find and organize and store in a useful way.&quot;---Dan Winkler &lt;br&gt;  &lt;br&gt; &quot;Wow, wow, and wow...I finally understand how to use clones and I realized that this is exactly how I want to organize my information. Multiple views on my data, fully interlinkable just like my thoughts.&quot;---Anon &lt;br&gt;  &lt;br&gt; &quot;Edward... you've come up with perhaps the most powerful new concept in code manipulation since VI and Emacs.---David McNab &lt;br&gt;  &lt;br&gt; &quot;Leo is...a revolutionary step in the right direction for programming.&quot;---Brian Takita &lt;br&gt; " id="227" linkTypes="1" links="84" title="Leo is revolutionary" />
<node body="&quot;Thanks for a wonderful program – everybody should be using it! It blows the socks off that Java Mind mapping software that won project of the month a while back on sourceforge!&quot;---Derick van Niekerk. &lt;br&gt;  &lt;br&gt; &quot;A few years back I would have said Zope was #1 Python showcase, but I agree 100% that Leo is tops now.&quot;---Jason Cunliffe &lt;br&gt;  &lt;br&gt; &quot;Leo is the most interesting Python project I know of...I see lots of stuff posted on the Daily Python page, but I usually yawn and come over to this forum to see what's cooking.&quot;---Anon &lt;br&gt;  &lt;br&gt; &quot;What an original synthesis of different ideas, why can't other Open Source projects change the way I think?&quot;---Anon &lt;br&gt; " id="228" linkTypes="1" links="84" title="Leo is a showcase Python application" />
<node body="&quot;When first I opened Leo, it was out of curiosity. But having used it...I'll never go back. They'll have to pry Leo out of my cold, dead fingers! Seriously, it should be renamed 'Crack Cocaine' because it's that addictive. I'm ready to start a 12-Step group.&quot;---Travers A. Hough &lt;br&gt;  &lt;br&gt; &quot;I feel addicted to programming again...in fact [Leo] has resurrected a dead project of mine :) The Outline has proven most liberating in terms of testing ideas out.&quot;---Anon &lt;br&gt;  &lt;br&gt; &quot;I have been absolutely seduced by Leo over the past few days. I tell you, I can not put it down. I feel like a kid with a shiny new bike...I'm already bursting with new ways I'd like to use the tool in the future.&quot;---Lyn Adams Headley &lt;br&gt;  &lt;br&gt; Thanks for the great work--I love Leo!!!---Josef Dalcolmo &lt;br&gt;  &lt;br&gt; Leo has simplified updating and creating new scripts and .bats keeping similar information in the same place. there is almost an addictive withdrawal effect when I can complete an operation in so much less time with Leo &amp; python than I had become used to.---Anon &lt;br&gt;  &lt;br&gt; Leo is my Favorites Mind Capsule ;-) &lt;br&gt;  &lt;br&gt; - she can contain all kinds of my Works (novel, code, slides, documents...) &lt;br&gt; - and she can magic record my chaos mind in same time and same place and NOT Disturb my working... &lt;br&gt; - luvin Leo, make me freedom with chaos mind and structuring work export! &lt;br&gt; - all my Slides is make with rst2s5 &lt;br&gt; - write rst in Leo &lt;br&gt; - usage CLI tools generate html slides &lt;br&gt; - easy, geek, and freedom!--- 周琦 (Zoom.Quiet) &lt;br&gt; " id="229" linkTypes="1" links="84" title="Leo is fun, even addicting" />
<node body="&quot;[Leo] should either replace or greatly augment the development tools that I use.&quot;---Zak Greant &lt;br&gt;  &lt;br&gt; &quot;Leo is a marriage of outlining and programming. Pure genius. The main reason I am impressed with this tool is that it doesn't affect your choice of tools. You can use whatever IDE for whatever language and switch back and forth between Leo and it.&quot;---Austin King &lt;br&gt;  &lt;br&gt; &quot;Leo is the best IDE that I have had the pleasure to use. I have been using it now for about 2--3 months. It has totally changed not only the way that I program, but also the way that I store and organize all of the information that I need for the job that I do.&quot;---Ian Mulvany &lt;br&gt;  &lt;br&gt; &quot;I only have one week of Leo experience but I already know it will be my default IDE/project manager...people complain about the lack of a project manager for the free/standard Python IDE's like Idle. Leo clearly solves that problem and in a way that commercial tools can't touch.&quot;---Marshall Parsons &lt;br&gt;  &lt;br&gt; &quot;I have been using Leo for about 3 weeks and I hardly use my other programming editor anymore...I find it easy and enjoyable to use. I plan to adopt it as my presentation tool for code reviews.&quot;---Jim Vickroy &lt;br&gt;  &lt;br&gt; &quot;I'm absolutely astounded by the power of such a simple idea! It works great and I can immediately see the benefits of using Leo in place of the standard flat file editor.&quot;---Tom Lee &lt;br&gt;  &lt;br&gt; &quot;I think you're really showing what open source can do and your current trajectory puts you on track to kick Emacs into the dustbin of computing history.&quot;---Dan Winkler &lt;br&gt; " id="230" linkTypes="1" links="84" title="Leo is a flexible, powerful IDE" />
<node body="&quot;Word outlines are very useful. But Leo makes Word look like a clunky toy.&quot;---Joe Orr &lt;br&gt;  &lt;br&gt; &quot;Leo is an interactive editor for organizing text fragments hierarchically and sequentially into one or more files and hierarchical folders, without arbitrary limits on the number and size of text fragments and the depth of the hierarchy...&quot;---Alex Abacus &lt;br&gt;  &lt;br&gt; &quot;Leo reminds me a great deal of things I loved when I used Userland's Frontier (an outlining cms with a native oodb) - but Frontier wasn't hackable enough for me, and it wasn't oriented towards coding..., and you couldn't round-trip rendered pages (big Leo win). This is really a super tool - in a matter of days I've started to use it on all my projects and I still haven't figured out how I lived without it.&quot;---John Sequeira &lt;br&gt;  &lt;br&gt; &quot;Leo is EXACTLY the kind of outliner I was looking for--fantastic job!&quot;---Steve Allen &lt;br&gt; " id="231" linkTypes="1" links="84" title="Leo is a superb outliner" />
<node body="&quot;If you are like me, you have a kind of knowledge base with infos gathered over time. And you have projects, where you use some of those infos. Now, with conventional outliners you begin to double these infos, because you want to have the infos needed for the project with your project. With Leo you can do this too, but if you change text in one place IT IS UPDATED IN THE OTHER PLACE TOO! This is a feature I did not see with any other outliner (and I tried a few). Amazing! Leo directly supports the way I work!&quot;---F. Geiger &lt;br&gt;  &lt;br&gt; &quot;Another day, another breakthrough using Leo--now I realize Leo is the best URL bookmark manager there is. No more bookmarks menus or favorites lists inside the browser for me. With the @url directive I can just double click on the URL to open it in my browser. Leo lets me arrange the URLs in a hierarchy (or multiple hierarchies), attach notes to them, save clippings of things I read on the sites. It's sooo much better than anything the browsers have built in and it lets me easily use different browsers on different platforms and different machines (try that with the browsers' built-in bookmark managers).&quot;---Dan Winkler &lt;br&gt;  &lt;br&gt; &quot;I am an amateur photographer. I use plain old 35mm. film for my pictures. Over the weekend, I used Leo to organize my lists of pictures. It is quite helpful--I can have separate nodes for pictures I have enlarged, as well as pictures I have submitted to our local camera club. Thanks!&quot;---Rich Reis &lt;br&gt;  &lt;br&gt; &quot;Cloning is pure genius!... Leo's cloning facility, allows me to create several views on the CFA course material. My main view follows the prescribed study guide. Another view is organized like the textbooks. Yet another gives me a glossary of terms. And when I'm done, I'll have some nice libraries...I can re-use later in other projects.&quot;---Michael Manti &lt;br&gt;  &lt;br&gt; Despite I am no programmer, I have been using Leo for some years now as my &quot;Intelligent PIM&quot; - I organize my (complex) life with Leo. Many thanks to Edward and others for the great application -- vili &lt;viljem.tisnikar@gmail.com&gt; &lt;br&gt;  &lt;br&gt; I had used Leo for a long time as a PIM to track my work, but moved to emacs org mode for a period of time because of its explicit agenda and work tracking capabilities. But I went back to Leo because it seems more flexible when it comes to viewing various aspects of a project. For some recent performance data collection work, under one outline are the theory behind the project, the code (generation) for the project, the project web page (generated from an @rst node tree),  and project deployment (little more than clicking a button). One can change focus from one aspect to another very quickly and use clones to really drill down into an area (for me it's typically the code) when needed. Leo is an impressive tool, and I have only scratched the surface--Robert Shanley. &lt;br&gt; " id="232" linkTypes="1" links="84" title="Leo is an excellent PIM" />
<node body="&quot;I've written documentation in WordPerfert, Ventura, Word, PageMaker, and FrameMaker and even though they create wonderfully looking and useful documents, they've never been able to do what I've been looking for. HTML, compiled help files, and later PDF came closer, but still not there...I think I've found it in Leo, a way to make a &quot;living&quot; document. A document built out of discrete parts that can be re-organized on the fly to meet the needs of a varying audience...I've already started converting the IT Procedures manual from Open Office to Leo because I know it's going to be much more useful to me and anyone else...just the possibility of keeping system maintenance scripts in the IT manual is mind boggling.&quot;---David Nichols &lt;br&gt;  &lt;br&gt; &quot;With the help of the rst2 plugin, [Leo is] the best outliner I have yet encountered for writing the early stages of academic papers.&quot; &lt;br&gt;  &lt;br&gt; &quot;A Leo file is an ideal documentation tool, collecting the assorted readme.txt files, the comments from the source files...as well as the config files themselves.&quot;---Kent Tenney &lt;br&gt; " id="233" linkTypes="1" links="84" title="Leo is a superb documentation tool" />
<node body="&quot;Just as structured programming reveals and disciplines the flow control of a program, [Leo] allows the designer to reveal and discipline structure at many layers simultaneously: data structures, object structure, entity-relationship structure, client-server structure, design pattern structure, temporal structure, project management structure, and any other structure relevant to the system.&quot;---Steven P. Schaefer &lt;br&gt;  &lt;br&gt; &quot;A funny observation with Leo is that when I 'Leo-ise' other people's code, Leo makes the code's structure so transparent that design faults become very quickly apparent. For example, maintenance pain caused by lack of factorization.&quot;---David McNab &lt;br&gt;  &lt;br&gt; &quot;Leo is a powerful tool for organizing text into tree structures, and for just generally attacking a number of problems from a tree-based perspective.&quot;---Joe Orr &lt;br&gt;  &lt;br&gt; &quot;I found this blog entry by someone (a talented former coworker of mine actually) complaining about some poorly written code she had to maintain: http://snippy.ceejbot.com/wiki/show/start/2003/01/29/001 She said: 'You'd need a bulldozer to start refactoring it.' That was my cue to write a long message explaining that there is indeed such a bulldozer and it's called Leo. (You can see my message there as a reply to her original posting.) I gave her my recipe for how to get someone else's messy, scary code into Leo and how to break it down into manageable chunks.&quot;---Dan Winkler &lt;br&gt;  &lt;br&gt; &quot;Ed, you continue to push the envelope. The amazing thing is that the footprint isn't doubling every few months like it would be in another designer's hands. Adding features by removing constraints, hot refactoring while adding unit tests. Forget the book. I would pay to see the movie.&quot; &lt;br&gt; " id="234" linkTypes="1" links="84" title="Leo simplifies the understanding of complex systems" />
<node body="&quot;I am extremely impressed at how stable and useful Leo appears to be.&quot;---Marcus &lt;br&gt; A. Martin &lt;br&gt;  &lt;br&gt; &quot;Leo is amazingly stable. Docs are often weak with Open Source Software. Not so Leo: Leo is unusually well documented.&quot;---F. Geiger &lt;br&gt;  &lt;br&gt; &quot;Leo is unimaginably useful and I always find new things it already knows(!) how to do. Indeed I am amazed by the never-ending resources and patience Edward is putting into it and its users community. Excellent.&quot;---Gil Shwartz &lt;br&gt;  &lt;br&gt; I feel strongly that Ed Ream, our ever-patient, ever-productive Leo architect deserves a nomination [for the ActiveState OpenSource Award.] Among other reasons, for: &lt;br&gt;  &lt;br&gt; - Delivering the first usable visual literate programming tool. &lt;br&gt; - Adding a vast abundance of new features. &lt;br&gt; - Making possible a previously unimaginable amount of leverage in code editing. &lt;br&gt; - Eliminating vast amounts of menial programming labour. &lt;br&gt; - Tirelessly and patiently supporting users, and catering to a wide range of feature requests.---David McNab &lt;br&gt; " id="235" linkTypes="1" links="84" title="Leo is stable, well designed and well supported" />
<node body="I just want to provide my own thoughts about the importance of @clean. I look at the posts in this group a fair amount because I find the discussion interesting but I had abandoned Leo as a day-to-day tool principally because of the sentinels in @file nodes. Even for solo projects, I just found them visually unappealing and beyond that occasionally confusing when I went to edit files with external editors. I would sometimes start a project in Leo, particularly if it was based on code I developed in the past using Leo, and then would use the old @nosent to save a version of the code without sentinels and then use my external editor of choice and not use Leo at all. I missed many of the features of Leo but just couldn't get over the sentinel issue. &lt;br&gt;  &lt;br&gt; @clean really seems to solve all the issues that I had. In particular--and &lt;br&gt; somehow this point doesn't seem to me to have been emphasized enough--it seems to fully support organizer nodes. They are one of the great things about Leo--it's happy to guess initially at what the structure of your program is but it's completely up to you to determine the structure and the ability to do things like break up long methods, group like methods, group menu actions in GUI code, etc etc is one of the very cool things about Leo. My limited but growing experience with @clean's handling of external changes has been mainly with incremental (as opposed to more sweeping) code changes, and the assignment of new lines is reasonable and you can always fix them it quickly if you don't like how external changes have been handled. &lt;br&gt;  &lt;br&gt; There have been some posts about the recovered nodes, comparing the old and new nodes where there were external changes. I think it's genius. As opposed to hoping that Leo has correctly incorporated external changes, it's all there in case you want to take a closer look. Without this, I would just not have the confidence that external changes were being applied correctly and while you can always do a git diff, I am not looking to do that every time I change a file externally especially if I am not at the point where I am about to do a commit. &lt;br&gt;  &lt;br&gt; There has been some discussion of @auto v. @clean. Preference is obviously a matter of taste. I will say that for me the fact that node headlines are unaffected by external file changes is a feature not a problem since I place notes in the headlines that I want preserved when I edit files externally. Yes, if the node headlines are the method names then they won't be updated if an external edit changes a method name but this was true of @file as well. &lt;br&gt;  &lt;br&gt; The ability to work on projects with people who don't have Leo is obvious; one perhaps slightly less obvious benefit of no sentinels is that I suspect that the likelihood that someone will clone a git repository is reduced when that repository's code is riddled with Leo sentinels (unless the potential cloner is a Leo loyalist). The one downside to no sentinels--there is no evidence that Leo is being used but I think that raises the broader question of marketing Leo, which I certainly believe will be aided significantly by being able to take advantage of Leo without sentinels in external files.--- Steve Zatz &lt;br&gt; " id="236" linkTypes="1" links="84" title="Steve Zatz explains why @clean changes everything" />
<node body="&quot;I would never again willingly program without Leo&quot;---Edward K. Ream &lt;br&gt;  &lt;br&gt; From Terry Brown: &lt;br&gt;  &lt;br&gt;     If you're looking for an *environment* which includes a good editor and outliner and is completely scriptable / interactive / &quot;live-code&quot; in Python, then Leo wins hands down. Of course, it's basically alone in this field, as far as I know, but I'm sure it would do well even if it wasn't :-). Take out the Python part, and maybe they're some others out there, but who'd want to take out the Python part :) I guess Emacs is sort of an environment like this, only in Lisp with a prehistoric GUI system. &lt;br&gt;  &lt;br&gt;     Sometimes I've wondered why Leo seems to appeal to people who aren't comfortable in Python, I think now it's because they still recognize the value of an *environment*, and there's just not much in this niche. &lt;br&gt;      &lt;br&gt;     My feeling, talking generally and not about Leo in particular, is that while not everyone needs to be a &quot;programmer&quot;, everyone who uses computers would benefit from being able to interact with them with more of the flexibility and efficiency that comes with even relatively simple &quot;scripting&quot;, and less of the limitations that come with the &quot;buy our latest product and you'll be able to do anything you want with a click&quot; view pushed by other suppliers of computing environments. &lt;br&gt;  &lt;br&gt; From Jacob Peck: &lt;br&gt;  &lt;br&gt;     Leo's impact on my life since I found it in January has been substantial. &lt;br&gt;  &lt;br&gt;     Leo allows me to automate my life to a great extent. It is my to-do list, my personal assistant, my address book, my password log, my recipe archive, my rss feed reader (due to rss.py), and my favored editor. It partially powers my blog (along with git, ruby, and heroku), allowing me to create a new blog entry with one click and a bit of editing. Viewrendered (with markdown support!) has changed the way I write READMEs and blog posts. On top of all of that, it has allowed to me to organize several disparate tabletop game design projects I have going, as well as my numerous writing projects. Not to mention the impact it has on my ability to understand and decode large python projects! &lt;br&gt;  &lt;br&gt;     But what really cinches all of this for me is how crazy extensible Leo is. Script buttons in particular are an integral part of my daily workflow, allowing me to transform my productivity over the last month...I'm now a thing-getter-doner, and I find much of it is due to the powerful core of Leo, plus scripting.py and todo.py. &lt;br&gt;      &lt;br&gt; From Ville M. Vainio: &lt;br&gt;      &lt;br&gt;     The outliner format helps me organize/reorganize my thoughts gradually, instead of putting everything in the right place from the beginning. I write a lot of body text with few headlines, and Leo's approach leaves lots of space for the body text and therefore suits my workflow. I find that I end up revisiting notes composed on Leo more often than notes slapped into tools like Evernote or random files in the file system. &lt;br&gt;  &lt;br&gt;     With Leo, I can interleave &quot;notes&quot; (most of the content), generated files and even random data and python scripts to manipulate that data. I process this data in various tools, but Leo helps me group it together in &quot;project specific&quot; Leo files. &lt;br&gt;  &lt;br&gt;     I know how to script the outline, so I can easily whip up different tools for my needs that deal with the headline structure directly. &lt;br&gt;      &lt;br&gt; From Terry Brown: &lt;br&gt;  &lt;br&gt;     Why Leo? Because I have two nodes which were originally identical but are now different and I want to see the differences. &lt;br&gt;      &lt;br&gt;     My outline loads a @file called ~/.leo/t/gen which contains a @button with several @rclick children for commonly used tasks. I add a new one, @rclick diff:: &lt;br&gt;      &lt;br&gt;         selected = c.getSelectedPositions() &lt;br&gt;         open('/tmp/a_diff', 'w').write(selected[0].b) &lt;br&gt;         open('/tmp/b_diff', 'w').write(selected[1].b) &lt;br&gt;         import os &lt;br&gt;         os.system(&quot;xxdiff /tmp/a_diff /tmp/b_diff &amp;&quot;) &lt;br&gt;      &lt;br&gt;     which is horrible for a number of reasons but also took only moments to write. And now, not only does this Leo session have a visual node diff capability, but also every future session which loads ~/.leo/t/gen. &lt;br&gt;      &lt;br&gt;     When you can go from wanting to having a feature in less time than it takes to write an email about it - well, that's &quot;why Leo&quot;. &lt;br&gt; " id="237" linkTypes="1" links="84" title="Quotes from Leo's developers" />
<node body="" id="238" linkTypes="3 3 3 3 3 3 3 3" links="526 527 528 529 530 531 532 533" title="Longer quotes..." />
<node body="Leo is a superb tool for understanding, studying and organizing any kind of complex data, including computer programs. The first great Aha in Leo's history was that webs (literate programs) are outlines in disguise. Leo's importers (@auto) make it easy to studying other people's programs. Leo's always-present outline structure clarifies overall program structure and makes many kinds of comments unnecessary. &lt;br&gt;  &lt;br&gt; Leo is also a superb browser for code and data. Unlike many other folding editors, Leo remembers which nodes were expanded when you last saved an outline. This is surprisingly important. And Leo's clones let you organize any data as you want, even if all folds are collapsed. &lt;br&gt;  &lt;br&gt; Leo is a uniquely powerful scripting environment. This power comes from three sources: Leo's API, Leo's ability to compose scripts from outlines and Leo's underlying data structure, a Directed Acyclic Graph, the basis for Leo's clones. &lt;br&gt;  &lt;br&gt; Leo's API consists primarily of generators, such as c.all_positions(), p.self_and_subtree(), etc. and properties, such as p.b, p.h, p.gnx and p.v.u.  Leo's API makes it trivial to write scripts to access or change any node. AFAIK, these capabilities are unique.  Simulating them in vim or Emacs is possible, but so is simulating Python's capabilities in C... &lt;br&gt;  &lt;br&gt; Afaik, no other scripting environment allows you to compose scripts from outlines.  @file, @clean, @auto, @others and section references and definitions make this possible.  Section references and definitions are modeled on the noweb language, but all of Leo's script composition features are fully integrated into Leo's outline structure. &lt;br&gt;  &lt;br&gt; Leo's outline nodes have headlines (p.h) and body text (p.b) and extensible information (p.v.u).  Headlines are descriptions (meta-data) of the data in p.b and p.v.u.  Scripts can rapidly discover and categorize data using metadata.  Leo's @ convention for headlines (@clean, @file, @auto, @html, etc.) show how extensible this node typing is. &lt;br&gt;  &lt;br&gt; So much for the theory.  The following also are important in practice: &lt;br&gt;  &lt;br&gt; - Native scripting in Python, with full access to all of Leo's sources. &lt;br&gt; - Leo's plugin architecture. &lt;br&gt; - Leo's rst3 command, vim, xemacs and ILeo (IPython bridge), and leoBridge module. &lt;br&gt; - Leo's minibuffer commands, borrowed shamelessly from Emacs. &lt;br&gt; - @test and @suite: Leo's outline-oriented unit testing framework. &lt;br&gt; - @button: bringing scripts to data. &lt;br&gt; - Leo's outline-oriented directives. &lt;br&gt;  &lt;br&gt; The invention/discovery of @clean earlier this year completes Leo is some sense. &lt;br&gt;  &lt;br&gt; Acknowledgements: Working with Leo's community of Leo's developers and users has been a great pleasure for over 20 years. My only regret is that Bernhard Mulder and Bob Fitzwater are no longer with us. Both made essential contributions. Bob Fitzwater was my mentor. He gently pushed me to consider design, not just &quot;bit twiddling&quot;.  Bernhard Mulder contributed two of the most important elements of Leo: Leo's traversers (generators) and the original @shadow algorithm.  Neither @clean nor the revised Mulder/Ream algorithm could possibly have happened without him.  I miss both these great thinkers.  Both would have been proud of what they helped create. &lt;br&gt;  &lt;br&gt; A successful software tool is one that was used to do something undreamed of by its author.' -- Stephen Johnson &lt;br&gt;  &lt;br&gt; Leo is a wild success on this score. I foresaw none of these developments 20 years ago:  Leo's minibuffer, @button, @test, @auto, @clean, Leo's plugin architecture, the rst3 command, the Leo bridge and the IPython bridge.  Surely many other features and uses could be added. None of these would have happened without Leo's community of brilliant people. These features create the Leonine world.  Who knows what will be the result... &lt;br&gt;  &lt;br&gt; Edward K. Ream &lt;br&gt; " id="239" linkTypes="3 3" links="534 535" title="Why Leo is noteworthy" />
<node body="The following deserve special mention: &lt;br&gt;  &lt;br&gt; David Brock wrote TSyntaxMemo, used in early versions of Leo. Terry Brown contributed many important features including Leo's user-modifiable panes, and several important plugins, including bookmarks.py and todo.py. e inspired @button nodes, a truly brilliant idea. The late Bob Fitzwater kept me focused on design. Oh, how I wish he could see today's Leo. Jonathan M. Gilligan showed how to put the Leo icon in Leo's windows. Donald Knuth invented the CWEB language and literate programming. LeoUser (B.H.) contributed numerous plugins, including a prototype for Leo's minibuffer, and wrote jyLeo: Leo in Jython. The late Bernhard Mulder invented the fundamental @shadow algorithm, a stroke of genius. Bernhard also inspired Leo's generators and position class. The one-node world could not have happened without Bernhard. Joe Orr created tutorials and XSLT stylesheets for Leo: http://www.jserv.com/jk_orr/xml/leo.htm. John K. Ousterhout created tcl/Tk, used in early versions of Leo. Neal Norwitz wrote PyChecker. Marc-Antoine Parent urged me to use XML for Leo's file format and helped improve it. Paul Paterson created the plugin architecture, helped with spell checking and contributed many plugins. François Pinard wrote pymacs. Norman Ramsey created noweb and gave permission to quote from the noweb web documentation. Rich Ries has contributed a huge number of suggestions. Steven P. Schaefer pointed out security problems lurking in event handlers and @script. Gil Shwartz helped with unicode support. Phil Straus has been a great friend and constant support. Kent Tenney has constantly lobbied to make Leo easier to use and understand. His comment opened the door to the one-node world. Guido van Rossum created Python, Tkinter and the Python License. Dave Winer created MORE. Ville M. Vainio made invaluable contributions, including the one-node world and the IPython related code.  Ville also wrote the contextmenu.py and valuespace.py plugins. Dan Winkler helped support Leo on the Mac. &lt;br&gt;  &lt;br&gt; Special thanks to my family. My brother, David Speed Ream, tested Leo and made many useful suggestions. Rebecca, James and Linda make it all worthwhile. During a conversation with Rebecca I realized that MORE could be used as a prototype for Leo. That was a crucial first step. &lt;br&gt; " id="240" linkTypes="1" links="85" title="@rst-no-head special mentions" />
<node body="As of 2014 .zip snapshots can be downloaded directly from github, no account required.  The downloaded file will have a name like:: &lt;br&gt;  &lt;br&gt;   leo-editor-50c070b715b9fec50c31be5853055a0ebc72cad5.zip &lt;br&gt;  &lt;br&gt; where the ``50c0...cad5`` part is the ID or fingerprint of the version you've downloaded.  Except &quot;Latest&quot;, which is just ``leo-editor-master.zip``. &lt;br&gt;  &lt;br&gt; Here are some direct download links: &lt;br&gt;  &lt;br&gt;   - `Latest &lt;https://github.com/leo-editor/leo-editor/archive/master.zip&gt;`_ &lt;br&gt;   - `1 day ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{1%20day%20ago}.zip&gt;`_ &lt;br&gt;   - `2 days ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{2%20days%20ago}.zip&gt;`_ &lt;br&gt;   - `5 days ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{5%20days%20ago}.zip&gt;`_ &lt;br&gt;   - `10 days ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{10%20days%20ago}.zip&gt;`_ &lt;br&gt;   - `30 days ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{30%20days%20ago}.zip&gt;`_ &lt;br&gt;   - `90 days ago &lt;https://github.com/leo-editor/leo-editor/archive/master@{90%20days%20ago}.zip&gt;`_ &lt;br&gt; " id="241" linkTypes="1" links="88" title="Snapshots" />
<node body=".. _`Docutils`:   http://docutils.sourceforge.net &lt;br&gt; .. _`feedparser`: https://pypi.python.org/pypi/feedparser &lt;br&gt; .. _`Markdown`:   http://daringfireball.net/projects/markdown/syntax &lt;br&gt; .. _`Python`:     https://www.python.org/ &lt;br&gt; .. _`PyEnchant`:  http://pythonhosted.org/pyenchant/download.html &lt;br&gt; .. _`PythonTidy`: https://pypi.python.org/pypi/PythonTidy/ &lt;br&gt; .. _`PyQt`:       http://www.riverbankcomputing.co.uk/software/pyqt/intro &lt;br&gt; .. _`PyQt4`:      http://www.riverbankcomputing.com/software/pyqt/download &lt;br&gt; .. _`PyQt5`:      http://www.riverbankcomputing.com/software/pyqt/download5 &lt;br&gt; .. _`Sphinx`:     http://sphinx.pocoo.org/ &lt;br&gt;  &lt;br&gt; Leo's minimal dependencies are: &lt;br&gt;  &lt;br&gt; * `Python`_ 2.6 or later, including all Python 3.x versions. &lt;br&gt; * `PyQt`_. You may download `PyQt4`_ or `PyQt5`_. &lt;br&gt;  &lt;br&gt; The following packages are optional, but recommended: &lt;br&gt;  &lt;br&gt; * `Docutils`_: required for the rst3 command and the viewrendered plugins. &lt;br&gt; * `Sphinx`_: required to regenerate Leo's documentation. &lt;br&gt; * `PyEnchant`_: required for spell checking. &lt;br&gt;  &lt;br&gt; Plugins may require other packages.  For example, viewrendered requires `Markdown`_ if one wishes to use markdown rendering, but it is optional. rss.py will not function without `feedparser`_. Etc. &lt;br&gt; " id="242" linkTypes="1" links="89" title="Dependencies" />
<node body="Leo requires the `Python`_ and `PyQt`_ packages. The `PyEnchant`_ package is optional. Leo uses a customized version of `PythonTidy`_, there is no need to install PythonTidy. &lt;br&gt;  &lt;br&gt; **Python**: Leo will work on any platform that supports Python 2.6 or above, including Python 3.0 and above. To install Python, see http://python.org. &lt;br&gt;  &lt;br&gt; **PyQt**: `PyQt`_ provides Leo's widgets. &lt;br&gt;  &lt;br&gt; * Download PyQt4 from http://www.riverbankcomputing.com/software/pyqt/download. &lt;br&gt; * Download PyQt5 from http://www.riverbankcomputing.com/software/pyqt/download5. &lt;br&gt;  &lt;br&gt; **Important**: The PyQt version must match your installed Python version. Remember that Leo requires Python 2.6 or later, or Python 3.0 or later. &lt;br&gt;  &lt;br&gt; **PyEnchant**: You must install `PyEnchant`_ if you want to use Leo's Spell tab. &lt;br&gt;  &lt;br&gt; * Download the PyEnchant package from: http://pythonhosted.org/pyenchant/download.html. &lt;br&gt;  &lt;br&gt; There is an executable installer for Windows users. &lt;br&gt; " id="243" linkTypes="1" links="89" title="Installing packages" />
<node body=".. _`git`: http://git-scm.com/ &lt;br&gt; .. _`GitHub`: https://github.com/leo-editor &lt;br&gt; .. _`latest stable release`: http://sourceforge.net/projects/leo/files/Leo/4.11%20final/ &lt;br&gt; .. _`SourceForge`: https://sourceforge.net &lt;br&gt; .. _`Leo's snapshots page`: http://www.greygreen.org/leo/ &lt;br&gt; .. _`nightly snapshot`: http://www.greygreen.org/leo/ &lt;br&gt; .. _`Leo's latest sources`: https://github.com/leo-editor/leo-editor &lt;br&gt;  &lt;br&gt; Leo's core code is always being improved and developed. Unit-testing ensures that the daily commits are as bug-free as possible. Almost all of the time, downloading the most recent `nightly snapshot`_ of the development code is going to give you code that is just as stable and much more up-to-date than the most recent `latest stable release`_ which most Leonistas would consider already outdated. &lt;br&gt;  &lt;br&gt; If you are just checking Leo out, feel free to use the `latest stable release`_ download if it makes you feel more secure, but once you've decided to work with Leo on a regular basis, we highly recommend regularly keeping your installation up to date with the most recent `nightly snapshot`_. &lt;br&gt;  &lt;br&gt; To summarize, you may get Leo in three ways: &lt;br&gt;  &lt;br&gt; 1. Download the `latest stable release`_ from `SourceForge`_. This release contains an executable installer. This release will usually be a bit out of date. &lt;br&gt;  &lt;br&gt; 2. Download a `nightly snapshot`_ from `Leo's snapshots page`_. This page contains .zip archives of Leo's code from 1, 2, 5, 10, 30 and 90 days ago. &lt;br&gt;     &lt;br&gt; 3. Download `Leo's latest sources`_ from `GitHub`_ using `git`_. Installing git is easy, and once set up this is the easiest way to get the latest version of Leo's code:: &lt;br&gt;     &lt;br&gt;         git clone https://github.com/leo-editor/leo-editor (http access) &lt;br&gt;      &lt;br&gt;    or:: &lt;br&gt;     &lt;br&gt;         git clone git@github.com:leo-editor/leo-editor.git (ssh access) &lt;br&gt; " id="244" linkTypes="3 3 3 3" links="536 537 538 539" title="Installing Leo itself" />
<node body="You can run Leo from a Python interpreter as follows:: &lt;br&gt;  &lt;br&gt;     import leo &lt;br&gt;     leo.run() # runs Leo, opening a new outline or, &lt;br&gt;     leo.run(fileName=aFileName) # runs Leo, opening the given file name. &lt;br&gt;  &lt;br&gt; Another way to run Leo is as follows:: &lt;br&gt;  &lt;br&gt;     cd &lt;path-to-launchLeo.py&gt; &lt;br&gt;     python launchLeo.py %* &lt;br&gt;  &lt;br&gt; Here are some tips that may make running Leo easier: &lt;br&gt;  &lt;br&gt; **Linux** &lt;br&gt;      &lt;br&gt; The following shell script will allow you to open foo.leo files by typing leo foo:: &lt;br&gt;  &lt;br&gt;     #!/bin/sh  &lt;br&gt;     python &lt;leopath&gt;launchLeo.py $1 &lt;br&gt;  &lt;br&gt; where &lt;leopath&gt; is the path to the directory containing the leo directory.  &lt;br&gt;  &lt;br&gt; **Windows** &lt;br&gt;  &lt;br&gt; You can associate Leo with .leo files using a batch file. Put the &lt;br&gt; following .bat file in c:\\Windows:: &lt;br&gt;  &lt;br&gt;     &lt;path-to-python&gt;/python &lt;path-to-leo&gt;/launchLeo.py %* &lt;br&gt;  &lt;br&gt; Here &lt;path-to-leo&gt; is the path to the directory *containing* the leo directory, &lt;br&gt; that is, the directory containing launchLeo.py. &lt;br&gt; " id="245" linkTypes="3 3 3 3" links="540 541 542 543" title="Running Leo" />
<node body="Leo supports the following command-line options. As usual, you can see the list by typing the following in a console window:: &lt;br&gt;  &lt;br&gt;     leo -h &lt;br&gt;  &lt;br&gt; or:: &lt;br&gt;  &lt;br&gt;     leo --help &lt;br&gt;  &lt;br&gt; You will get something like the following:: &lt;br&gt;  &lt;br&gt;     Usage: launchLeo.py [options] file1, file2, ... &lt;br&gt;      &lt;br&gt;     Options: &lt;br&gt;       -h, --help            show this help message and exit &lt;br&gt;       --debug               enable debug mode &lt;br&gt;       --diff                use Leo as an external git diff &lt;br&gt;       --fullscreen          start fullscreen &lt;br&gt;       --ipython             enable ipython support &lt;br&gt;       --gui=GUI             gui to use (qt/qttabs) &lt;br&gt;       --maximized           start maximized &lt;br&gt;       --minimized           start minimized &lt;br&gt;       --no-cache            disable reading of cached files &lt;br&gt;       --no-plugins          disable all plugins &lt;br&gt;       --no-splash           disable the splash screen &lt;br&gt;       --screen-shot=SCREENSHOT_FN &lt;br&gt;                             take a screen shot and then exit &lt;br&gt;       --script=SCRIPT       execute a script and then exit &lt;br&gt;       --script-window=SCRIPT_WINDOW &lt;br&gt;                             open a window for scripts &lt;br&gt;       --select=SELECT       headline or gnx of node to select &lt;br&gt;       --session-restore     restore previously saved session tabs at startup &lt;br&gt;       --session-save        save session tabs on exit &lt;br&gt;       --silent              disable all log messages &lt;br&gt;       --trace-plugins       trace imports of plugins &lt;br&gt;       -v, --version         print version number and exit &lt;br&gt;       --window-size=WINDOW_SIZE &lt;br&gt;                             initial window size (height x width) &lt;br&gt; " id="246" linkTypes="1" links="90" title="Leo's command-line options" />
<node body="If you give no file arguments on the command line Leo will open ``~/.leo/workbook.leo``.  Initially, this file contains Leo's cheat sheet and an example from the rst3 tutorial. &lt;br&gt; " id="247" linkTypes="1" links="90" title="Leo's workbook file" />
<node body="A **session** specifies a list of tabs (.leo files) that Leo opens &lt;br&gt; automatically when Leo first starts. &lt;br&gt;  &lt;br&gt; The typical usage is to start Leo with the --session-save &lt;br&gt; --session-restore command-line options, open several Leo files and exit. &lt;br&gt;  &lt;br&gt; The next time Leo is started with those options, the files will be &lt;br&gt; open, and the nodes focused as when the previous session ended. &lt;br&gt;  &lt;br&gt; Leo stores session state in ~/.leo/leo.session &lt;br&gt; " id="248" linkTypes="1" links="90" title="Using sessions" />
<node body=".. Links used in this document... &lt;br&gt;  &lt;br&gt; .. External links &lt;br&gt;  &lt;br&gt; .. _docutils:           http://docutils.sourceforge.net/ &lt;br&gt; .. _`git repository`:   https://github.com/leo-editor/leo-editor &lt;br&gt; .. _unicode:            http://www.unicode.org/ &lt;br&gt;  &lt;br&gt; .. Glossary &lt;br&gt; .. _directive:              glossary.html#directive &lt;br&gt; .. _directives:             glossary.html#directives &lt;br&gt; .. _`external file`:        glossary.html#external-file &lt;br&gt; .. _`external files`:       glossary.html#external-files &lt;br&gt; .. _headline:               glossary.html#headline &lt;br&gt; .. _headlines:              glossary.html#headlines &lt;br&gt; .. _node:                   glossary.html#node &lt;br&gt; .. _nodes:                  glossary.html#nodes &lt;br&gt; .. _outliner:               glossary.html#outliner &lt;br&gt; .. _sections:               glossary.html#sections &lt;br&gt; .. _`section name`:         glossary.html#section-name &lt;br&gt; .. _`section names`:        glossary.html#section-names &lt;br&gt; .. _sentinels:              glossary.html#sentinels &lt;br&gt; .. _`sentinel line`:        glossary.html#sentinel &lt;br&gt; .. _`sentinel lines`:       glossary.html#sentinel &lt;br&gt; .. _setting:                glossary.html#setting &lt;br&gt; .. _settings:               glossary.html#settings &lt;br&gt;  &lt;br&gt; .. FAQ &lt;br&gt; .. _`How to install Leo on Windows`:    installing.html#installing-leo-on-windows &lt;br&gt; .. _`run Leo in a console`:             running.html#running-leo-from-a-console-window &lt;br&gt;  &lt;br&gt; .. Tutorial &lt;br&gt; .. _`programming tutorial`: tutorial-programming.html &lt;br&gt; .. _tutorial:               tutorial.html &lt;br&gt; .. _`Clones`:               tutorial-pim.html#clones &lt;br&gt; .. _`Views`:                tutorial-pim.html#views &lt;br&gt;  &lt;br&gt; .. Other local references &lt;br&gt; .. _command:                commands.html &lt;br&gt; .. _`History of Leo`:       appendices.html#history-of-leo &lt;br&gt; .. _`Leo 4.0: Eliminating error 'recovery'`: appendices.html#leo-4-0-eliminating-error-recovery &lt;br&gt;  &lt;br&gt; " id="249" linkTypes="1" links="91" title="@rst-no-head Links (FAQ)" />
<node body="" id="250" linkTypes="3 3 3 3 3 3 3 3 3" links="544 545 546 547 548 549 550 551 552" title="Customizing Leo" />
<node body="" id="251" linkTypes="3 3 3" links="553 554 555" title="Getting Leo" />
<node body="" id="252" linkTypes="3 3" links="556 557" title="Installing Leo" />
<node body="" id="253" linkTypes="3 3 3 3 3 3 3 3" links="558 559 560 561 562 563 564 565" title="Learning to use Leo" />
<node body="" id="254" linkTypes="3 3 3" links="566 567 568" title="Leo in Shared environments" />
<node body="" id="255" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3" links="569 570 571 572 573 574 575 576 577 578 579 580" title="Scipting &amp; Testing" />
<node body="" id="256" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601" title="Tips and techniques" />
<node body="" id="257" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="602 603 604 605 606 607 608 609 610 611 612 613 614 615 616" title="Trouble shooting" />
<node body="" id="258" linkTypes="3 3 3 3 3" links="617 618 619 620 621" title="Unicode issues" />
<node body="" id="259" linkTypes="3 3 3 3 3 3 3 3 3 3" links="622 623 624 625 626 627 628 629 630 631" title="Using external files" />
<node body=".. index:: &lt;br&gt;     pair: Command name; Tutorial &lt;br&gt;  &lt;br&gt; Every Leo command has a **command name**. In this document, keystrokes that invoke a command will be followed by the command name in parentheses. For example, ``Ctrl-S (save-file)`` saves a Leo file. &lt;br&gt;  &lt;br&gt; ``Alt-X (full-command)`` &lt;br&gt;     Executes any other command by typing its full name. &lt;br&gt;     For full details see `The minibuffer &amp; completions`_. &lt;br&gt; " id="260" linkTypes="1" links="93" title="Command names" />
<node body="Here is a slightly reduced screenshot of Leo's main window: &lt;br&gt;  &lt;br&gt; .. image:: screen-shots/render-svg-sources.png &lt;br&gt;    :alt: Screenshot &lt;br&gt;    :scale: 80 % &lt;br&gt;     &lt;br&gt; .. index:: &lt;br&gt;     pair: Body pane; Tutorial &lt;br&gt;     pair: Expansion box; Tutorial &lt;br&gt;     pair: Icon area; Tutorial &lt;br&gt;     pair: Log pane; Tutorial &lt;br&gt;     pair: Main Window; Tutorial &lt;br&gt;     pair: Outline pane; Tutorial &lt;br&gt;     pair: Status line; Tutorial &lt;br&gt;  &lt;br&gt; Leo's main window consists of an **icon area** just below the menus, an **outline pane** at the top left, a **log pane** at the top right, a **body pane** at the bottom left, and an optional **viewrendered pane** at the bottom right. The **minibuffer** and **status line** lie at the bottom of the main window. &lt;br&gt;  &lt;br&gt; The log pane contains several tabs. The **Log tab** shows messages from Leo, the **Find Tab** shows the status of Leo's Find/Replace commands. Other tabs may also appear in the log pane: The **Spell Tab** controls Leo's spell-checking. The **Completion Tab** shows available typing completions. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Icon box; Tutorial &lt;br&gt;     pair: Node; Tutorial &lt;br&gt;     pair: Headline; Tutorial &lt;br&gt;     pair: Body text; Tutorial &lt;br&gt;  &lt;br&gt; Leo stores all data in **nodes**. Nodes have **headlines**, shown in the outline pane, and **body text**. The body pane shows the body text of the **presently selected node**, the node whose headline is selected in the outline pane.  Headlines have an **icon box** indicating a nodes status. For example, the icon box has a black border when the node has been changed. &lt;br&gt; " id="261" linkTypes="1" links="93" title="Leo's main window" />
<node body="Here are Leo's basic file commands: &lt;br&gt;  &lt;br&gt; ``Ctrl-N (new)`` &lt;br&gt;     Creates a new outline in a new tab. &lt;br&gt; ``Ctrl-O (open-outline)`` &lt;br&gt;     Opens an existing .leo file. &lt;br&gt; ``Ctrl-S (save-file)`` &lt;br&gt;     Saves the outline. &lt;br&gt; ``Ctrl-Q (exit-leo)`` &lt;br&gt;     Exits Leo.  Leo will prompt you to save any unsaved outlines. &lt;br&gt;      &lt;br&gt; A **session** specifies a list of tabs (.leo files) that Leo opens automatically when Leo first starts. When the ``--session-save`` and ``--session-restore`` command-line options are in effect, Leo will save session data on exit and will reload outlines when Leo restarts. For full details, see `Using sessions &lt;commands.html#using-sessions&gt;`_ in Leo's `Users Guide &lt;usersguide.html&gt;`_. &lt;br&gt; " id="262" linkTypes="1" links="93" title="File operations &amp; sessions" />
<node body="Here's how to switch focus without using the mouse: &lt;br&gt;  &lt;br&gt; ``Alt-0 (vr-toggle)`` &lt;br&gt;     Hides or shows the viewrendered pane. &lt;br&gt; ``Alt-T (focus-to-tree)`` &lt;br&gt;     Puts focus in the outline pane, regardless of focus. &lt;br&gt; ``Ctrl-T (toggle-active-pane)`` &lt;br&gt;     Toggles focus between the outline and body panes. &lt;br&gt; ``Ctrl-Tab (tab-cycle-next)`` &lt;br&gt;     Switches between outline tabs. You may open multiple Leo outlines in different tabs within the same main window. &lt;br&gt; ``Ctrl-G (keyboard-quit)`` &lt;br&gt;     Puts focus in the body pane. More effective than hitting Alt-Tab twice." id="263" linkTypes="1" links="93" title="Switching focus" />
<node body="``Ctrl-I or Insert (insert-node)`` &lt;br&gt;     Inserts a new node into the outline. &lt;br&gt; ``Ctrl-H (edit-headline)`` &lt;br&gt;     Begins editing the headline of the selected node. &lt;br&gt; ``Return`` &lt;br&gt;     When focus is in the outline pane, ``&lt;Return&gt;`` ends editing ``(end-edit-headline)`` or switches focus to the body pane. &lt;br&gt; ``Ctrl-Shift-C (copy-node)`` &lt;br&gt;     Copies the outline and all it's descendants, placing the node on the clipboard. &lt;br&gt; ``Ctrl-Shift-X (cut-node)`` &lt;br&gt;     Cuts the outline and all its descendants, placing the node on the clipboard. &lt;br&gt; ``Ctrl-Shift-V (paste-node)`` &lt;br&gt;     Pastes a node (and its descendants) from the clipboard after the presently selected node. &lt;br&gt; ``Ctrl-M (mark)`` &lt;br&gt;     Toggles the mark on a node. Marked nodes have a vertical red bar in their icon area. &lt;br&gt; ``Ctrl-} (demote)`` &lt;br&gt;     Makes all following siblings of a node children of the node. Use ``demote`` to &quot;gather&quot; nodes so they can all be moved with their parent. &lt;br&gt; ``Ctrl-{ (promote)`` &lt;br&gt;     Makes all the children of a node siblings of the node. Use ``demote`` to &quot;scatter&quot; the nodes after moving their parent. &lt;br&gt; " id="264" linkTypes="1" links="93" title="Operations on nodes" />
<node body="You may select, expand and contract outline nodes with the mouse as usual, but using arrow keys is *highly recommended*. When focus is in the outline pane, *plain* arrows keys change the selected node: &lt;br&gt;  &lt;br&gt; ``Right-arrow (expand-and-go-right)`` &lt;br&gt;     Expands a node or selects its first child. &lt;br&gt; ``Left-arrow (contract-or-go-left)`` &lt;br&gt;     Contracts a node if its children are visible, and selects the node's parent otherwise. &lt;br&gt; ``Up-arrow (goto-prev-visible)`` &lt;br&gt;     Selects the previous *visible* outline node. &lt;br&gt; ``Down-arrow (goto-next-visible)`` &lt;br&gt;     Selects the next *visible* outline node. &lt;br&gt;    &lt;br&gt; Regardless of focus, ``Alt-arrow`` select outline nodes: &lt;br&gt;  &lt;br&gt; ``Alt-Home (goto-first-visible-node)`` &lt;br&gt;     Selects the first outline node and collapses all nodes. &lt;br&gt; ``Alt-End (goto-last-visible-node)`` &lt;br&gt;     Selects the last *visible* outline node and collapses all nodes except the node and its ancestors. &lt;br&gt; ``Alt-arrow keys`` &lt;br&gt;     Select the outline pane, and then act just like the plain arrow keys when the outline pane has focus. &lt;br&gt; " id="265" linkTypes="1" links="93" title="Selecting outline nodes" />
<node body="When focus is in any of Leo's text panes (body pane, log pane, headlines), Leo works like most text editors: &lt;br&gt;  &lt;br&gt; - ``Plain arrow`` keys move the cursor up, down, left or right. &lt;br&gt; - ``Ctrl-LeftArrow`` and ``Ctrl-RightArrow`` move the cursor by words. &lt;br&gt; - ``Home`` and ``End`` move the cursor to the beginning or end of a line. &lt;br&gt; - ``Ctrl-Home`` moves the cursor to the beginning of the body text. &lt;br&gt; - ``Ctrl-End`` moves the cursor to the end of the body text. &lt;br&gt; - ``PageDown`` and ``PageUp`` move the cursor up or down one page. &lt;br&gt;  &lt;br&gt; **Note**: As usual, adding the ``Shift`` key modifier to any of the keys above moves the cursor and extends the selected text. &lt;br&gt; " id="266" linkTypes="1" links="93" title="Moving the cursor in text panes" />
<node body=".. index:: &lt;br&gt;     pair: Minibuffer; Tutorial &lt;br&gt;     pair: Tab completion; Tutorial &lt;br&gt;  &lt;br&gt; Leo’s minibuffer appears at the bottom of Leo’s main window. You use the minibuffer to execute commands by name, and also to accumulate arguments to commands. &lt;br&gt;  &lt;br&gt; ``Alt-X (full-command)`` puts the cursor in the minibuffer. &lt;br&gt;  &lt;br&gt; You could type the full command name in the minibuffer, followed by the ``&lt;Return&gt;`` key to invoke the command, but that would be *way* too much work. Instead, you can avoid most typing using **tab completion**. With tab completion, *there is no need to remember the exact names of Leo’s commands*. &lt;br&gt;  &lt;br&gt; For example, suppose you want to print out the list of Leo’s commands. You might remember only that there are several related commands and that they all start with &quot;print&quot;. Just type ``&lt;Alt-X&gt;pri&lt;Tab&gt;`` &lt;br&gt;  &lt;br&gt; You will see ``print-`` in the minibuffer. This is the longest common prefix of all the command names that start with ``pri``. The Completion tab in the log pane shows all the commands that start with ``print-``. &lt;br&gt;  &lt;br&gt; Now just type ``c&lt;Tab&gt;`` You will see the ``print-commands`` command in the minibuffer. &lt;br&gt;  &lt;br&gt; Finally, ``&lt;Return&gt;`` executes the ``print-commands`` command. The output of the print-commands command appears in the commands tab, and focus returns to the body pane. &lt;br&gt;  &lt;br&gt; **Very Important**: Leo has hundreds of commands, but because of tab completion you do not have to remember, or even *know about* any of them.  Feel free to ignore commands that you don't use. &lt;br&gt;  &lt;br&gt; **Opening files using filename completion** &lt;br&gt;  &lt;br&gt; ``file-open-by-name`` &lt;br&gt;     Prompts for a filename. This command completes the name of files and directories as in command completion.  As a result, this command can be very fast.  You may want to bind this command to ``Ctrl-O`` instead of the default ``open-outline`` command. &lt;br&gt;      &lt;br&gt; **Command history**: &lt;br&gt;  &lt;br&gt; ``Ctrl-P (repeat-complex-command`` &lt;br&gt;     Repeats the last command entered by name in the minibuffer. &lt;br&gt; ``UpArrow`` (in the minibuffer) &lt;br&gt;     Moves backward through command history. The first ``UpArrow`` is the same as ``Ctrl-P``. &lt;br&gt; ``DownArrow`` (in the minibuffer) &lt;br&gt;     Moves forward through command history. &lt;br&gt;  &lt;br&gt; **Summary**: &lt;br&gt;  &lt;br&gt; - ``&lt;Return&gt;`` executes the command. &lt;br&gt; - ``&lt;Tab&gt;`` shows all valid completions. &lt;br&gt; - ``&lt;BackSpace&gt;`` shows more alternatives. &lt;br&gt; - ``Ctrl-G`` exits the minibuffer and puts focus in the body pane. &lt;br&gt; - ``UpArrow`` and ``DownArrow`` in the minibuffer cycle through command history. &lt;br&gt; " id="267" linkTypes="1" links="93" title="The minibuffer &amp; completions" />
<node body="This section explains how to use Leo's standard search/replace commands. &lt;br&gt; **Note**: you can also use the Nav Tab (in the Log pane) to search for text. &lt;br&gt;  &lt;br&gt; ``Ctrl-F (start-search)`` shows the Find Tab and puts the focus in the text box labeled ``Find:``. &lt;br&gt;  &lt;br&gt; **Aside**: You can select radio buttons and toggle check boxes in the Find Tab with ``Ctrl-Alt keys``. The capitalized words of the radio buttons or check boxes indicate which key to use.  For example, ``Ctrl-Alt-X (toggle-find-regex-option)`` toggles the ``regeXp`` checkbox. &lt;br&gt;  &lt;br&gt; After typing ``Ctrl-F``, type the search string, say ``def``, in the text box. &lt;br&gt;  &lt;br&gt; Start the find command by typing ``&lt;Return&gt;``. &lt;br&gt;  &lt;br&gt; But suppose you want to replace ``def`` with ``foo``, instead of just finding ``def``. &lt;br&gt;  &lt;br&gt; Just type ``&lt;Tab&gt;`` before typing ``&lt;Return&gt;``. Focus shifts to the text box labeled ``Replace:``. &lt;br&gt;  &lt;br&gt; Finally, type ``&lt;Return&gt;`` to start the find-next command. When Leo finds the next instance of ``def``, it will select it. &lt;br&gt;  &lt;br&gt; You may now type any command.  The following are most useful: &lt;br&gt;  &lt;br&gt; - ``Ctrl-minus (replace-then-find)`` replaces the selected text. &lt;br&gt; - ``F3 (find-next)`` continues searching without making a replacement. &lt;br&gt; - ``F2 (find-previous)`` continues the search in reverse. &lt;br&gt; - ``Ctrl-G (keyboard-quit)`` ends the search. &lt;br&gt; " id="268" linkTypes="1" links="93" title="Finding &amp; replacing text" />
<node body="The **clone find** commands, cfa and cff are extraordinarily useful. These commands move clones of all nodes matching the search pattern under a single **organizer node**, created as the last top-level node. **Flattened** searches put all nodes as direct children of the organizer node:: &lt;br&gt;  &lt;br&gt;     cfa     clone-find-all &lt;br&gt;     cff     clone-find-all-flattened &lt;br&gt;      &lt;br&gt; The **clone-marked** commands move clones of all marked nodes under an organizer node. Especially useful for gathering nodes by hand:: &lt;br&gt;  &lt;br&gt;     cfam    clone-find-marked  &lt;br&gt;     cffm    clone-find-flattened-marked &lt;br&gt; " id="269" linkTypes="1" links="93" title="Clone-find commands" />
<node body="Leo has unlimited undo--Leo remembers *all* changes you make to outline structure or the contents of any node since you restarted Leo. &lt;br&gt;  &lt;br&gt; ``Ctrl-Z (undo)`` &lt;br&gt;     Undoes the last change. Another Ctrl-Z undoes the previous change, etc. &lt;br&gt; ``Ctrl-Shift-Z (redo)`` &lt;br&gt;     Undoes the effect of the last undo, etc. &lt;br&gt;  &lt;br&gt; The first two entries of the ``Edit`` menu show what the next undo or redo operation will be. &lt;br&gt; " id="270" linkTypes="1" links="93" title="Undoing and redoing changes" />
<node body="``F1 (help)`` &lt;br&gt;     Shows a help message appears in the viewrendered pane. Alt-0 (vr-toggle) hides or shows this pane. &lt;br&gt; ``F11 (help-for-command)`` &lt;br&gt;     Shows the documentation for any Leo command. ``F11`` prompts for the name of a Leo command in the minibuffer. Use tab completion to see the list of all commands that start with a given prefix. &lt;br&gt; ``F12 (help-for-python)`` &lt;br&gt;     Shows the documentation from Python's help system. Typing completion is not available: type the full name of any Python module, class, function or statement. &lt;br&gt;  &lt;br&gt; These commands clarify which settings are in effect, and where they came from:: &lt;br&gt;  &lt;br&gt;     print-bindings &lt;br&gt;     print-settings &lt;br&gt;  &lt;br&gt; These commands discuss special topics:: &lt;br&gt;  &lt;br&gt;     help-for-abbreviations &lt;br&gt;     help-for-autocompletion &lt;br&gt;     help-for-bindings &lt;br&gt;     help-for-creating-external-files &lt;br&gt;     help-for-debugging-commands &lt;br&gt;     help-for-drag-and-drop &lt;br&gt;     help-for-dynamic-abbreviations &lt;br&gt;     help-for-find-commands &lt;br&gt;     help-for-minibuffer &lt;br&gt;     help-for-regular-expressions &lt;br&gt;     help-for-scripting &lt;br&gt;     help-for-sessions &lt;br&gt;  &lt;br&gt; Using Leo, especially for programming, requires some learning initially. Please feel free to `ask for help &lt;https://groups.google.com/forum/#!forum/leo-editor&gt;`_ at any time. &lt;br&gt; " id="271" linkTypes="1" links="93" title="Getting help" />
<node body=".. index:: &lt;br&gt;    pair: Directive; Tutorial &lt;br&gt;  &lt;br&gt; **Directives** control Leo's operations. Directives start with ``@`` in the leftmost column. &lt;br&gt;  &lt;br&gt; Directives may appear either in headlines or body text. &lt;br&gt;  &lt;br&gt; When people speak of an ``@x`` node, they are implying that the headline starts with ``@x``. If a node contains an ``@x`` directive (in the body pane), they will usually say something like, &quot;a node containing an ``@x`` directive&quot;. &lt;br&gt;  &lt;br&gt; Directives apply until overridden by the same (or related) directive in a descendant node. &lt;br&gt;  &lt;br&gt; Some commonly used general-purpose directives: &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @color; Tutorial &lt;br&gt;     pair: @nocolor; Tutorial &lt;br&gt;     pair: @killcolor; Tutorial &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     @color &lt;br&gt;     @killcolor &lt;br&gt;     @nocolor &lt;br&gt;  &lt;br&gt; These control whether to syntax color text.  &lt;br&gt;  &lt;br&gt; Nodes may contain multiple color directives. &lt;br&gt;  &lt;br&gt; Nodes containing multiple color directives do not affect coloring of descendant nodes. &lt;br&gt;      &lt;br&gt; .. index:: &lt;br&gt;     pair: @language; Tutorial &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     @language python &lt;br&gt;     @language c &lt;br&gt;     @language rest # restructured text &lt;br&gt;     @language plain # plain text: no syntax coloring. &lt;br&gt;      &lt;br&gt; These control which language to use when syntax coloring text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @pagewidth; Tutorial &lt;br&gt;      &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     @pagewidth 100 &lt;br&gt;      &lt;br&gt; Sets the page width used when formatting paragraphs. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @tabwidth; Tutorial &lt;br&gt;     pair: Negative tab width; Tutorial &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     @tabwidth -4 &lt;br&gt;     @tabwidth 8 &lt;br&gt;      &lt;br&gt; Sets the width of tabs. &lt;br&gt;  &lt;br&gt; Negative tab widths cause Leo to convert tabs to spaces and are highly recommended for Python programming. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @wrap; Tutorial &lt;br&gt;     pair: @nowrap; Tutorial &lt;br&gt;      &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     @nowrap &lt;br&gt;     @wrap &lt;br&gt;  &lt;br&gt; These enable or disable line wrapping in the body pane. &lt;br&gt; " id="272" linkTypes="1" links="93" title="Leo directives" />
<node body=".. index:: &lt;br&gt;     pair: leoSettings.leo; Tutorial &lt;br&gt;     pair: Global Settings; Tutorial &lt;br&gt;     pair: myLeoSettings.leo; Tutorial &lt;br&gt;     pair: Personal Settings; Tutorial &lt;br&gt;     pair: Local Settings; Tutorial &lt;br&gt;     pair: Configuration file; Tutorial &lt;br&gt;  &lt;br&gt; Leo has a flexible (perhaps *too* flexible) configuration system. It's best to use this flexibility in a restricted way as follows: &lt;br&gt;  &lt;br&gt; 1. The file leo/config/leoSettings.leo contains Leo's default **global settings**. Don't change this file unless you are one of Leo's developers. &lt;br&gt;     &lt;br&gt; 2. The file ~/myLeoSettings.leo contains your **personal settings**. Leo will not create this file automatically: you should create it yourself. Settings in myLeoSettings.leo override (or add to) the default settings in leoSettings.leo. &lt;br&gt;     &lt;br&gt; 3. Any other .leo file may also contain **local settings**. Local settings apply only to that file and override all other settings. It's best to use local settings sparingly. &lt;br&gt;     &lt;br&gt; As a result, settings may vary from one Leo file to another. This can be confusing. These two commands can help: &lt;br&gt;  &lt;br&gt; - ``print-settings`` shows each setting and where it came from. &lt;br&gt; - ``print-bindings`` shows each key binding and where it came from. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @settings tree; Tutorial &lt;br&gt;  &lt;br&gt; **Important**: within any file, settings take effect **only** if they are contained in an **@settings tree**, that is, are descendants of a node whose headline is @settings. Nodes outside @settings trees do not affect settings in any way. &lt;br&gt;  &lt;br&gt; Within ``@settings`` trees, you specify boolean settings with ``@bool`` nodes, string settings with ``@string`` nodes, menus with ``@menus`` and ``@menu`` nodes, etc. For exact details, please do study leoSettings.leo. You can open either leoSettings.leo or myLeoSettings.leo from the Help menu. Within leoSettings.leo: &lt;br&gt;  &lt;br&gt; - The node ``About this file`` explains about settings. &lt;br&gt; - The node ``Candidates for settings in myLeoSettings.leo`` highlights the settings you are most likely to want to customize. &lt;br&gt; " id="273" linkTypes="1" links="93" title="Configuring Leo" />
<node body=".. _`bookmarks.py`:     plugins.html#bookmarks-py &lt;br&gt; .. _`contextmenu.py`:   plugins.html#contextmenu-py &lt;br&gt; .. _`mod_scripting.py`: plugins.html#mod-scripting-py &lt;br&gt; .. _`quicksearch.py`:   plugins.html#quicksearch-py &lt;br&gt; .. _`todo.py`:          plugins.html#todo-py &lt;br&gt; .. _`valuespace.py`:    plugins.html#valuespace-py &lt;br&gt; .. _`viewrendered.py`:  plugins.html#viewrendered-py &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Plugins; Tutorial &lt;br&gt;  &lt;br&gt; `Leo plugins &lt;plugins.html&gt;`_ are Python programs that extend what Leo can do. &lt;br&gt;  &lt;br&gt; Plugins reside in the leo/plugins folder. &lt;br&gt;  &lt;br&gt; Enable plugins by adding their file names in ``@enabled-plugins`` nodes in an ``@settings`` tree. The ``@enabled-plugins`` node in leoSettings.leo enables the recommended plugins. &lt;br&gt;  &lt;br&gt; Programmers have contributed dozens of plugins, including: &lt;br&gt;  &lt;br&gt; - `bookmarks.py`_ manages and shows bookmarks. &lt;br&gt; - `contextmenu.py`_ shows a context menu when you right-click a headline. &lt;br&gt; - `mod_scripting.py`_ supports @button and @command nodes. &lt;br&gt; - `quicksearch.py`_ Adds Nav tab for searching. &lt;br&gt; - `todo.py`_ provides to-do list and simple project-management capabilities. &lt;br&gt; - `valuespace.py`_ adds outline-oriented spreadsheet capabilities. &lt;br&gt; - `viewrendered.py`_ creates the rendering pane and renders content in it. &lt;br&gt; " id="274" linkTypes="1" links="93" title="Plugins" />
<node body=".. _`programming tutorial`: tutorial-programming.html &lt;br&gt; .. _`Using @clean nodes`: tutorial-programming.html#using-clean &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @file node; Tutorial &lt;br&gt;      &lt;br&gt; Leo stores outline data on your file system in **.leo files**. &lt;br&gt;  &lt;br&gt; Rather than storing all your data in the .leo file, you may store parts of your outline data in **external files**, files on your file system. &lt;br&gt;  &lt;br&gt; **@file nodes** create external files. @file nodes have headlines starting with @file followed by a file name:: &lt;br&gt;  &lt;br&gt;     @file leoNodes.py &lt;br&gt;     @file ../../notes.text &lt;br&gt;      &lt;br&gt; .. index:: &lt;br&gt;     pair: Dirty node; Tutorial &lt;br&gt;  &lt;br&gt; Leo reads external files automatically when you open Leo outline, and writes all **dirty** (changed) external files when you save any Leo outline. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @all; Tutorial &lt;br&gt;     pair: Outline Order; Tutorial &lt;br&gt;  &lt;br&gt; The **@all** directive tells Leo to write the **@file tree** (the @file node and all its descendants) to the external file in **outline order**, the order in which the nodes appear in the outline pane when all nodes are expanded. Non-programmers will typically use the @all directive; programmers typically use the @others directive, as discussed in the `programming tutorial`_. The @all directive may appear anywhere in the body text of the root @file node. &lt;br&gt;  &lt;br&gt; The @all directivive is designed for &quot;catch-all&quot; files, like todo.txt or notes.txt or whatever. Such files are assumed to contain a random collection of nodes, so there is no language in effect and no real comment delimiters. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Sentinel Comments; Tutorial &lt;br&gt;     pair: Sentinel Lines; Tutorial &lt;br&gt;  &lt;br&gt; When writing @file nodes, Leo adds **sentinel comments** to external files. Sentinels embed Leo's outline structure into external files. If you don't want sentinels in your sources, skip head to the `Using @clean nodes`_, part of Leo's `programming tutorial`_. &lt;br&gt; " id="275" linkTypes="1" links="93" title="Creating external files with @file and @all" />
<node body="- Every command has a name. &lt;br&gt; - You may execute any command by name from the minibuffer. &lt;br&gt; - Many commands are bound to keystrokes. &lt;br&gt; - You may bind multiple keystrokes to a single command and change bindings to your taste. &lt;br&gt;  &lt;br&gt;     **Note**: All Ctrl-&lt;number&gt; keys and most Ctrl-Shift-&lt;number&gt; keys are |br| &lt;br&gt;     unbound by default. You may bind them to whatever commands you like. &lt;br&gt;  &lt;br&gt; - Leo has commands to create, change and reorganize outlines. &lt;br&gt; - Within the body pane, Leo uses standard key bindings to move the cursor. &lt;br&gt; - Ctrl-F starts the find command. Use the minibuffer to complete the command. &lt;br&gt; - Leo's configuration files specify all settings, including key bindings. &lt;br&gt; - Leo directives control how Leo works. &lt;br&gt; - @all creates an external file from all the nodes of an outline. &lt;br&gt; - Enable plugins using @enabled-plugins nodes in an @settings tree. &lt;br&gt; " id="276" linkTypes="1" links="93" title="Summary" />
<node body=".. index:: &lt;br&gt;     pair: Clone; Tutorial &lt;br&gt;      &lt;br&gt; A **clone** is a node that appears in more than one place in a Leo outline. Clones are marked with a small red arrow in its icon box. &lt;br&gt;  &lt;br&gt; .. .. image:: images/box13.GIF &lt;br&gt; ..    :scale 200 % &lt;br&gt; ..    :alt: Leo Icon Box With Clone Mark &lt;br&gt;  &lt;br&gt; All clones of a node are actually *the same node*: &lt;br&gt;  &lt;br&gt; - Any change to one clone affects all clones. &lt;br&gt; - Inserting, moving or deleting any child of a clone will change all other clones on the screen. &lt;br&gt;  &lt;br&gt; Clones allow data to be stored in *arbitrarily many* places within an outline. &lt;br&gt;  &lt;br&gt; ``Ctrl-` (clone-node)`` &lt;br&gt;     Clones node A. The shortcut is a grave accent, *not* a single quote.  This is often on the same keyboard key as the tilde ``~`` character. &lt;br&gt;  &lt;br&gt; Please take a few moments to experiment with clones: &lt;br&gt;  &lt;br&gt; - Create a node whose headline is A. &lt;br&gt; - Clone node A with the ``clone-node`` command. &lt;br&gt; - Type some text into the body of A. &lt;br&gt; - All clones of A now have the same body. &lt;br&gt; - Insert a node, say B, as a child of any of the A nodes. &lt;br&gt; - Notice that *all* the A nodes now have a B child. &lt;br&gt; - See what happens if you clone B. &lt;br&gt; - See what happens if you insert, delete or move nodes that are children of A. &lt;br&gt; - When you delete a node's penultimate clone, the node becomes a regular node again. &lt;br&gt; " id="277" linkTypes="1" links="94" title="Clones" />
<node body="Clones can greatly accelerate your work flow. To start a project, clone nodes related to the project and drag them at or near the top level, where you can get at them easily. When the project is complete, just delete the clones. This work flow is surprisingly effective: &lt;br&gt;  &lt;br&gt; - The original nodes never move, but they change whenever their clones do. &lt;br&gt;  &lt;br&gt; - There is nothing to &quot;put back in place&quot; when you are done. Just delete the clones. &lt;br&gt;    &lt;br&gt; Used this way, **clones create views**: when you gather cloned nodes together for a project, you are, in effect, creating a project-oriented view of the outline. This view **focuses your attention** on only those nodes that are relevant to the task at hand. &lt;br&gt; " id="278" linkTypes="1" links="94" title="Clones accelerate work flow by creating views" />
<node body=".. index:: &lt;br&gt;     pair: Abbreviation; Tutorial &lt;br&gt;  &lt;br&gt; Leo optionally expands abbreviations as you type. Abbreviations typically end with something like ``;;`` so they won't trigger by accident. &lt;br&gt;  &lt;br&gt; To use abbreviations, you must enable them in myLeoSettings.leo:: &lt;br&gt;  &lt;br&gt;     @bool enable-abbreviations = True &lt;br&gt;  &lt;br&gt; You define abbreviations in ``@data abbreviations`` nodes or ``@data global-abbreviations`` nodes. None come predefined, but ``leo/config/exampleSettings.leo`` contains example abbreviations in the node ``@data abbreviations examples`` &lt;br&gt;  &lt;br&gt; Abbreviations can simply be shortcuts:: &lt;br&gt;  &lt;br&gt;     ncn;;=@nocolor &lt;br&gt;      &lt;br&gt; Abbreviations can span multiple lines. Continued lines start with ``\:``, like this:: &lt;br&gt;  &lt;br&gt;     form;;=&lt;form action=&quot;main_submit&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;br&gt;     \:&lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Continue &amp;rarr;&quot;&gt;&lt;/p&gt; &lt;br&gt;     \:&lt;/form&gt;\n &lt;br&gt;  &lt;br&gt; Abbreviations can define templates in which ``&lt;|a-field-name|&gt;`` denotes a field to be filled in:: &lt;br&gt;  &lt;br&gt;     input;;=&lt;input type=&quot;text/submit/hidden/button&quot; &lt;br&gt;     \:name=&quot;&lt;|name|&gt;&quot; &lt;br&gt;     \:value=&quot;&quot; id=&quot;&lt;|id|&gt;&quot;&gt;\n &lt;br&gt;  &lt;br&gt; Typing ``,,`` after inserting a template selects the next field. &lt;br&gt;  &lt;br&gt; Abbreviations can execute **abbreviation scripts**, delimited by ``{|{`` and ``}|}``:: &lt;br&gt;  &lt;br&gt;     date;;={|{import time ; x=time.asctime()}|} &lt;br&gt;     ts;;={|{import time ; x=time.strftime(&quot;%Y%m%d%H%M%S&quot;)}|} &lt;br&gt;      &lt;br&gt; To use abbreviations scripts, enable them in myLeoSettings.leo as follows:: &lt;br&gt;  &lt;br&gt;     @bool scripting-abbreviations = True &lt;br&gt;  &lt;br&gt; With abbreviation scripts enabled, typing ``ts;;`` gives:: &lt;br&gt;  &lt;br&gt;     20131009171117 &lt;br&gt;      &lt;br&gt; It's even possible to define a context in which abbreviation scripts execute. See leoSettings.leo for full details. &lt;br&gt; " id="279" linkTypes="1" links="94" title="Using abbreviations and templates" />
<node body=".. index:: &lt;br&gt;     pair: URL; Tutorial &lt;br&gt;     pair: @url; Tutorial &lt;br&gt;  &lt;br&gt; Leo highlights URLs whenever syntax is coloring is enabled. &lt;br&gt;  &lt;br&gt; ``Ctrl-Left-Click (open-url-under-cursor)`` &lt;br&gt;     Opens the URL under the cursor. &lt;br&gt; ``open-url`` &lt;br&gt;     Opens a URL appearing either in the headline or the first line of body text. If a headline starts with ``@url``, the rest of the headline is take to be a url. &lt;br&gt;      &lt;br&gt; **Note**: &lt;br&gt;  &lt;br&gt; - Leo opens URLs that look like file names using os.startfile. &lt;br&gt; - Leo opens all other URLs with your default web browser. &lt;br&gt; - Any scheme (http, mailto, ftp, file, etc.) supported by your browser is valid. &lt;br&gt; - URL's should contain no spaces: use ``%20`` instead of spaces. &lt;br&gt;  &lt;br&gt; `See the Appendix &lt;appendices.html#valid-url-s&gt;`_ for a complete description of valid URLs. &lt;br&gt; " id="280" linkTypes="1" links="94" title="Using URLs" />
<node body="Clones are nodes appearing multiple places in the outline. &lt;br&gt;  &lt;br&gt; - Changes to one clone affect all other clones. &lt;br&gt; - All clones of a node are *exactly the same node*. &lt;br&gt;  &lt;br&gt; Views allow multiple views of data to exist in a single outline. &lt;br&gt;  &lt;br&gt; - A view is simply a collection of nodes. &lt;br&gt; - Because of clones, a node may appear in many views at once. &lt;br&gt; - View focus attention on tasks and reduce searching for nodes. &lt;br&gt;  &lt;br&gt; Leo expands abbreviations as you type. &lt;br&gt;  &lt;br&gt; - Abbreviations range from simple shortcuts to multi-line templates containing fields. &lt;br&gt; - Type ``,,`` to move to the next field. &lt;br&gt; - Abbreviations can also insert the result of executing code. &lt;br&gt;      &lt;br&gt; Ctrl-left-clicking any URL opens the URL. &lt;br&gt; " id="281" linkTypes="1" links="94" title="Summary" />
<node body="This tutorial would benefit from an example toolchain for a writer. How to actually get an html file that can be loaded into a word processor to output an .odt or .docx file for example. &lt;br&gt;  &lt;br&gt; For most of the purposes that a programmer would use rst, i.e., documentation or a web page, the tutorial goes far enough. But for those who have different output goals, highlighting the flexibility that Leo with rst should be a primary goal. There are literally hundreds of writers in the world for every programmer. If you want Leo to become popular, this is a critical understanding. &lt;br&gt; " id="282" linkTypes="1" links="95" title="@rst-ignore notes" />
<node body="The rst3 command requires the `docutils`_ Python package. You must also install the `Sphinx`_ package if you use sphinx markup. Sphinx gives Leo's and `Python's`_ web sites their distinctive appearance and features. &lt;br&gt;  &lt;br&gt; After installing docutils or sphinx, you must restart Leo so that the new installation will take effect. &lt;br&gt; " id="283" linkTypes="1" links="95" title="Install docutils and (optional) sphinx" />
<node body=".. index:: &lt;br&gt;     pair: @rst Node; Tutorial &lt;br&gt;      &lt;br&gt; 1. Create a node someplace in your outline. &lt;br&gt;  &lt;br&gt; 2. Type this in the headline:: &lt;br&gt;  &lt;br&gt;         @rst myDocument.html &lt;br&gt;          &lt;br&gt; The @rst node, and all its descendants, represents your document." id="284" linkTypes="1" links="95" title="Create the @rst node" />
<node body="The rst3 command applied to:: &lt;br&gt;  &lt;br&gt;     @rst myDocument.html &lt;br&gt;      &lt;br&gt; will generate an **output file**, myDocument.html, from this node and its children, grand-children, etc. The rst3 command creates the output file in the same directory as the .leo file containing the @rst node. You can specify other directories using absolute or relative paths. Examples:: &lt;br&gt;  &lt;br&gt;     @rst myDocument.html        # in same folder as the .leo file &lt;br&gt;     @rst html/myDocument.html   # in a subfolder &lt;br&gt;     @rst ~/docs/myDocument.html # an absolute path to the folder &lt;br&gt;      &lt;br&gt; The rst3 command writes an **intermediate file** in the same directory as the output file. This intermediate file contains the reStructuredText markup generated by the rst3 command. It has the suffix .txt:: &lt;br&gt;  &lt;br&gt;     myDocument.html.txt &lt;br&gt;  &lt;br&gt;  &lt;br&gt; " id="285" linkTypes="1" links="95" title="The output and intermediate files" />
<node body="Put the rst3_call_docutils setting in the @settings tree in the .leo file containing the @rst node. This setting determines whether to use plain rST markup or full sphinx markup. To use plain reStructuredText markup:: &lt;br&gt;  &lt;br&gt;     @bool rst3_call_docutils = True &lt;br&gt;      &lt;br&gt; To use sphinx markup:: &lt;br&gt;  &lt;br&gt;     @bool rst3_call_docutils = False &lt;br&gt; " id="286" linkTypes="3" links="632" title="Choose docutils or sphinx" />
<node body="Put something like this in the body of the @rst node:: &lt;br&gt;  &lt;br&gt;     ############# &lt;br&gt;     War and Peace &lt;br&gt;     ############# &lt;br&gt;      &lt;br&gt; rST markup uses over/underlining to indicate chapter titles. Put a **overline** consisting of pounds signs above the title (War and Peace), and an identical **underline** of pound signs below as shown. rST markup for chapter titles is a bit picky: &lt;br&gt;  &lt;br&gt; - under/overlines must be at least 4 characters long &lt;br&gt; - under/overlines must be at least as long as the title. &lt;br&gt; - The overline and underline must be identical. &lt;br&gt;  &lt;br&gt; In addition, the rst3 command requires that the &quot;#&quot; character be used in the over/underlines for chapter titles. &lt;br&gt; " id="287" linkTypes="1" links="95" title="Put a title in the @rst node " />
<node body="Put introductory words in the body of the @rst node itself: &lt;br&gt;  &lt;br&gt;     &quot;Well, Prince, so Genoa and Lucca are now just family estates of the &lt;br&gt;     Buonapartes. But I warn you, if you don't tell me that this means war, &lt;br&gt;     if you still try to defend the infamies and horrors perpetrated by that &lt;br&gt;     Antichrist--I really believe he is Antichrist--I will have nothing more &lt;br&gt;     to do with you and you are no longer my friend, no longer my 'faithful &lt;br&gt;     slave,' as you call yourself! But how do you do? I see I have &lt;br&gt;     frightened you--sit down and tell me all the news.&quot; &lt;br&gt;      &lt;br&gt;     It was in July, 1805, and the speaker was the well-known Anna Pavlovna &lt;br&gt;     Scherer, maid of honor and favorite of the Empress Marya Fedorovna. &lt;br&gt;     With these words she greeted Prince Vasili Kuragin, a man of high rank &lt;br&gt;     and importance, who was the first to arrive at her reception. Anna &lt;br&gt;     Pavlovna had had a cough for some days. She was, as she said, suffering &lt;br&gt;     from la grippe; grippe being then a new word in St. Petersburg, used &lt;br&gt;     only by the elite. &lt;br&gt; " id="288" linkTypes="1" links="95" title="Start the chapter" />
<node body="To create a new section, subsection, etc., in the output file: &lt;br&gt;  &lt;br&gt; 1. Create a new outline node, as some descendant of the @rst node. &lt;br&gt;  &lt;br&gt; 2. **The new node's headline becomes the section's title**. &lt;br&gt;  &lt;br&gt; 3. Type the contents of the section in the body text of the node. &lt;br&gt;  &lt;br&gt; That's all there is to it: &lt;br&gt;  &lt;br&gt; - **The rst3 command generates rST underlining automatically**. &lt;br&gt;  &lt;br&gt; - **You reorganize your document by reorganizing nodes**. &lt;br&gt;  &lt;br&gt; There is *no* need to change markup when reorganizing your document, a huge improvement over writing &quot;raw&quot; rST. &lt;br&gt; " id="289" linkTypes="1" links="95" title="Create sections and subsections" />
<node body="Now you write your novel, short story, documentation or whatever. Organize your work as always: &lt;br&gt;  &lt;br&gt; | **nodes create sections, subsections, sub-sub-sections, etc.** &lt;br&gt; | **depending on their position in the outline**. &lt;br&gt; " id="290" linkTypes="1" links="95" title="Write your document" />
<node body=".. index:: &lt;br&gt;     pair: rst3 Command; Tutorial &lt;br&gt;  &lt;br&gt; ``&lt;Alt-X&gt;rst3&lt;Return&gt;`` runs the rst3 command. &lt;br&gt;  &lt;br&gt; - If the present node is an @rst node, or a descendant node of an @rst node, the rst3 command applies to the nearest ancestor @rst node. &lt;br&gt;  &lt;br&gt; - Otherwise, the rst3 command applies to all descendant @rst trees. &lt;br&gt;  &lt;br&gt; If @bool rst3_call_docutils is True, the rst3 command will call docutils automatically to create the output files. For more information about Leo settings, see `this section &lt;tutorial-basics.html#configuring-leo&gt;`_. &lt;br&gt;  &lt;br&gt; When using sphinx, run sphinx's &quot;make&quot; utility after running the rst3 command to create the final output files. &lt;br&gt;  &lt;br&gt; **Errors and warnings**: &lt;br&gt;  &lt;br&gt; 1. Install docutils and then restart Leo if you see this error:: &lt;br&gt;  &lt;br&gt;     writeToDocutils: docutils not present &lt;br&gt;      &lt;br&gt; 2. ​Leo has a default stylesheet ​​that centers titles and makes them big and bold, so you can disregard messages such as:: &lt;br&gt;  &lt;br&gt;     stylesheet not found &lt;path-to&gt;default.css &lt;br&gt; " id="291" linkTypes="1" links="95" title="Run the rst3 command" />
<node body="" id="292" linkTypes="3 3 3" links="633 634 635" title="Other topics" />
<node body="- The rst3 command converts an @rst tree to an output file and an intermediate file. &lt;br&gt;  &lt;br&gt; - docutils uses the output file; sphinx uses the intermediate file. &lt;br&gt;  &lt;br&gt; - Settings starting with &quot;rst3&quot; control how the rst3 command works. &lt;br&gt;  &lt;br&gt; - Within @rst trees, headlines become rST sections. &lt;br&gt;  &lt;br&gt; - Sections levels in the generated rST correspond to outline levels in Leo. &lt;br&gt;  &lt;br&gt; - You reorganize your rST documents just by reorganizing the corresponding @rst tree. &lt;br&gt;    &lt;br&gt; - The rst3 command works acts on the nearest ancestor @rst node, if any, or on all descendant @rst nodes. &lt;br&gt;    &lt;br&gt; - @rst-no-head nodes insert text (or markup) without an rST headline. &lt;br&gt;  &lt;br&gt; - The rst3 command ignores @rst-ignore nodes and @rst-ignore-tree trees. &lt;br&gt;  &lt;br&gt; - The @button make-sphinx node in LeoDocs.leo calls sphinx automatically. &lt;br&gt;  &lt;br&gt; - CheatSheet.leo contains an expanded version of the example used in this tutorial. |br| &lt;br&gt;   You can open CheatSheet.leo from Leo's help menu. &lt;br&gt;    &lt;br&gt; - The rst3 command provides *many* other capabilities. For details, see `the rst3 chapter &lt;rstplugin3.html&gt;`_. &lt;br&gt;   " id="293" linkTypes="1" links="95" title="Summary" />
<node body="You now know enough to get started with the rst3 command. Some possible next steps are: &lt;br&gt;  &lt;br&gt; - Look at Leo's own documentation in LeoDocs.leo. Discover how the nodes in this tree correspond to the documentation you see before you. &lt;br&gt;     &lt;br&gt; - LeoDocs.leo has an @button make-sphinx script that calls sphinx automatically. &lt;br&gt;  &lt;br&gt; - Create your own @rst nodes. Run the rst3 command on them and see what happens. &lt;br&gt;  &lt;br&gt; - If you get stuck, please ask for help at https://groups.google.com/forum/#!forum/leo-editor. &lt;br&gt; " id="294" linkTypes="1" links="95" title="Further study" />
<node body=".. tutorial-programming.html &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @clean; Tutorial &lt;br&gt;  &lt;br&gt; Leo creates **external files** (files on your file system) from **@clean nodes** and their *descendant* nodes. Examples:: &lt;br&gt;  &lt;br&gt;     @clean spam.py &lt;br&gt;     @clean ../foo.c &lt;br&gt;     @clean ~/bar.py &lt;br&gt;  &lt;br&gt; A single Leo outline may contain many @clean nodes. Leo outlines are like project files in other IDE's (Integrated Development Environments). &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Import Script; Tutorial &lt;br&gt;     pair: import-file command; Tutorial &lt;br&gt;  &lt;br&gt; Leo's import-file command creates a single @clean tree using the same importers that @auto uses. When importing several files it is more convenient to use a **import script**. Leo's `Scripting Tutorial &lt;tutorial-scripting.html&gt;`_ discusses such scripts. &lt;br&gt; " id="295" linkTypes="3 3 3" links="636 637 638" title="Using @clean" />
<node body=".. index:: &lt;br&gt;     pair: @file; Tutorial &lt;br&gt;     pair: sentinel lines; Tutorial &lt;br&gt;  &lt;br&gt; Before Leo 5.1, the recommended way to create external files was with **@file trees**. @file trees use the same markup as @clean trees. &lt;br&gt;  &lt;br&gt; The only difference between @clean and @file is that @file insert **sentinel lines** into external files. Sentinel lines are comments corresponding to markup. Sentinel lines *explicitly* represent structure. &lt;br&gt;  &lt;br&gt; Sentinel comments greatly simplify the update algorithm. There are no ambiguous lines @file trees! @file nodes are especially useful when everyone in a project uses Leo. Leo's sources use @file trees for the convenience of Leo developers. &lt;br&gt;  &lt;br&gt; @file is recommended if you seldom share files with others. Nevertheless, &lt;br&gt; most people will prefer to use @clean instead of @file. For example, &lt;br&gt; changing:: &lt;br&gt;  &lt;br&gt;     @clean myfile.py &lt;br&gt;      &lt;br&gt; to:: &lt;br&gt;  &lt;br&gt;     @file myfile.py &lt;br&gt;      &lt;br&gt; in the earlier example will create the file myfile.py whose contents looks something like this:: &lt;br&gt;  &lt;br&gt;     #@+leo-ver=5-thin &lt;br&gt;     #@+node:ekr.20131023081456.2537: * @file myfile.py &lt;br&gt;     #@@language python &lt;br&gt;     #@@tabwidth -4 &lt;br&gt;     #@+&lt;&lt; docstring &gt;&gt; &lt;br&gt;     #@+node:ekr.20131023081456.2538: ** &lt;&lt; docstring &gt;&gt; &lt;br&gt;     '''This is the docstring for this python module.''' &lt;br&gt;     #@-&lt;&lt; docstring &gt;&gt; &lt;br&gt;     #@+others &lt;br&gt;     #@+node:ekr.20131023081456.2539: ** main &lt;br&gt;     def main(): &lt;br&gt;         print('hello from main') &lt;br&gt;     #@-others &lt;br&gt;     if __name__ == '__main__': &lt;br&gt;         main() &lt;br&gt;     #@-leo &lt;br&gt;      &lt;br&gt; Not pleasant to look at. However, sentinel lines won't bother you if you &lt;br&gt; seldom change the external file outside Leo. For example, Leo's developers &lt;br&gt; use @file nodes for Leo's own sources. &lt;br&gt; " id="296" linkTypes="1" links="96" title="Using @file" />
<node body="This tutorial discussed @clean first for three reasons: &lt;br&gt;  &lt;br&gt; 1. To avoid making excuses for sentinel lines. &lt;br&gt;  &lt;br&gt; 2. To brag about the @clean update algorithm. &lt;br&gt;  &lt;br&gt; 3. It is often more convenient to avoid sentinels. For example, when I study other people's code I do the following: &lt;br&gt;  &lt;br&gt; - Create a `git &lt;http://git-scm.com/&gt;`_ repo of the directory to be studied, adding all the source files and doing an initial commit. &lt;br&gt;    &lt;br&gt; - Use an `import script &lt;tutorial-scripting.html#import-scripts&gt;`_ to create the desired @clean nodes. &lt;br&gt;  &lt;br&gt; - Explicitly save all the imported files using Ctrl-Shift-W (write-at-file-nodes). &lt;br&gt;  &lt;br&gt; - Use git diff to ensure that no important changes have been made while importing the nodes. &lt;br&gt;  &lt;br&gt; - Use git diff to track any changes I make (such as adding tracing or debugging statements) for the purposes of studying the code. &lt;br&gt;  &lt;br&gt; Using @clean is an essential part of this work flow. The diffs would be much harder to read if I had imported files into @file trees instead. &lt;br&gt;  &lt;br&gt; Nevertheless, there are advantages to using @file instead of @clean. All these advantages arise because external files created by @file contain explicit outline structure. &lt;br&gt;  &lt;br&gt; 1. Leo can read @file trees more quickly and without guesses. There is never any need for you to move ambiguous lines from one node to another. &lt;br&gt;     &lt;br&gt; 2. Sentinels allow you to share structure simply by sending the external file. This is an overwhelming advantage for Leo's developers. &lt;br&gt;     &lt;br&gt; 3. A minor advantage: @file makes Leo files smaller. Leo stores the entire @clean *tree* in the .leo file, but only stores the top-level @file *node* in the .leo file. &lt;br&gt;     &lt;br&gt; In short: use @clean for most purposes. Use @file when all developers in a project use Leo. &lt;br&gt; " id="297" linkTypes="1" links="96" title="Summary: @clean vs @file" />
<node body=".. index:: &lt;br&gt;     pair: @edit; Tutorial &lt;br&gt;  &lt;br&gt; Use @edit instead of @clean to place the entire contents of an external file into a single outline node. Leo writes no sentinel when writing @edit files. &lt;br&gt; " id="298" linkTypes="1" links="96" title="Using @edit" />
<node body="Use @auto instead of @clear when you expect other people to make substantial changes to an external file without using Leo. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @auto; Tutorial &lt;br&gt;     pair: Importer; Tutorial &lt;br&gt;  &lt;br&gt; When reading @auto files, Leo **importers** create an outline from the external file. Importers create nodes for each class, method and function in the external file. &lt;br&gt;  &lt;br&gt; Notes: &lt;br&gt;  &lt;br&gt; - Leo determines the language using the file's extension. &lt;br&gt;  &lt;br&gt; - Importers exist for C, C#, elisp, html, .ini files, Java, Javascript, Pascal, PHP, Python, TypeScript, vimoutliner files and xml. &lt;br&gt;  &lt;br&gt; - If no importer exists for a file, Leo reads the entire file into an @edit node. &lt;br&gt; " id="299" linkTypes="3" links="639" title="Using @auto" />
<node body="You now know enough to create external files and to choose between @clean and @file. The following sections discuss directives affecting external files. &lt;br&gt; " id="300" linkTypes="3 3" links="640 641" title="Directives" />
<node body="- @clean, @file, @edit and @auto trees create external files. @clean is recommended for most purposes. &lt;br&gt;  &lt;br&gt; - When writing @clean, @file and @auto trees, Leo replaces @others and section references with their expansions. &lt;br&gt;    &lt;br&gt; - A **section name** is any text of the form: ``&lt;&lt; any text &gt;&gt;``. &lt;br&gt;  &lt;br&gt; - A **section definition node** is a node whose headline starts with a section name. &lt;br&gt;  &lt;br&gt; - A **section reference** is a section name in body text. &lt;br&gt;  &lt;br&gt; - @edit reads an entire external file into the body text of the @edit node. &lt;br&gt;  &lt;br&gt; - @auto imports an external file into an outline, creating nodes for functions, methods and classes. @persistence nodes optionally save gnx's and uA's of @auto trees in a semi-permanent way. &lt;br&gt;    &lt;br&gt; - @first places lines before the first sentinel lines of a file. &lt;br&gt;  &lt;br&gt; - @path specifies a common prefix for file names of @clean, @file, @edit and @auto nodes. &lt;br&gt;  &lt;br&gt; - leo/core/LeoPyRef.leo contains all of Leo's core source code. &lt;br&gt; " id="301" linkTypes="1" links="96" title="Summary" />
<node body="Any Leo node may contain a Python script. &lt;br&gt;  &lt;br&gt; ``Ctrl-B (execute-script)`` executes the body text of the presently selected node. &lt;br&gt;  &lt;br&gt; | execute-script creates the script using @others and section references: &lt;br&gt; | **you can create complex scripts from a node and its descendants.** &lt;br&gt;  &lt;br&gt; | As discussed below, execute-script predefines three variables: c, g and p. &lt;br&gt; | Using these variables, scripts may easily do any of the following: &lt;br&gt;  &lt;br&gt; - Gain access to all data contained in any Leo outline. &lt;br&gt; - Traverse the data in any outline. &lt;br&gt; - Use utility classes and function in the leo.core.leoGlobals module. &lt;br&gt; - Execute any code in Leo's own code base. &lt;br&gt; " id="302" linkTypes="1" links="97" title="Overview" />
<node body=".. index:: &lt;br&gt;     pair: Hello World Example; Tutorial &lt;br&gt;  &lt;br&gt; Here is the obligatory &quot;Hello World!&quot; script:: &lt;br&gt;  &lt;br&gt;     g.es('Hello World!') &lt;br&gt;      &lt;br&gt; In more detail: &lt;br&gt;  &lt;br&gt; 1. Create a node anywhere in the outline. &lt;br&gt; 2. Put g.es('hello, world!') in the node's body text. &lt;br&gt; 3. Select the node and type Ctrl-B. &lt;br&gt;  &lt;br&gt; Notes: &lt;br&gt;  &lt;br&gt; - Output should appear in the log pane. &lt;br&gt; - ``Ctrl-B (execute-script)`` executes the body text of the selected node as a Python script. &lt;br&gt; - If text is selected, execute-script executes only the selected text. &lt;br&gt; - g.es prints its arguments to Leo's log pane. &lt;br&gt;  &lt;br&gt; ..  You can use Ctrl-B even if you are reading this in leoDocs.leo! &lt;br&gt;  &lt;br&gt; **Important**: g seems to be undefined, yet this script *does* work without error, because... &lt;br&gt; " id="303" linkTypes="1" links="97" title="Hello world" />
<node body=".. index:: &lt;br&gt;     pair: Predefined Symbols; Tutorial &lt;br&gt;      &lt;br&gt; The execute-script command predefines the symbols c, g and p. &lt;br&gt;  &lt;br&gt; c is the **commander** of the outline containing the script. &lt;br&gt;  &lt;br&gt; - Commanders are instances of the Commands class, defined in leoCommands.py. &lt;br&gt;  &lt;br&gt; - Commanders provide access to all outline data *and* all of Leo's source code. &lt;br&gt;  &lt;br&gt; g is Leo's **leo.core.leoGlobals** module. &lt;br&gt;  &lt;br&gt; - This module contains many useful functions, including g.es. &lt;br&gt;  &lt;br&gt; p is the **position** of the presently selected node. &lt;br&gt;  &lt;br&gt; - positions are instances of the position class, defined in leoNodes.py. &lt;br&gt;  &lt;br&gt; - The position class provides safe, convenient ways of accessing and &lt;br&gt;   modifying outline nodes. &lt;br&gt;  &lt;br&gt; - For any position p, p.v is a **vnode** object. &lt;br&gt;  &lt;br&gt; - vnodes contain all the permanent data in a Leo outline. &lt;br&gt;  &lt;br&gt; The next two sections are crucial: they discuss vnodes and positions in all necessary detail. &lt;br&gt; " id="304" linkTypes="1" links="97" title="Predefined symbols: c, g and p" />
<node body=".. index:: &lt;br&gt;     pair: Vnode; Tutorial &lt;br&gt;     pair: vnode class; Tutorial &lt;br&gt;  &lt;br&gt; This section discusses vnodes; the next discusses positions. To script Leo properly, you *must* understand how vnodes and positions are related. &lt;br&gt;  &lt;br&gt; **vnodes** are instances of the vnode class, defined in leoNodes.py. Each vnode represents *all* the data associated with an outline node, including *private* data carrying its outline structure. For each vnode v: &lt;br&gt;  &lt;br&gt; - v.b is the (outline) node's body text. &lt;br&gt;  &lt;br&gt; - v.h is the node's headline. &lt;br&gt;  &lt;br&gt; - v.u is the nodes **user data**, discussed later in this chapter. &lt;br&gt;  &lt;br&gt; | **All cloned outline nodes share a common vnode**. Conversely, &lt;br&gt; | each vnode represents *all* the clones of the corresponding outline node. &lt;br&gt;  &lt;br&gt; Because a *single* vnode can represent *many* outline nodes, it is awkward to use vnodes directly. This is where positions come in: **positions simplify access to vnodes**... &lt;br&gt; " id="305" linkTypes="1" links="97" title="Vnodes" />
<node body=".. index:: &lt;br&gt;     pair: Position; Tutorial &lt;br&gt;     pair: position class; Tutorial &lt;br&gt;  &lt;br&gt; A **position** represents a specific outline node at an exact location in the outline. Positions are instances of the position class, defined in leoNodes.py. Methods of the position class provide safe ways to insert, delete and move outline nodes. The `scripting portion`_ of `Leo's cheat sheet`_ lists the most important methods of the position class. &lt;br&gt;  &lt;br&gt; - The vnode at position p is p.v. &lt;br&gt;  &lt;br&gt; - Because all clones share the same vnode, many positions may have the same p.v field. &lt;br&gt;  &lt;br&gt; - p.b, p.h and p.u are synonyms for p.v.b, p.v.h and p.v.u. &lt;br&gt;  &lt;br&gt; - For any commander c, c.p is the presently selected node. &lt;br&gt;  &lt;br&gt; **positions usually become invalid when outline structure changes**. Scripts should store positions for later use only if the script does not cause the outline to change in any way. &lt;br&gt;  &lt;br&gt; - c.positionExists(p) returns True if p is (still) valid in c's outline. &lt;br&gt;  &lt;br&gt; The next section describes generators. Generators are a great way of gaining access to outline nodes. &lt;br&gt; " id="306" linkTypes="1" links="97" title="Positions" />
<node body=".. index:: &lt;br&gt;     pair: Generator; Tutorial &lt;br&gt;  &lt;br&gt; Leo generators are `Python generators &lt;https://wiki.python.org/moin/Generators&gt;`_. These generators traverse (step through) Leo outlines node by node: **Leo generators yield a sequence of positions.** &lt;br&gt;  &lt;br&gt; The Commands (commander) and position classes define several generators, discussed later in this chapter. c.all_positions() traverses the outline in outline order.  The following prints a properly-indented list of all headlines:: &lt;br&gt;  &lt;br&gt;     for p in c.all_positions(): &lt;br&gt;         print(' '*p.level()+p.h) &lt;br&gt;          &lt;br&gt; Leo generators **yield** (return a sequence of) positions. They do *not* return actual lists; this saves lots of space for large outlines. In fact, this &quot;sequence of positions&quot; is actually a sequence of a **single, constantly changing** position. This is a very important space optimization. &lt;br&gt;    &lt;br&gt; When a generator is finished, this single position becomes an **empty position**. p.v is None for empty positions. There are the right and wrong ways to test for empty positions:: &lt;br&gt;  &lt;br&gt;     if not p:       # Right &lt;br&gt;     if not p.v:     # Right &lt;br&gt;     if p is None:   # Wrong! &lt;br&gt;      &lt;br&gt; The `scripting portion`_ of `Leo's cheat sheet`_ lists all of Leo's generators. &lt;br&gt;   " id="307" linkTypes="1" links="97" title="Generators" />
<node body=".. index:: &lt;br&gt;     pair: Capturing Positions; Tutorial &lt;br&gt;     pair: p.copy(); Tutorial &lt;br&gt;      &lt;br&gt; As mentioned previously, **positions become invalid whenever nodes are inserted, deleted or moved**. &lt;br&gt;  &lt;br&gt; It is valid to capture positions *temporarily*, *provided* that the outline does not changed while the captured positions are being used. Here is the proper way:: &lt;br&gt;  &lt;br&gt;     aList = [p.copy() for p in c.all_positions()] &lt;br&gt;         # aList is valid until the outline changes. &lt;br&gt;          &lt;br&gt; The p.copy() method returns a *separate* position that does not change when p changes. Beginners erroneously try to capture positions like this:: &lt;br&gt;  &lt;br&gt;     aList = [p for p in c.all_positions()] # Wrong! &lt;br&gt;      &lt;br&gt; This is wrong. Leo's generators use a single position, and yield that *same* position for every node in the outline. Furthermore, that position will be empty when the generator ends, so every member of aList will be the (same) empty position! &lt;br&gt; " id="308" linkTypes="1" links="97" title="Capturing positions" />
<node body="Wrapper and widget classes are at the heart of Leo's design. A **widget** is an actual Qt widget. Leo's core seldom accesses widgets directly. &lt;br&gt;  &lt;br&gt; A **wrapper** is an object whose api hides the details of the underlying gui **text** widgets. Leo's core uses this api almost exclusively. That is, Leo's core treats wrappers *as if* they were only text widgets there are! &lt;br&gt;  &lt;br&gt; There is a back door for rare special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using ``wrapper.widget``. Searching for ``wrapper.widget`` should find all gui-dependent snippets of code in Leo's core. &lt;br&gt;  &lt;br&gt; Wrappers are crucial, even if Leo *always* uses the Qt gui. Wrappers allow users to choose different Qt widgets for the body pane, without changing *any* of Leo's core code, except the startup code that actually allocates widgets. Wrappers allow Leo's text-handling code to remain unchanged regardless of whether the body or log panes are a QTextBrowser or a QsciScintilla widget. Without wrappers, all of Leo's text-editing commands would have to know the details of the api of the actual Qt text widget! &lt;br&gt; " id="309" linkTypes="1" links="97" title="wrappers vs. widgets" />
<node body=".. _`Leo's Directive Reference`: directives.html &lt;br&gt; .. _`Leo's cheat sheet`: cheatsheet.html &lt;br&gt; .. _`scripting portion`: cheatsheet.html#scripting &lt;br&gt;  &lt;br&gt; The `scripting portion`_ of `Leo's cheat sheet`_ contains much more information about scripting, including lists of Leo's generators and useful methods of the commander and position classes. &lt;br&gt;  &lt;br&gt; `Leo's Directive Reference`_ discusses all directives in great detail. It would be a good idea to skim this chapter to see what it contains. &lt;br&gt; " id="310" linkTypes="1" links="97" title="Further study" />
<node body=".. index:: &lt;br&gt;     pair: Autocompletion; Tutorial &lt;br&gt;      &lt;br&gt; Autocompletion reminds you of all members (functions, methods, ivars, etc.) contained in objects in Leo's source code, and in Python's standard library modules. &lt;br&gt;  &lt;br&gt; Alt-1 (toggle-autocompleter) enables and disables autocompletion. **Note**: Autocompletion can be enabled only when @language python is in effect. &lt;br&gt;  &lt;br&gt; For example, typing just &quot;c.atF&quot; (in the body pane, with autocompletion enabled) automatically inserts &quot;c.atFileCommands&quot; into the body pane, because &quot;c.atFileCommands&quot; is the only possible completion of &quot;c.atF&quot;. &lt;br&gt;  &lt;br&gt; As another example, typing &quot;at.writeA&quot; will show (in an autocompleter tab in the Log pane) all of the write commands in leoAtFile.py:: &lt;br&gt;  &lt;br&gt;     writeAll:method &lt;br&gt;     writeAllHelper:method &lt;br&gt;     writeAtAutoNodes:method &lt;br&gt;     writeAtAutoNodesHelper:method &lt;br&gt;     writeAtShadowNodes:method &lt;br&gt;     writeAtShadowNodesHelper:method &lt;br&gt;  &lt;br&gt; When a single completion is shown, typing '?' will show the docstring for a method. For example, &quot;c.atFileCommands.write?&quot; shows:: &lt;br&gt;  &lt;br&gt;     Write a 4.x derived file. &lt;br&gt;     root is the position of an @&lt;file&gt; node &lt;br&gt; " id="311" linkTypes="1" links="97" title="Autocompletion" />
<node body=".. index:: &lt;br&gt;     pair: Calltips; Tutorial &lt;br&gt;  &lt;br&gt; Calltips show the expected arguments to functions and methods: &lt;br&gt;  &lt;br&gt; - Alt-2 (toggle-calltips) enables and disables calltips. &lt;br&gt; - '(' shows calltips, when @language python is in effect. &lt;br&gt; - &lt;Return&gt; or Ctrl-G (keyboard-quit) exits calltips. &lt;br&gt;  &lt;br&gt; Calltips work for any Python function or method, including Python's global functions. Examples:: &lt;br&gt;  &lt;br&gt;     g.toUnicode(            g.toUnicode(s, encoding, reportErrors=False &lt;br&gt;     c.widgetWantsFocusNow(  c.widgetWantsFocusNow(w &lt;br&gt;     reduce(                 reduce(function, sequence[, initial]) -&gt; value &lt;br&gt; " id="312" linkTypes="1" links="97" title="Calltips" />
<node body=".. index:: &lt;br&gt;     pair: Script Button; Tutorial &lt;br&gt;     pair: @button Node; Tutorial &lt;br&gt;  &lt;br&gt; @button nodes create **script buttons** in Leo's icon area. &lt;br&gt;  &lt;br&gt; Each @button node also creates a corresponding minibuffer command. &lt;br&gt;  &lt;br&gt; Pressing the script button (or executing the command from the minibuffer) applies the script in the @button node to the presently selected outline node. &lt;br&gt;  &lt;br&gt; Script buttons **bring scripts to outlines** a powerful pattern. Creating an @button script should be your first thought whenever you want to automate any task. &lt;br&gt;  &lt;br&gt; - The mod_scripting.py plugins must be enabled to create @button nodes. &lt;br&gt;  &lt;br&gt; - Script buttons execute the **present** body text of the @button node. You can modify a script button's script at any time. &lt;br&gt;  &lt;br&gt; - You can bind keys to the commands created by script buttons:: &lt;br&gt;  &lt;br&gt;     @button my-button @key=Alt-8 &lt;br&gt;  &lt;br&gt; - Right-clicking a script button deletes it. &lt;br&gt; " id="313" linkTypes="1" links="97" title="Using @button nodes" />
<node body=".. index:: &lt;br&gt;     pair: @test Node; Tutorial &lt;br&gt;  &lt;br&gt; Leo's unit test commands (&lt;Alt-X&gt;run&lt;tab&gt; gives the full list) create unit tests from the body text of @test nodes. &lt;br&gt;  &lt;br&gt; - The headline gives the name of the test:: &lt;br&gt;  &lt;br&gt;     @test test that g is predefined &lt;br&gt;      &lt;br&gt; - The body contains the unit test:: &lt;br&gt;  &lt;br&gt;     assert g &lt;br&gt;      &lt;br&gt; - The unit test commands convert the body to a subclass of unittest.TestCase.  This saves a lot of typing. &lt;br&gt;    &lt;br&gt; - The unit test commands predefine c, g, and p as usual. &lt;br&gt;  &lt;br&gt; - 'self' is predefined as the test itself, that is, the instance of unittest.TestCase created by the @test node. For example:: &lt;br&gt;    &lt;br&gt;     self.assertTrue(g) &lt;br&gt;      &lt;br&gt; For more details, see `Leo's unit-testing reference &lt;unitTesting.html&gt;`_. &lt;br&gt; " id="314" linkTypes="1" links="97" title="Using @test nodes" />
<node body="The following script imports files from a given directory and all subdirectories:: &lt;br&gt;  &lt;br&gt;     c.recursiveImport( &lt;br&gt;         dir_ = 'path to file or directory', &lt;br&gt;         kind = '@clean',        # or '@file' or '@auto' &lt;br&gt;         one_file = False,       # True: import only one file. &lt;br&gt;         safe_at_file = False,   # True: generate @@clean nodes. &lt;br&gt;         theTypes = None,        # Same as ['.py'] &lt;br&gt;     ) &lt;br&gt; " id="315" linkTypes="1" links="97" title="Import scripts" />
<node body="- execute-script predefines c, g and p. &lt;br&gt; - c is a commander, g is the leoGlobals module, and p is the current position. &lt;br&gt; - Vnodes contain all outline data. &lt;br&gt; - Positions provide easy access to vnodes. &lt;br&gt; - Positions become invalid when outline nodes are inserted, deleted or moved. &lt;br&gt; - Generators visit all or parts of the outline, in a specified order. &lt;br&gt; - Generators yield a *single* position whose value constantly changes. &lt;br&gt; - p.copy() yields a new position that does not change when p changes. &lt;br&gt; - Alt-1 enables autocompletion. &lt;br&gt; - Leo's autocompleter understands symbols such as c, g, g.app, etc. &lt;br&gt; - @button nodes create scripts that can be applied to any outline node. &lt;br&gt; - @test nodes create unit tests (subclasses of unittest.TestCase) from body text." id="316" linkTypes="1" links="97" title="Summary" />
<node body="These are not included on the web, but may be of interest to those &lt;br&gt; reading LeoDocs.leo." id="317" linkTypes="3 3" links="642 643" title="@rst-ignore-tree scripting examples" />
<node body="################ &lt;br&gt; Customizing Leo &lt;br&gt; ################ &lt;br&gt;  &lt;br&gt; This chapter discusses how to customize Leo using the plugins and other means. See `Specifying settings`_ for a description of how to change Leo's settings. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="318" linkTypes="3 3 3 3 3" links="644 645 646 647 648" title="@rst html\customizing.html" />
<node body="###################### &lt;br&gt; rst3 Command Reference &lt;br&gt; ###################### &lt;br&gt;  &lt;br&gt; .. _`rst3 tutorial`: tutorial-rst3.html &lt;br&gt;  &lt;br&gt; Please read the `rst3 tutorial`_ before reading this chapter. &lt;br&gt;  &lt;br&gt; This chapter covers advanced settings and features of the rst3 command. It is for power users only. &lt;br&gt;  &lt;br&gt; *Are you sure you want to read this chapter?* The tutorial covers everything most people need to know about the rst3 command. Leo's own documentation uses none of the features discussed here. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 4 &lt;br&gt; " id="319" linkTypes="3 3 3 3 3 3" links="649 650 651 652 653 654" title="@rst html\rstplugin3.html" />
<node body="####### &lt;br&gt; Plugins &lt;br&gt; ####### &lt;br&gt;  &lt;br&gt; .. _`Using @button nodes`:  tutorial-scripting#using-button-nodes &lt;br&gt; .. _`Writing Plugins`:  writingPlugins.html &lt;br&gt;  &lt;br&gt; This chapter discusses the plugins contained in leoPlugins.leo. These plugins are part of Leo's official distribution. The next chapter, `Writing Plugins`_, tells how to write plugins. &lt;br&gt;  &lt;br&gt; The scripting plugin (mod_scripting.py) deserves special mention. This plugin lets you create **script buttons** in a matter of seconds. See `Using @button nodes`_. Script buttons are extraordinarily useful. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 5 &lt;br&gt; " id="320" linkTypes="3 3 3 3" links="655 656 657 658" title="@rst html\plugins.html" />
<node body="######################## &lt;br&gt; Leo's Commands Reference &lt;br&gt; ######################## &lt;br&gt;  &lt;br&gt; This chapter discusses the basics of using Leo, including all of Leo's commands. It starts with a discussion of the Emacs-like minibuffer, then continues with a discussion of commands in each of Leo's menus. &lt;br&gt;  &lt;br&gt; **Very Important**: Leo has hundreds of commands, but because of tab completion you do not have to remember, or even *know about* any of them.  Feel free to ignore commands that you don't use. It *is* good to know the following prefixes for tab completion in the minibuffer::  &lt;br&gt;  &lt;br&gt;     file-       file commands &lt;br&gt;     find-       find commands &lt;br&gt;     isearch-    incremental search commands &lt;br&gt;     print-      print commands &lt;br&gt;     rectangle-  rectangle commands &lt;br&gt;     toggle-     toggle settings commands &lt;br&gt;      &lt;br&gt; .. Less important prefixes: &lt;br&gt; ..  abbrev-     abbreviation commands &lt;br&gt; ..  buffer-     buffer commands &lt;br&gt; ..  ddabrev-    dynamic abbreviations &lt;br&gt; ..  directory-  directory commands &lt;br&gt; ..  gc-         garbage collection commands &lt;br&gt; ..  macro-      macro expansion commands &lt;br&gt; ..  register-   register commands &lt;br&gt; ..  run-        run unit tests commands &lt;br&gt; ..  yank-       yank commands &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 2 &lt;br&gt; " id="321" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677" title="@rst html\commands.html" />
<node body=".. Aliases. &lt;br&gt; find-clone-all &lt;br&gt; find-clone-all-flattened &lt;br&gt; find-next-clone &lt;br&gt; find-quick &lt;br&gt; find-quick-changed &lt;br&gt; find-quick-selected &lt;br&gt; find-quick-test-failures &lt;br&gt; find-quick-timeline &lt;br&gt; global-search &lt;br&gt;  &lt;br&gt; .. No longer used. &lt;br&gt; disable-idle-time-tracing &lt;br&gt; enable-idle-time-tracing &lt;br&gt; toggle-idle-time-tracing &lt;br&gt;  &lt;br&gt; .. Deprecated tangle/untangle commands. &lt;br&gt; tangle &lt;br&gt; tangle-all &lt;br&gt; tangle-marked &lt;br&gt; untangle &lt;br&gt; untangle-all &lt;br&gt; untangle-marked &lt;br&gt;  &lt;br&gt; .. Obscure, unused, minibuffer-related commands. &lt;br&gt; advertised-undo &lt;br&gt; context-menu-open &lt;br&gt; digit-argument &lt;br&gt; menu-shortcut &lt;br&gt; negative-argument &lt;br&gt; number-command &lt;br&gt; number-command-0 &lt;br&gt; number-command-1 &lt;br&gt; number-command-2 &lt;br&gt; number-command-3 &lt;br&gt; number-command-4 &lt;br&gt; number-command-5 &lt;br&gt; number-command-6 &lt;br&gt; number-command-7 &lt;br&gt; number-command-8 &lt;br&gt; number-command-9 &lt;br&gt; self-insert-command &lt;br&gt; universal-argument &lt;br&gt; " id="322" linkTypes="1" links="102" title="@rst-ignore Not documented" />
<node body="#################### &lt;br&gt; Directives Reference &lt;br&gt; #################### &lt;br&gt;  &lt;br&gt; .. |br| raw:: html &lt;br&gt;  &lt;br&gt;    &lt;br /&gt; &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 4 &lt;br&gt; " id="323" linkTypes="3 3 3 3 3" links="678 679 680 681 682" title="@rst html/directives.html" />
<node body="############# &lt;br&gt; Leo and Emacs &lt;br&gt; ############# &lt;br&gt;  &lt;br&gt; This chapter several topics relating to the Emacs editor. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 2 &lt;br&gt; " id="324" linkTypes="3 3 3 3" links="683 684 685 686" title="@rst html\emacs.html" />
<node body="################### &lt;br&gt; Using Vim with Leo &lt;br&gt; ################### &lt;br&gt;  &lt;br&gt; This chapter discusses these topics: &lt;br&gt;  &lt;br&gt; - How to enable and use Leo's new vim-emulation mode. &lt;br&gt; - How to import and export vim's .otl files. &lt;br&gt; - How to install and use stand-alone vim-like bindings. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="325" linkTypes="3 3 3" links="687 688 689" title="@rst html\vimBindings.html" />
<node body="########################## &lt;br&gt; ILeo: Leo's IPython Bridge &lt;br&gt; ########################## &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 2 &lt;br&gt; " id="326" linkTypes="3 3 3 3 3 3 3" links="690 691 692 693 694 695 696" title="@rst html\IPythonBridge.html" />
<node body="####################################### &lt;br&gt; Embedding Leo with the leoBridge module &lt;br&gt; ####################################### &lt;br&gt;  &lt;br&gt; The leoBridge module allows complete access to all aspects of Leo from other &lt;br&gt; Python programs running independently of Leo. Let us call such a program a &lt;br&gt; **host** program. Using the leoBridge module, host programs can get access to: &lt;br&gt;  &lt;br&gt; - all of Leo's source code, &lt;br&gt; - the contents of any .leo file, &lt;br&gt; - the commander of any .leo file. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 2 &lt;br&gt;  &lt;br&gt; " id="327" linkTypes="3 3 3" links="697 698 699" title="@rst html\leoBridge.html" />
<node body="################### &lt;br&gt; Using ZODB with Leo &lt;br&gt; ################### &lt;br&gt;  &lt;br&gt; .. _`ZODB`: http://www.zope.org/Wikis/ZODB/guide/zodb.html &lt;br&gt;  &lt;br&gt; This chapter discusses how to write Leo scripts that store and retrieve data using `ZODB`_. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 2 &lt;br&gt; " id="328" linkTypes="3 3 3 3 3 3 3" links="700 701 702 703 704 705 706" title="@rst html\zodb.html" />
<node body="########################### &lt;br&gt; Controlling Syntax Coloring &lt;br&gt; ########################### &lt;br&gt;  &lt;br&gt; This chapter discusses the settings to control Leo's syntax colorer. This chapter also discusses how to extend Leo's colorizer by creating xml language descriptions files and corresponding Python files. **Important**: this material is for those who want to support Leo's colorizing code. To use Leo's colorizers you only need to know about syntax-coloring settings. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="329" linkTypes="3 3 3 3 3" links="707 708 709 710 711" title="@rst html\coloring.html" />
<node body="############### &lt;br&gt; Writing Plugins &lt;br&gt; ############### &lt;br&gt;  &lt;br&gt; .. _`Scripting Leo with Python`: tutorial-scripting.html &lt;br&gt;  &lt;br&gt; Plugins modify how Leo works. With plugins you can give Leo new commands, &lt;br&gt; modify how existing commands work, or change any other aspect of Leo's look &lt;br&gt; and feel. &lt;br&gt;  &lt;br&gt; leoPlugins.leo contains all of Leo's official plugins. Studying this file is &lt;br&gt; a good way to learn how to write plugins. &lt;br&gt;  &lt;br&gt; Writing plugins is like writing any other Leo script.  See &lt;br&gt; `Scripting Leo with Python`_. In particular: &lt;br&gt;  &lt;br&gt; 1. Plugins can use any of Leo's source code simply by importing any module &lt;br&gt;    defined in leoPy.leo. &lt;br&gt;  &lt;br&gt; 2. Plugins can register event handlers just like any other Leo script. For full &lt;br&gt;    details, see the section called `Handling Events`_ later in this chapter. &lt;br&gt;  &lt;br&gt; The rest of this chapters discusses topics related specifically to plugins. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="330" linkTypes="3 3 3 3 3 3" links="712 713 714 715 716 717" title="@rst html\writingPlugins.html" />
<node body="##################### &lt;br&gt; Unit testing with Leo &lt;br&gt; ##################### &lt;br&gt;  &lt;br&gt; .. _`run Leo in a console window`: installing.html#running-leo-from-a-console-window &lt;br&gt;  &lt;br&gt; This chapter describes how you can execute Python unit test from within Leo &lt;br&gt; outlines. &lt;br&gt;  &lt;br&gt; Leo's **unit test commands** run the unit tests created by @test and @suite &lt;br&gt; nodes. run-unit-tests and run-unit-tests-locally run all unit tests in the &lt;br&gt; presently selected part of the Leo outline; run-all-unit-tests and &lt;br&gt; run-all-unit-tests-locally run all unit tests in the entire Leo outline. &lt;br&gt;  &lt;br&gt; Important: you must `run Leo in a console window`_ to see the output the &lt;br&gt; unit tests. Leo's unit test commands run all the unit tests using the &lt;br&gt; standard unittest text test runner, and the output of the unit tests &lt;br&gt; appears in the console. &lt;br&gt;  &lt;br&gt; test/unitTest.leo contains many examples of using @test and @suite nodes. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 2 &lt;br&gt; " id="331" linkTypes="3 3 3 3 3 3" links="718 719 720 721 722 723" title="@rst html\unitTesting.html" />
<node body="################## &lt;br&gt; Debugging with Leo &lt;br&gt; ################## &lt;br&gt;  &lt;br&gt; This chapter discusses debugging Python scripts with Leo. &lt;br&gt; Be aware of the distinction between **Leo-specific** scripts and **general** scripts. &lt;br&gt; Leo-specific scripts access data in the Leo outline in which they are contained; &lt;br&gt; general scripts do not. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="332" linkTypes="3 3 3" links="724 725 726" title="@rst html\debuggers.html" />
<node body="############################# &lt;br&gt; A Miscellany of Leo Scripting &lt;br&gt; ############################# &lt;br&gt;  &lt;br&gt; This chapter covers miscellaneous topics related to Leo scripts. &lt;br&gt;  &lt;br&gt; You might call this a FAQ for scripts... &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="333" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745" title="@rst html\scripting-miscellany.html" />
<node body="######################### &lt;br&gt; Exploring Leo's Code Base &lt;br&gt; ######################### &lt;br&gt;  &lt;br&gt; .. |br| raw:: html &lt;br&gt;  &lt;br&gt;    &lt;br /&gt; &lt;br&gt;     &lt;br&gt; This chapter is for anyone who wants to understand Leo's code base, &lt;br&gt; including those who want to be one of Leo's implementors. &lt;br&gt;  &lt;br&gt; You already know that leoFind.py and leoUndo.py implement Leo's find and &lt;br&gt; undo command, and so on. &lt;br&gt;  &lt;br&gt; This chapter focuses on the *process* of finding your way around Leo's &lt;br&gt; code, not the myriad details you will find within Leo's code. &lt;br&gt;  &lt;br&gt; It's actually very easy! Try it. You'll see. &lt;br&gt;  &lt;br&gt; Reading this chapter should take about 20 minutes. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="334" linkTypes="3 3 3 3 3 3 3 3 3" links="746 747 748 749 750 751 752 753 754" title="@rst html/theory.html" />
<node body="############################# &lt;br&gt; Vim Mode: Theory of Operation &lt;br&gt; ############################# &lt;br&gt;  &lt;br&gt; .. |br| raw:: html &lt;br&gt;  &lt;br&gt;    &lt;br /&gt; &lt;br&gt;     &lt;br&gt; This is the theory of operation of Leo's vim mode, contained in &lt;br&gt; leo/core/leoVim.py. It discusses everything you need to understand the code &lt;br&gt; and to add new vim commands. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :depth: 3 &lt;br&gt; " id="335" linkTypes="3 3 3 3" links="755 756 757 758" title="@rst html/vim-theory.html" />
<node body="################# &lt;br&gt; The Leonine World &lt;br&gt; ################# &lt;br&gt;  &lt;br&gt; **Leonine** refers to Leo's unique way of organizing data and programs. This has many implications: &lt;br&gt;  &lt;br&gt; **Browsing**: Leo remembers your outline organization. Class browsers don't. Doh! &lt;br&gt;  &lt;br&gt; **The big picture**: Outline nodes hide messy details, revealing the big picture *at all times*. &lt;br&gt;  &lt;br&gt; **Programming**: Leo outlines naturally organize programs into modules, classes and functions. Leonine sources are their own design document. How you organize outlines is a choice in a new design space. &lt;br&gt;  &lt;br&gt; **User-defined types**: Headlines naturally describe a node's contents: **headlines naturally define types**. Leo's core supports types such as @button, @rst, @suite, @url, etc. Plugins define @bookmark, @graph, @html and @task types. Scripts can easily define other types. &lt;br&gt;  &lt;br&gt; **Testing**: Leo's @test nodes creates a unique unit-testing framework: &lt;br&gt;  &lt;br&gt; - @test nodes focus on the real test code. &lt;br&gt; - It is easy to run only the @test nodes in a particular suboutline. &lt;br&gt; - @test scripts can easily use data in their children. &lt;br&gt;  &lt;br&gt; .. _`clone-find`: tutorial-basics.html#clone-find-commands &lt;br&gt;  &lt;br&gt; **Work flow**: The `clone-find`_ commands gather all match a pattern under a single node. No need to keep searching for them. You can change the clones, and the original nodes change as well. This is a great way to fix bugs or to write books. &lt;br&gt;  &lt;br&gt; **Databases**: Leo's clones create new opportunities for scriptable databases. In my brother Speed's outlines, suboutlines *are* SQL queries! &lt;br&gt; " id="336" linkTypes="1" links="118" title="@rst html\leonine-world.html" />
<node body="" id="337" linkTypes="3 3 3" links="759 760 761" title="Key bindings" />
<node body="For much more information, see the `Commands Reference`_. &lt;br&gt;  &lt;br&gt; Copy/Paste (text):: &lt;br&gt;  &lt;br&gt;     Ctrl-C (copy-text) &lt;br&gt;     Ctrl-K (kill) &lt;br&gt;     Ctrl-V (paste-text) &lt;br&gt;     Ctrl-X (cut-text) &lt;br&gt;     Ctrl-Y (yank) &lt;br&gt;     Alt-Y  (yank-pop) &lt;br&gt;     kill-... &lt;br&gt;  &lt;br&gt; Files:: &lt;br&gt;  &lt;br&gt;     Ctrl-N (new)  &lt;br&gt;     Ctrl-O (open-outline) &lt;br&gt;     Ctrl-S (save-file)  &lt;br&gt;     Ctrl-Q (exit-leo) &lt;br&gt;  &lt;br&gt; Focus:: &lt;br&gt;  &lt;br&gt;     Alt-T (focus-to-tree)  &lt;br&gt;     Ctrl-T (toggle-active-pane) &lt;br&gt;     Ctrl-Tab (tab-cycle-next) &lt;br&gt;      &lt;br&gt; Help:: &lt;br&gt;  &lt;br&gt;     Alt-0 (vr-toggle) &lt;br&gt;     F1 (help)  &lt;br&gt;     F11 (help-for-command)  &lt;br&gt;     F12 (help-for-python) &lt;br&gt;     print-bindings &lt;br&gt;     print-settings &lt;br&gt;     help-for-... &lt;br&gt;  &lt;br&gt; Find/Replace:: &lt;br&gt;  &lt;br&gt;     Ctrl-F (search-with-present-options)  &lt;br&gt;     Shift-Ctrl-R (replace-string) &lt;br&gt;     Ctrl-minus (replace-then-find)  &lt;br&gt;     F3 (find-next)  &lt;br&gt;     F2 (find-previous) &lt;br&gt;      &lt;br&gt; Minibuffer:: &lt;br&gt;  &lt;br&gt;     Alt-X (full-command) &lt;br&gt;     Ctrl-G (keyboard-quit) &lt;br&gt;     Tab (not a command, completes typing) &lt;br&gt;  &lt;br&gt; Nodes:: &lt;br&gt;  &lt;br&gt;     Ctrl-I or Insert (insert-node) &lt;br&gt;     Ctrl-H (edit-headline) &lt;br&gt;     &lt;Return&gt; (when editing a headline) (end-edit-headline) &lt;br&gt;     Ctrl-Shift-C (copy-node) &lt;br&gt;     Ctrl-Shift-X (cut-node)  &lt;br&gt;     Ctrl-Shift-V (paste-node)  &lt;br&gt;     Ctrl-{ (promote) &lt;br&gt;     Ctrl-} (demote) &lt;br&gt;     Ctrl-M (mark)  &lt;br&gt;  &lt;br&gt; Undo:: &lt;br&gt;  &lt;br&gt;     Ctrl-Z (undo) &lt;br&gt;     Ctrl-Shift-Z (redo) &lt;br&gt; " id="338" linkTypes="1" links="119" title="Frequently used commands" />
<node body="The **clone find** commands, cfa and cff,  move clones of all nodes matching the search pattern under a single **organizer node**, created as the last top-level node. **Flattened** searches put all nodes as direct children of the organizer node:: &lt;br&gt;  &lt;br&gt;     cfa     clone-find-all &lt;br&gt;     cff     clone-find-all-flattened &lt;br&gt;      &lt;br&gt; The **clone-marked** commands move clones of all marked nodes under an organizer node. Especially useful for gathering nodes by hand:: &lt;br&gt;  &lt;br&gt;     cfam    clone-find-marked  &lt;br&gt;     cffm    clone-find-flattened-marked &lt;br&gt; " id="339" linkTypes="1" links="119" title="Gathering find commands" />
<node body="Directives starting with '@ in the leftmost column &lt;br&gt;      &lt;br&gt; See the `Directives reference`_ for full details:: &lt;br&gt;  &lt;br&gt;     @                       # starts doc part &lt;br&gt;     @c                      # ends doc part &lt;br&gt;     @color &lt;br&gt;     @doc                    # starts doc part &lt;br&gt;     @killcolor &lt;br&gt;     @nocolor &lt;br&gt;     @language python &lt;br&gt;     @language c &lt;br&gt;     @language rest          # restructured text &lt;br&gt;     @language plain         # plain text: no syntax coloring. &lt;br&gt;     @lineending lineending &lt;br&gt;     @nosearch               # suppress searching for cff &amp; cfa commands. &lt;br&gt;     @pagewidth 100 &lt;br&gt;     @raw, @end_raw          # @file only. &lt;br&gt;     @tabwidth -4            # use spaces &lt;br&gt;     @tabwidth 8             # use tabs &lt;br&gt;     @nowrap &lt;br&gt;     @wrap &lt;br&gt;      &lt;br&gt; Leading whitespace is allowed (and significant) for:: &lt;br&gt;  &lt;br&gt;     @all &lt;br&gt;     @others &lt;br&gt;     " id="340" linkTypes="1" links="119" title="Leo directives" />
<node body="For documentation see node: &quot;About this file&quot; in leoSettings.leo:: &lt;br&gt;  &lt;br&gt;     Command history:    @history-list &lt;br&gt;     Key bindings:       @shortcuts &lt;br&gt;     Visual settings:    @data qt-gui-plugin-style-sheet &lt;br&gt;     Enabling plugins:   @enabled-plugins &lt;br&gt;  &lt;br&gt; To disable a binding for a key, bind it to do-nothing:: &lt;br&gt;  &lt;br&gt;     do-nothing = Insert &lt;br&gt;      &lt;br&gt; This overrides the following default binding in leoSettings.leo:: &lt;br&gt;  &lt;br&gt;     insert-node = Insert &lt;br&gt; " id="341" linkTypes="1" links="119" title="Settings" />
<node body="Supported by Leo's core:: &lt;br&gt;  &lt;br&gt;     @chapter &lt;br&gt;     @rst, @rst-no-head, @rst-ignore, @rst-ignore-tree &lt;br&gt;     @settings &lt;br&gt;     @test, @testsetup, @testclass &lt;br&gt;     @url &lt;br&gt;  &lt;br&gt; Within @settings trees:: &lt;br&gt;  &lt;br&gt;     @bool, @buttons, @color, @commands &lt;br&gt;     @directory, @encoding &lt;br&gt;     @enabled-plugins, @float, @font, &lt;br&gt;     @history-list, @int &lt;br&gt;     @menus, @menu, @menuat, @item &lt;br&gt;     @openwith, @path, @shortcuts, @string &lt;br&gt;  &lt;br&gt; Supported by plugins:: &lt;br&gt;  &lt;br&gt;     bookmarks.py:       @bookmarks, @bookmark &lt;br&gt;     at_folder.py:       @folder &lt;br&gt;     at_produce.py:      @produce &lt;br&gt;     at_view.py:         @clip, @strip, @view &lt;br&gt;     expfolder.py:       @expfolder &lt;br&gt;     mod_scripting.py:   @button, @command, @script &lt;br&gt;     viewrendered.py:    @graphics-script, @image &lt;br&gt;                         @html, @movie, @svg &lt;br&gt; " id="342" linkTypes="1" links="119" title="Node types" />
<node body="See the docstring of these plugins for more details:: &lt;br&gt;  &lt;br&gt;     bookmarks.py:       Manages URL's used as bookmarks. &lt;br&gt;     contextmenu.py:     Creates context menus for headlines. &lt;br&gt;     mod_scripting.py:   Supports @button and @command nodes. &lt;br&gt;     quicksearch.py:     Adds Nav tab for searching. &lt;br&gt;     todo.py:            To-do lists and simple project management. &lt;br&gt;     valuespace.py:      Creates an outline-oriented spreadsheet. &lt;br&gt;     viewrendered.py:    Creates a rendering pane. &lt;br&gt;                         Automatically loaded by Leo's help commands. &lt;br&gt;                         Supports @graphics-script, @image, @html, &lt;br&gt;                         @movie and @svg nodes. &lt;br&gt; " id="343" linkTypes="1" links="119" title="Notable Plugins" />
<node body=".. From cheat sheet &lt;br&gt;  &lt;br&gt; \@&lt;file&gt; nodes create external files:: &lt;br&gt;  &lt;br&gt;     @asis &lt;filename&gt;        write only, no sentinels, exact line endings &lt;br&gt;     @auto &lt;filename&gt;        recommended &lt;br&gt;     @clean &lt;filename&gt;       recommended &lt;br&gt;     @edit &lt;filename&gt;        @edit node contains entire file &lt;br&gt;     @file &lt;filename&gt;        recommended &lt;br&gt;     @nosent &lt;filename&gt;      write only, no sentinels &lt;br&gt;      &lt;br&gt; This table summarizes the differences between @&lt;file&gt; nodes:: &lt;br&gt;  &lt;br&gt;                              Sections &amp;   File data in &lt;br&gt;     @&lt;file&gt; kind  Sentinels?  @others?    .leo file?    Notes              &lt;br&gt;     ------------  ---------- -----------  ------------  ----- &lt;br&gt;     @asis          no          no          yes &lt;br&gt;     @auto          no          yes         no           1, 2 &lt;br&gt;     @auto-xx       no          yes         no           1, 2 &lt;br&gt;     @clean         no          yes         yes      &lt;br&gt;     @edit          no          no          no     &lt;br&gt;     @file          yes         yes         no &lt;br&gt;     @nosent        no          yes         yes &lt;br&gt;      &lt;br&gt; \@auto nodes read files using language-specific importers. &lt;br&gt; By default, the file's extension determines the importer:: &lt;br&gt;  &lt;br&gt;     Extensions                  Importer &lt;br&gt;     ----------                  -------- &lt;br&gt;     .c, .cc, .c++, .cpp,.cxx    C &lt;br&gt;     .cs', .c#'                  C Sharp &lt;br&gt;     .el                         Elisp &lt;br&gt;     .h, .h++                    C &lt;br&gt;     .html, .htm                 HTML &lt;br&gt;     .ini                        Config file &lt;br&gt;     .ipynb                      Jupyter notebook &lt;br&gt;     .java                       Java &lt;br&gt;     .js                         JavaScript &lt;br&gt;     .md                         Markdown &lt;br&gt;     .org                        Org Mode &lt;br&gt;     .otl                        Vim outline &lt;br&gt;     .pas                        Pascal &lt;br&gt;     .php                        PHP &lt;br&gt;     .py, .pyi, .pyw             Python &lt;br&gt;     .rest, .rst                 reStructuredText &lt;br&gt;     .ts                         TypeScript &lt;br&gt;     .xml                        XML &lt;br&gt;      &lt;br&gt; You can also specify importers *explicitly* as follows:: &lt;br&gt;  &lt;br&gt;     @auto-xxx           Importer &lt;br&gt;     ---------           -------- &lt;br&gt;     @auto-ctext         ctext &lt;br&gt;     @auto-markdown      markdown &lt;br&gt;     @auto-md            markdown &lt;br&gt;     @auto-org           org-mode &lt;br&gt;     @auto-org-mode      org-mode &lt;br&gt;     @auto-otl           vimoutline &lt;br&gt;     @auto-vim-outline   vimoutline &lt;br&gt;     @auto-rst           reStructuredText &lt;br&gt;      &lt;br&gt; **Important**: The importers/exporters for markdown, org-mode, reStructuredText and vimoutline files automatically generate section headings corresponding to Leo's outline level. Body text of the top-level @auto node is ignored. &lt;br&gt;      &lt;br&gt; See the `Directives reference`_ for full details. &lt;br&gt;      &lt;br&gt; " id="344" linkTypes="1" links="119" title="External files (@&lt;file&gt; nodes)" />
<node body="**Section names** have the form:: &lt;br&gt;  &lt;br&gt;     &lt;&lt; any text, except double closing angle brackets &gt;&gt; &lt;br&gt;      &lt;br&gt; **Section-definition nodes** have headlines starting with a section name. &lt;br&gt;  &lt;br&gt; Leo performs **expansions** for all @&lt;file&gt; nodes except @asis. &lt;br&gt;  &lt;br&gt; Expansion of @all: &lt;br&gt;  &lt;br&gt; - Leo replaces @all by the *unexpanded* body text of *all* nodes. &lt;br&gt;  &lt;br&gt; Expansion of section names and @others: &lt;br&gt;  &lt;br&gt; - Leo replaces section names in body text by the *expanded* &lt;br&gt;   text of the corresponding section definition node. &lt;br&gt;    &lt;br&gt; - Leo replaces @others with the *expanded* text of all nodes &lt;br&gt;   that *aren't* section-definition nodes. &lt;br&gt; " id="345" linkTypes="1" links="119" title="Sections" />
<node body="This section lists the ivars, properties, functions and methods most commonly used in Leo scripts. &lt;br&gt;  &lt;br&gt; **Very important**: use Alt-1 (toggle-autocompleter) and Alt-2 (toggle-calltips) to recreate these lists as you type. &lt;br&gt; " id="346" linkTypes="3 3 3 3 3 3" links="762 763 764 765 766 767" title="Scripting" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Usage: launchLeo.py [options] file1, file2, ... &lt;br&gt;      &lt;br&gt;     Options: &lt;br&gt;       -h, --help            show this help message and exit &lt;br&gt;       --debug               enable debug mode &lt;br&gt;       --diff                use Leo as an external git diff &lt;br&gt;       --fullscreen          start fullscreen &lt;br&gt;       --ipython             enable ipython support &lt;br&gt;       --gui=GUI             gui to use (qt/qttabs) &lt;br&gt;       --maximized           start maximized &lt;br&gt;       --minimized           start minimized &lt;br&gt;       --no-cache            disable reading of cached files &lt;br&gt;       --no-plugins          disable all plugins &lt;br&gt;       --no-splash           disable the splash screen &lt;br&gt;       --screen-shot=SCREENSHOT_FN &lt;br&gt;                             take a screen shot and then exit &lt;br&gt;       --script=SCRIPT       execute a script and then exit &lt;br&gt;       --script-window=SCRIPT_WINDOW &lt;br&gt;                             open a window for scripts &lt;br&gt;       --select=SELECT       headline or gnx of node to select &lt;br&gt;       --session-restore     restore previously saved session tabs at startup &lt;br&gt;       --session-save        save session tabs on exit &lt;br&gt;       --silent              disable all log messages &lt;br&gt;       --trace-plugins       trace imports of plugins &lt;br&gt;       -v, --version         print version number and exit &lt;br&gt;       --window-size=WINDOW_SIZE &lt;br&gt;                             initial window size (height x width) &lt;br&gt;     " id="347" linkTypes="1" links="119" title="Command-line options" />
<node body="Leo grew out of my efforts to use Donald Knuth's &quot;CWEB system of Structured documentation.&quot; I had known of literate programming since the mid 1980's, but I never understood how to make it work for me. In November 1995 I started thinking about programming in earnest. Over the holidays I mused about making programs more understandable. " id="348" linkTypes="1" links="120" title="1995: Beginnings" />
<node body="In January 1996 the fog of confusion suddenly cleared. I summarized my thinking with the phrase, **web are outlines in disguise**. I suspected that outline views were the key to programming, but many details remained obscure. &lt;br&gt;  &lt;br&gt; March 5, 1996, is the most important date in Leo's history. While returning from a day of skiing, I discussed my thoughts with Rebecca. During that conversation I realized that I could use the MORE outliner as a prototype for a &quot;programming outliner.&quot; I immediately started work on my first outlined program. It quickly became apparent that outlines work: all my old problems with programming vanished. The @others directive dates from this day. I realized that MORE's outlines could form the basis for Leo's screen design. Rather than opening body text within the outline, as MORE does, I decided to use a separate body pane. &lt;br&gt;  &lt;br&gt; I hacked a translator called M2C which allowed me to use MORE to write real code. I would write code in MORE, copy the text to the clipboard in MORE format, then run M2C, which would convert the outline into C code. This process was useful, if clumsy. I called the language used in the outline SWEB, for simplified CWEB. Much later Leo started supporting the noweb language. &lt;br&gt; " id="349" linkTypes="1" links="120" title="1996: Breakthroughs" />
<node body="Throughout 1996 I created a version of Leo on the Macintosh in plain C and the native Mac Toolbox. This was a poor choice; I wasted a huge amount of time programming with these primitive tools. However, this effort convinced me that Leo was a great way to program. &lt;br&gt;  &lt;br&gt; Late in 1997 I wrote a Print command to typeset an outline. Printing (Weaving) is supposedly a key feature of literate programming. Imagine my surprise when I realized that such a &quot;beautiful&quot; program listing was almost unintelligible; all the structure inherent in the outline was lost! I saw clearly that typesetting, no matter how well done, is no substitute for explicit structure. &lt;br&gt;  &lt;br&gt; In 1998 I created a version of Leo using Apple's YellowBox environment. Alas, Apple broke its promises to Apple developers. I had to start again. &lt;br&gt; " id="350" linkTypes="1" links="120" title="1996-1998: Apple and YellowBox" />
<node body="In May of 1999 I began work on the Borland version of Leo for Windows. Borland C++ was much better than CodeWarrior C, but it was still C++. Still, the Borland Delphi classes were a pleasure to use and free of bugs. I redesigned Leo's file format for the Windows version of Leo; the Yellow Box file format was a binary format that requires the Yellow Box runtime. &lt;br&gt;  &lt;br&gt; There are two significant problems with the Borland version of Leo. First, it works only on Windows. Second, it can never be Open software, because it uses Borland's Delphi classes and a commercial syntax coloring component. &lt;br&gt;  &lt;br&gt; This version of Leo was the first version to use xml as the format of .leo files. Marc-Antoine Parent urged me to use XML and patiently explained how to use XML properly. " id="351" linkTypes="1" links="120" title="1999-2001: Borland C++" />
<node body="I attended the Python conference in early 2001. In May of 2000 I began work on an wxWindows version of Leo. This did not work out, but something good did come from this effort. I spent a lot of time adding Python scripting to the wxWindows code and I became familiar with Python and its internals. &lt;br&gt;  &lt;br&gt; I really started to 'get' Python in September 2001. I wrote the white papers at about this time. Python solved *all* my programming problems. I rewrote Leo in Python in about two months! For the first time in my career I was no longer anxious while programming; it simply isn't possible to create bad bugs in Python. The Python version of Leo was the first officially OpenSoftware version of Leo. The first functional version of Leo in Python was 0.05 alpha, December 17, 2001. &lt;br&gt;  &lt;br&gt; In October of 2001 I began work on the leo.py, an Open Software version of leo.py, a version of Leo written in Python and Tk.  At last I have found the proper platform for Leo.  leo.py naturally supports scripting in Python.  The combination of Python and Tk is incredibly powerful, very easy to use, and truly cross platform.  I rewrote Leo in Python in about two months!  For the first time in my career I no longer am anxious while programming; it simply isn't possible to create bad bugs in Python. &lt;br&gt;  &lt;br&gt; Tk was officially retired in June 2011. &lt;br&gt; " id="352" linkTypes="1" links="120" title="2001: Discovering Python" />
<node body="In the summer of 2001 I began to consider using sentinel lines in external files. Previously I had thought that outline structure must be 'protected' by remaining inside .leo files. Accepting the possibility that sentinels might be corrupted opened vast new design possibilities. In retrospect, problems with sentinels almost never happen, but that wasn't obvious at the time! The result of this design was known then as Leo2. That terminology is extinct. I think of this version as the first version to support @file and automatic tangling and untangling. &lt;br&gt;  &lt;br&gt; " id="353" linkTypes="3 3 3 3 3 3 3 3 3 3" links="768 769 770 771 772 773 774 775 776 777" title="2001: Putting sentinel lines in external files" />
<node body="The biggest surprise in Leo's history was the realization it is **much** easier to untangle files derived from @file. Indeed, the old tangle code created all sorts of problems that just disappear when using @file. The new Python version of Leo became fully operational in early 2002. It was probably about this time that I chose noweb as Leo's preferred markup language. My decision not to support noweb's escape sequences made Leo's read code much more robust. &lt;br&gt; " id="354" linkTypes="1" links="120" title="2002: Untangling @file is easy!" />
<node body="I spent 2002 taking advantages of Python's tremendous power and safety. Many improvements were at last easy enough to do: &lt;br&gt;  &lt;br&gt; - Nested @others directives appeared in 3.2. &lt;br&gt; - Unicode support started in 3.3. &lt;br&gt; - @first and @last appeared in 3.7 &lt;br&gt; - @asis and @nosent appeared in 3.8. &lt;br&gt; - Incremental syntax coloring and incremental undo appeared in 3.9. &lt;br&gt; - Paul Paterson created Leo's plugin architecture sometime during this period. &lt;br&gt; - 3.12 fixed a huge memory leak. &lt;br&gt; - 3.12 Final, the last 3.x version, appeared July 17, 2003. &lt;br&gt; " id="355" linkTypes="1" links="120" title="2002: Leo 3.x: Continuous improvement" />
<node body="I registered the Leo project on SourceForge on March 10, 2003. Leo started a new life shortly thereafter. Prior to SourceForge my interest in Leo had been waning. &lt;br&gt; " id="356" linkTypes="1" links="120" title="2003: SourceForge: new energy" />
<node body="In late 2002 and throughout 2003 I worked on an entirely new file format. 4.0 final went out the door October 17, 2003. &lt;br&gt;  &lt;br&gt; Version 4.0 is a major advance in Leo's error handling. Using 4.0 is much safer than all previous versions. The new read code makes no changes to the outline until it is known that no read errors have occurred. &lt;br&gt;  &lt;br&gt; This was a time of intense design work trying to improve error recovery scheme used while reading external files. In the summer of 2003 I realized that orphan and @ignore'd nodes must be prohibited in @file trees. With this restriction, Leo could finally recreate @file trees in outlines using **only** the information in external files. This made the read code much more robust, and eliminated all the previous unworkable error recovery schemes. At last Leo was on a completely firm foundation. &lt;br&gt;  &lt;br&gt; Leo's read code now writes a message to the log pane whenever it sees that the body text in the external file does not match the body text in the outline. These messages do not indicate errors, only that the body text has been changed outside of Leo. &lt;br&gt;  &lt;br&gt; Leo's read code now warns if any non-empty node is unvisited. This check, and the check that headlines match pretty much guarantees that out-of-sync outlines will generate errors. Thus, there is no need a gnx timestamp in @+leo sentinels! &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     - Added support for uA's &lt;br&gt;     - Eliminated child indices, extraneous blank lines and @body sentinels &lt;br&gt;     - Eliminated @node sentinels &lt;br&gt;     - New @nl and @nonl sentinels &lt;br&gt;     - Read errors leave the outline completely unchanged &lt;br&gt; " id="357" linkTypes="1" links="120" title="2003: 4.0: New read logic eliminates read errors, eliminated child indices" />
<node body="Leo 4.1 Final went out the door February 20, 2004. This release reorganized the code base to support gui's other than tkinter. &lt;br&gt;  &lt;br&gt; Leo first used gnx's (global node indices) as a foolproof way of associating nodes in .leo files with nodes in external files. At the time, there was still intense discussions about protecting the logical consistency of outlines. @thin was later to solve all those problems, but nobody knew that then. &lt;br&gt; " id="358" linkTypes="1" links="120" title="2004: 4.1: The debut of gnx's" />
<node body="Leo 4.2 Final was released September 20, 2004.  This is one of the most significant dates in Leo's history. There were so many significant changes that it is hard to remember what Leo was like before it. &lt;br&gt;  &lt;br&gt; Leo 4.2 eliminated worries about consistency of outlines and external files: Leo recreates all essential information from @thin files, so *there is nothing left in the .leo file to get out of sync*. Thin external files use gnx's extensively. This simplifies the file format and makes thin external files more cvs friendly. &lt;br&gt;    &lt;br&gt; Leo 4.2 forms the **great divide** in Leo's internal data structures. Before 4.2, Leo every node in the outline had its own vnode. This was a big performance problem: clone operations had to traverse the entire outline! 4.2 represents clones by sharing subtrees. Kent Tenney and Bernhard Mulder made absolutely crucial contributions. Kent pointed out that it is a tnode, not a vnode that must form the root of the shared data. Bernhard showed that iterators avoid creating huge numbers of positions. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     The debut of @all, @test and @suite &lt;br&gt;     The mod_scripting plugin creates script buttons &lt;br&gt;     A much faster and more robust spell checker plugin &lt;br&gt;     Leo saves t.unknownAttributes in the root nodes of @thin trees &lt;br&gt;     New iterators" id="359" linkTypes="1" links="120" title="2004: 4.2: generators, uA's the end of sync problems, shared tnodes" />
<node body="Leo 4.3 final was released May 23, 2005.  This release introduced settings files. These files replaced config.txt and made settings completely extensible and flexible. This release also introduced the ill-fated settings pane. It was soon retired because it inhibited development. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Leo stores recent files in .leoRecentFiles.txt files &lt;br&gt;     Added PluginsManager plugin &lt;br&gt;     Support for extensions in the leo/extensions directory &lt;br&gt;     Leo predefines c, g and p in scripts and @test nodes &lt;br&gt;      &lt;br&gt; Leo 4.3.3 final went out the door September 17, 2005.  It added the rst3 plugin. &lt;br&gt;  &lt;br&gt; " id="360" linkTypes="1" links="120" title="2005: 4.3: @settings trees, plugins manager, predefined c, g, p" />
<node body="Leo 4.4 Final was released May 11, 2006.  It completed a year-long effort to incorporate an Emacs-style minibuffer and related commands into Leo. Leo 4.4 also featured many improvements in how keys are bound to commands, including per-pane bindings and user-defined key-binding modes. These features allow users to emulate Emacs, Vim, or any other editor. They also make it easy to use Leo without a mouse. &lt;br&gt;  &lt;br&gt; This release created many Emacs-like commands, including cursor and screen movement, basic character, word and paragraph manipulation, and commands to manipulate buffers, the kill ring, regions and rectangles. Much of the work started with a prototype by LeoUser (B.H). &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     A tabbed log pane &lt;br&gt;     Autocompletion and calltips &lt;br&gt;     @mode nodes &lt;br&gt;     The **New World Order**: drawing happens immediately, not at idle time &lt;br&gt;     The **Newer World Order**: c.endUpdate is equivalent to c.redraw_now &lt;br&gt;  &lt;br&gt; Development on long-delayed projects accelerated after 4.4 final went out the door:: &lt;br&gt;  &lt;br&gt;     Syntax coloring controlled using jEdit's xml language-description files &lt;br&gt;     Support for debugging scripts using external debuggers &lt;br&gt;     Leo's vnodes and tnodes can support ZODB &lt;br&gt;     Using pymacs to write Leo scripts within Emacs &lt;br&gt;     Added the leoBridge module &lt;br&gt; " id="361" linkTypes="1" links="120" title="2006: 4.4: The minibuffer, key bindings autocompletion, multiple log panes" />
<node body="This series of releases featured hundreds of improvements. &lt;br&gt; " id="362" linkTypes="3 3 3 3 3 3 3 3" links="778 779 780 781 782 783 784 785" title="2006-2008: 4.4.x: Hundreds of improvements" />
<node body="Leo 4.5 final was released September 2, 2008. Leo's drawing and focus code was substantially simplified, removing all calls to c.beginUpdate and c.endUpdate. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Full support for @shadow files in Leo's core &lt;br&gt;     Major improvements to Leo's key binding code &amp; usable vim-like bindings &lt;br&gt;     uA's may now be associated with vnodes in @thin and @shadow files &lt;br&gt;     Leo now always uses sax to read .leo files &lt;br&gt; " id="363" linkTypes="1" links="120" title="2008: 4.5: Code reorg, @shadow, vim bindings" />
<node body="Leo 4.6 final was released July 15, 2009.  The big feature was caching of external files, a feature suggested by Ville M. Vainio.  Caching *greatly* reduces the time to load .leo files. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Leo used Qt interface by default. &lt;br&gt;     Leo tests syntax of .py files when saving them &lt;br&gt;     Added @auto-rst and @edit &lt;br&gt;     Added Properties of commanders, positions and vnodes &lt;br&gt;     Leo warns on dangerous writes to @thin and @file nodes &lt;br&gt; " id="364" linkTypes="1" links="120" title="2009: 4.6: Caching, Qt gui, @edit, @auto-rst" />
<node body="Leo 4.7 final was released February 23, 2010. Leo 4.7.1 final fixed a serious bug in Leo 4.7.  It went out the door just days later, on February 26, 2010. &lt;br&gt;  &lt;br&gt; Leo 4.7 accomplishes something I long thought to be impossible: the unification of vnodes and tnodes. tnodes no longer exist: vnodes contain all data. The Aha that made this possible is that iterators and positions allow a single node to appear in more than one place in a tree traversal. &lt;br&gt;  &lt;br&gt; This was one of the most significant developments in Leo's history. At last the endless confusion between vnodes and tnodes is gone. At the most fundamental level, Leo's data structures are as simple as possible. This makes them as general and as powerful as possible! &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     A single code base runs on both Python 2 and 3 &lt;br&gt;     Automatically converts from old-style to new-style sentinels &lt;br&gt;     Added a new Windows installer &lt;br&gt;  &lt;br&gt; Leo 4.7.1 fixed dangerous bug in Leo 4.7. The problem arose because it was too easy to save the .leo file (thus deleting the tnodeList) without forcing the converted external files to be saved. The next time Leo attempted to read the external files, the tnodeList would be missing and data would be lost. &lt;br&gt; " id="365" linkTypes="1" links="120" title="2010: 4.7: The one node world &amp; Python 3k" />
<node body="Leo 4.8 final was released November 26, 2010. This release simplified Leo's sentinels as much as possible. This version also added &quot;Resurrected&quot; and &quot;Recovered&quot; nodes. These nodes protect against data loss, and also implicitly warn when unusual data-changing events occur. Creating this scheme may be the final chapter in the epic saga of error recovery in Leo. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Added Drag and Drop of outlines &lt;br&gt;     Defined abbreviations in Leo settings nodes &lt;br&gt;     Leo now uses PyEnchant to check spelling &lt;br&gt;     Deprecated the ancient Tangle and Untangle commands &lt;br&gt; " id="366" linkTypes="1" links="120" title="2010: 4.8: New sentinels &amp; recovery nodes" />
<node body="Leo 4.9 final was released June 21, 2011.  This release completely switches over to Qt. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Completed the Autocompleter &lt;br&gt;     The rendering pane can now display movies, html, svg images, etc. &lt;br&gt;     Nodes may contain multiple @language directives &lt;br&gt;     Leo highlights URL's everywhere &lt;br&gt;     Ctrl-click URL's opens them in your web browser &lt;br&gt;     Added unified extract and import commands &lt;br&gt; " id="367" linkTypes="1" links="120" title="2011: 4.9: The end of Tk, autocompleter, vr pane" />
<node body="Leo 4.10 final was released March 29, 2012. It contained a huge number of improvements and bug fixes:: &lt;br&gt;  &lt;br&gt;   Tab completion now shows all @command &amp; @button nodes &lt;br&gt;   Leo tabs may be detached from the main window &lt;br&gt;   The bigdash plugin searches across multiple files &lt;br&gt;   Much improved abbreviations using @data nodes &lt;br&gt;   Improved handling of URL's &lt;br&gt;   Detachable windows &lt;br&gt;   Improved Leo's home page &lt;br&gt;   Easier installation on MacOS &lt;br&gt; " id="368" linkTypes="1" links="120" title="2012: 4.10: Many improvements" />
<node body="Leo 4.11 final was released November 6, 2013. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Clones are now valid anywhere in @file nodes &lt;br&gt;     A colored border highlights the pane with focus &lt;br&gt;     Added support for sessions &lt;br&gt;     By Terry Brown: &lt;br&gt;         Added templates to abbreviations &lt;br&gt;         Leo warns if a .leo file is open elsewhere &lt;br&gt;         Added colorizing themes &lt;br&gt;  &lt;br&gt; Leo 4.11.1 final was released December 20, 2013. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     @data qt-gui-user-style-sheet overrides @data qt-gui-plugin-style-sheet &lt;br&gt;     Rewrote and simplified Leo's tutorials &lt;br&gt;     A colored border highlights the pane with focus &lt;br&gt; " id="369" linkTypes="1" links="120" title="2013: 4.11: More improvements" />
<node body="Leo 5.0 final was released November 24, 2014. During this time, Leo's video tutorials made their debut.  These tutorials helped a lot of people learn Leo. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Added leo/core/leoVim.py: full emulation of vim &lt;br&gt;     Added support for Emacs org-mode outlines &lt;br&gt;     Added the pylint command &lt;br&gt;     Added support for PyQt5 &lt;br&gt;     Syntax coloring happens at idle time &lt;br&gt;     Cloned nodes expand and contract independently &lt;br&gt;     Added a pluggable architecture for @auto nodes &lt;br&gt;     Leo's default workbook files contains Leo's quickstart guide &lt;br&gt;      &lt;br&gt; Leo now stores &quot;ephemeral&quot; or position-related data *in vnodes*. This was a completely new idea in Leo's history! &lt;br&gt; " id="370" linkTypes="1" links="120" title="2014: 5.0 Vim mode, plays well with others" />
<node body="Leo 5.1 b1 was released March 20, 2015.  This release features @clean, one of the most important developments in Leo's history. The Mulder/Ream update algorithm puts @clean on a completely sound footing. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;    &lt;br&gt;   http://leoeditor.com/load-leo.html displays .leo files in the browser &lt;br&gt;   Added the LeoQtGui.IdleTime class and the g.IdleTime wrapper &lt;br&gt;   Leo now honors @language inside @doc parts &lt;br&gt;   @shadow is deprecated &lt;br&gt; " id="371" linkTypes="3 3 3" links="786 787 788" title="2015: 5.1 @clean" />
<node body=".. _`Writing plugins`:   writingPlugins.html &lt;br&gt;  &lt;br&gt; Here are the XML elements that may appear in Leo files: &lt;br&gt;  &lt;br&gt; &lt;?xml&gt; &lt;br&gt;     Leo files start with the following line:: &lt;br&gt;  &lt;br&gt;         &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;br&gt;  &lt;br&gt; &lt;?xml-stylesheet&gt; &lt;br&gt;     An xml-stylesheet line is option.  For example:: &lt;br&gt;  &lt;br&gt;         &lt;?xml-stylesheet ekr_stylesheet?&gt; &lt;br&gt;  &lt;br&gt; &lt;leo_file&gt; &lt;br&gt;     The &lt;leo_file&gt; element opens an element that contains the entire file. &lt;br&gt;     &lt;/leo_file&gt; ends the file. &lt;br&gt;  &lt;br&gt; &lt;leo_header&gt;  &lt;br&gt;     The &lt;leo_header&gt; element specifies version information and other information &lt;br&gt;     that affects how Leo parses the file.  For example:: &lt;br&gt;  &lt;br&gt;         &lt;leo_header file_format=&quot;2&quot; tnodes=&quot;0&quot; max_tnode_index=&quot;5725&quot; clone_windows=&quot;0&quot;/&gt; &lt;br&gt;  &lt;br&gt;     The file_format attribute gives the 'major' format number. &lt;br&gt;     It is '2' for all 4.x versions of Leo. &lt;br&gt;     The tnodes and clone_windows attributes are no longer used. &lt;br&gt;     The max_tnode_index	attribute is the largest tnode index. &lt;br&gt;  &lt;br&gt; &lt;globals&gt; &lt;br&gt;     The globals element specifies information relating to the entire file. &lt;br&gt;     For example:: &lt;br&gt;  &lt;br&gt;         &lt;globals body_outline_ratio=&quot;0.50&quot;&gt; &lt;br&gt;             &lt;global_window_position top=&quot;27&quot; left=&quot;27&quot; height=&quot;472&quot; width=&quot;571&quot;/&gt; &lt;br&gt;             &lt;global_log_window_position top=&quot;183&quot; left=&quot;446&quot; height=&quot;397&quot; width=&quot;534&quot;/&gt; &lt;br&gt;         &lt;/globals&gt; &lt;br&gt;  &lt;br&gt;     -   The body_outline_ratio attribute specifies the ratio of the height of the body pane to &lt;br&gt;         the total height of the Leo window. &lt;br&gt;         It initializes the position of the splitter separating the outline pane from the body pane. &lt;br&gt;  &lt;br&gt;     -   The global_window_position and global_log_window_position elements &lt;br&gt;         specify the position of the Leo window and Log window in global coordinates: &lt;br&gt;  &lt;br&gt; &lt;preferences&gt; &lt;br&gt;     This element is vestigial. &lt;br&gt;     Leo ignores the &lt;preferences&gt; element when reading. &lt;br&gt;     Leo writes an empty &lt;preferences&gt; element. &lt;br&gt;  &lt;br&gt; &lt;find_panel_settings&gt; &lt;br&gt;     This element is vestigial. &lt;br&gt;     Leo ignores the &lt;find_panel_settings&gt; element when reading. &lt;br&gt;     Leo writes an empty &lt;find_panel_settings&gt; element. &lt;br&gt;  &lt;br&gt; &lt;clone_windows&gt; &lt;br&gt;     This element is vestigial. &lt;br&gt;     Leo ignores the &lt;clone_windows&gt; element when reading. &lt;br&gt;     Leo no longer writes &lt;clone_windows&gt; elements. &lt;br&gt;  &lt;br&gt; &lt;vnodes&gt; &lt;br&gt;     A single &lt;vnodes&gt; element contains nested &lt;v&gt; elements. &lt;br&gt;     &lt;v&gt; elements correspond to vnodes. &lt;br&gt;     The nesting of &lt;v&gt; elements indicates outline structure in the obvious way. &lt;br&gt;  &lt;br&gt; &lt;v&gt; &lt;br&gt;     The &lt;v&gt; element represents a single vnode and has the following form:: &lt;br&gt;  &lt;br&gt;         &lt;v...&gt;&lt;vh&gt;sss&lt;/vh&gt; (zero or more nested v elements) &lt;/v&gt; &lt;br&gt;  &lt;br&gt;     The &lt;vh&gt; element specifies the headline text. &lt;br&gt;     sss is the headline text encoded with the usual XML escapes. &lt;br&gt;     As shown above, a &lt;v&gt; element may contain nested &lt;v&gt; elements. &lt;br&gt;     This nesting indicates outline structure in the obvious way. &lt;br&gt;     Zero or more of the following attributes may appear in &lt;v&gt; elements:: &lt;br&gt;  &lt;br&gt;         t=name.timestamp.n &lt;br&gt;         a=&quot;xxx&quot; &lt;br&gt;  &lt;br&gt;     The t=&quot;Tnnn&quot; attribute specifies the &lt;t&gt; element associated with a &lt;v&gt; element. &lt;br&gt;     The a=&quot;xxx&quot; attribute specifies vnode attributes. &lt;br&gt;     The xxx denotes one or more upper-case letters whose meanings are as follows:: &lt;br&gt;  &lt;br&gt;         C	The vnode is a clone. (Not used in 4.x) &lt;br&gt;         E	The vnode is expanded so its children are visible. &lt;br&gt;         M	The vnode is marked. &lt;br&gt;         T	The vnode is the top visible node. &lt;br&gt;         V	The vnode is the current vnode. &lt;br&gt;  &lt;br&gt;     For example, a=&quot;EM&quot;  specifies that the vnode is expanded and is marked. &lt;br&gt;  &lt;br&gt;     **New in 4.0**: &lt;br&gt;  &lt;br&gt;     -   &lt;v&gt; elements corresponding to @file nodes now contain tnodeList attributes. &lt;br&gt;         The tnodeList attribute allows Leo to recreate the order in which nodes should  &lt;br&gt;         appear in the outline. &lt;br&gt;         The tnodeList attribute is a list of gnx's: global node indices. &lt;br&gt;         See Format of external files (4.x) for the format of gnx's. &lt;br&gt;  &lt;br&gt;     -   Plugins and scripts may add attributes to &lt;v&gt; and &lt;t&gt; elements. &lt;br&gt;         See `Writing plugins`_ for details. &lt;br&gt;  &lt;br&gt; &lt;tnodes&gt; &lt;br&gt;     A single &lt;tnodes&gt; element contains a non-nested list of &lt;t&gt; elements. &lt;br&gt;  &lt;br&gt; &lt;t&gt; &lt;br&gt;     The &lt;t&gt; element represents the body text of the corresponding &lt;v&gt; element. &lt;br&gt;     It has this form:: &lt;br&gt;  &lt;br&gt;         &lt;t tx=&quot;&lt;gnx&gt;&quot;&gt;sss&lt;/t&gt; &lt;br&gt;  &lt;br&gt;     The tx attribute is required. &lt;br&gt;     The t attribute of &lt;v&gt; elements refer to this tx attribute. &lt;br&gt;     sss is the body text encoded with the usual XML escapes. &lt;br&gt;  &lt;br&gt;     **New in 4.0**: Plugins and scripts may add attributes to &lt;v&gt; and &lt;t&gt; &lt;br&gt;     elements. See `Writing plugins`_ for details. &lt;br&gt; " id="372" linkTypes="1" links="121" title="Format of .leo files" />
<node body=".. _`sentinel lines`: glossary.html#sentinel-lines &lt;br&gt;  &lt;br&gt; This section describe the format of external files. Leo's `sentinel lines`_ are comments, and this section describes those comments. &lt;br&gt;  &lt;br&gt; .. index:: gnx &lt;br&gt;  &lt;br&gt; External files created by @file use gnx's in @+node sentinels. Such gnx's permanently and uniquely identify nodes. Gnx's have the form:: &lt;br&gt;  &lt;br&gt;     id.yyyymmddhhmmss &lt;br&gt;     id.yyyymmddhhmmss.n &lt;br&gt;  &lt;br&gt; The second form is used if two gnx's would otherwise be identical. &lt;br&gt;  &lt;br&gt; - id is a string unique to a developer, e.g., a git id. &lt;br&gt;  &lt;br&gt; - yyyymmddhhmmss is the node's creation date. &lt;br&gt;  &lt;br&gt; - n is an integer. &lt;br&gt;  &lt;br&gt; Closing sentinels are required for section references and the @all and @others directives, collectively known as **embedding constructs.** Proof: These constructs do not terminate the node in which they appear. Without a closing sentinel there would be no way to know where the construct ended and the following lines of the enclosing node began. &lt;br&gt;  &lt;br&gt; New sentinels do not include @nonl or @nl. As a result, body text always ends with at least one newline. &lt;br&gt;  &lt;br&gt; Here are the sentinels used by Leo, in alphabetical order. Unless otherwise noted, the documentation applies to all versions of Leo. In the following discussion, gnx denotes a gnx as described above. &lt;br&gt;  &lt;br&gt; \@&lt;&lt; &lt;br&gt;     A sentinel of the form @&lt;&lt;section_name&gt;&gt; represents a section reference. &lt;br&gt;  &lt;br&gt;     If the reference does not end the line, the sentinel line ending &lt;br&gt;     the expansion is followed by the remainder of the reference line. &lt;br&gt;     This allows the Read code to recreate the reference line exactly. &lt;br&gt;  &lt;br&gt; \@@ &lt;br&gt;     The @@ sentinel represents any line starting with @ in body text &lt;br&gt;     except @*whitespace*, @doc and @others. &lt;br&gt;     Examples:: &lt;br&gt;  &lt;br&gt;       @@nocolor &lt;br&gt;       @@pagewidth 80 &lt;br&gt;       @@tabwidth 4 &lt;br&gt;       @@code &lt;br&gt;  &lt;br&gt; \@afterref &lt;br&gt;     Marks non-whitespace text appearing after a section references. &lt;br&gt;  &lt;br&gt; \@+all &lt;br&gt;     Marks the start of text generated by the @all directive. &lt;br&gt;  &lt;br&gt; \@-all &lt;br&gt;     Marks the end of text generated by the @all directive. &lt;br&gt;  &lt;br&gt; \@at and @doc &lt;br&gt;  &lt;br&gt;     The @+doc @+at sentinels indicate the start of a doc parts. &lt;br&gt;  &lt;br&gt;     We use the following **trailing whitespace convention** to &lt;br&gt;     determine where putDocPart has inserted line breaks:: &lt;br&gt;  &lt;br&gt;         A line in a doc part is followed by an inserted newline &lt;br&gt;         if and only if the newline if preceded by whitespace. &lt;br&gt;  &lt;br&gt;     To make this convention work, Leo's write code deletes the trailing &lt;br&gt;     whitespace of all lines that are followed by a &quot;real&quot; newline. &lt;br&gt;  &lt;br&gt; \@+body **(Leo 3.x only)** &lt;br&gt;     Marks the start of body text. &lt;br&gt;  &lt;br&gt; \@-body **(Leo 3.x only)** &lt;br&gt;     Marks the end of body text. &lt;br&gt;  &lt;br&gt; \@delims &lt;br&gt;     The @delims directive inserts @@delims sentinels into the &lt;br&gt;     external file. The new delimiter strings continue in effect until &lt;br&gt;     the next @@delims sentinel *in the external file* or until the &lt;br&gt;     end of the external file. Adding, deleting or changing @@delim &lt;br&gt;     *sentinels* will destroy Leo's ability to read the external file. &lt;br&gt;     Mistakes in using the @delims *directives* have no effect on Leo, &lt;br&gt;     though such mistakes will thoroughly mess up a external file as &lt;br&gt;     far as compilers, HTML renderers, etc. are concerned. &lt;br&gt;  &lt;br&gt; \@+leo &lt;br&gt;     Marks the start of any external file. This sentinel has the form:: &lt;br&gt;  &lt;br&gt;         &lt;opening_delim&gt;@leo&lt;closing_delim&gt; &lt;br&gt;  &lt;br&gt;     The read code uses single-line comments if &lt;closing_delim&gt; is empty. &lt;br&gt;     The write code generates single-line comments if possible. &lt;br&gt;  &lt;br&gt;     The @+leo sentinel contains other information. For example:: &lt;br&gt;  &lt;br&gt;         &lt;opening_delim&gt;@leo-ver=4-thin&lt;closing_delim&gt; &lt;br&gt;  &lt;br&gt; \@-leo &lt;br&gt;     Marks the end of the Leo file. &lt;br&gt;     Nothing but whitespace should follow this directive. &lt;br&gt;  &lt;br&gt; \@+middle **(Created in Leo 4.0, removed in Leo 5.3)** &lt;br&gt;  &lt;br&gt; \@-middle **(Created in Leo 4.0, removed in Leo 5.3)** &lt;br&gt;     Marks the start/end of intermediate nodes between the node that &lt;br&gt;     references a section and the node that defines the section. &lt;br&gt;      &lt;br&gt;     These sentinels were a **mistake** that created bugs.  See: &lt;br&gt;     https://github.com/leo-editor/leo-editor/issues/132 &lt;br&gt;      &lt;br&gt; \@nl **(Leo 3.x only)** &lt;br&gt;     Insert a newline in the outline. &lt;br&gt;  &lt;br&gt; \@+node &lt;br&gt;     Mark the start and end of a node:: &lt;br&gt;  &lt;br&gt;         @+node:gnx:&lt;headline&gt; &lt;br&gt;          &lt;br&gt; \@nonl **(Leo 3.x only)** &lt;br&gt;     Suppresses a newline in the outline. &lt;br&gt;  &lt;br&gt; \@others &lt;br&gt;     The @+others sentinel indicates the start of the expansion of an @+others           &lt;br&gt;     directive, which continues until the matching @-others sentinel. &lt;br&gt;  &lt;br&gt; \@verbatim &lt;br&gt;     @verbatim indicates that the next line of the external file is not a sentinel. &lt;br&gt;     This escape convention allows body text to contain lines that would otherwise &lt;br&gt;     be considered sentinel lines. &lt;br&gt;  &lt;br&gt; \@@verbatimAfterRef &lt;br&gt;     @verbatimAfterRef is generated when a comment following a section reference would &lt;br&gt;     otherwise be treated as a sentinel. In Python code, an example would be:: &lt;br&gt;  &lt;br&gt;       &lt;&lt; ref &gt;&gt; #+others &lt;br&gt; " id="373" linkTypes="1" links="121" title="Format of external files" />
<node body="Leo uses unicode internally for all strings. &lt;br&gt;  &lt;br&gt; 1. Leo converts headline and body text to unicode when reading .leo files and external files. Both .leo files and external files may specify their encoding.  The default is utf-8. If the encoding used in a external file is not &quot;utf-8&quot; it is represented in the @+leo sentinel line. For example:: &lt;br&gt;  &lt;br&gt;         #@+leo-encoding=iso-8859-1. &lt;br&gt;  &lt;br&gt;     The utf-8 encoding is a &quot;lossless&quot; encoding (it can represent all &lt;br&gt;     unicode code points), so converting to and from utf-8 plain &lt;br&gt;     strings will never cause a problem. When reading or writing a &lt;br&gt;     character not in a &quot;lossy&quot; encoding, Leo converts such characters &lt;br&gt;     to '?' and issues a warning. &lt;br&gt;  &lt;br&gt; 2. When writing .leo files and external files Leo uses the same encoding used to read the file, again with utf-8 used as a default. &lt;br&gt;  &lt;br&gt; 3. leoSettings.leo contains the following Unicode settings, with the defaults as shown:: &lt;br&gt;  &lt;br&gt;         default_derived_file_encoding = UTF-8  &lt;br&gt;         new_leo_file_encoding = UTF-8  &lt;br&gt;  &lt;br&gt;     These control the default encodings used when writing external &lt;br&gt;     files and .leo files. Changing the new_leo_file_encoding setting &lt;br&gt;     is not recommended. See the comments in leoSettings.leo. You may &lt;br&gt;     set default_derived_file_encoding to anything that makes sense for &lt;br&gt;     you. &lt;br&gt;  &lt;br&gt; 4. The @encoding directive specifies the encoding used in a external file. You can't mix encodings in a single external file. &lt;br&gt; " id="374" linkTypes="1" links="121" title="Unicode reference" />
<node body="Leo checks that the URL is valid before attempting to open it. A valid URL is: &lt;br&gt;  &lt;br&gt; -   3 or more lowercase alphas &lt;br&gt; -   followed by one : &lt;br&gt; -   followed by one or more of: &lt;br&gt; -   ``$%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~`` &lt;br&gt; -   followed by one of: ``$%&amp;'()*+/0-9:=?@A-Z_a-z}~``  &lt;br&gt;  &lt;br&gt; That is, a comma, hyphen and open curly brace may not be the last character. &lt;br&gt;  &lt;br&gt; URL's in Leo should contain no spaces: use %20 to indicate spaces. &lt;br&gt;  &lt;br&gt; You may use any type of URL that your browser supports: http, mailto, ftp, file, etc. &lt;br&gt; " id="375" linkTypes="1" links="121" title="Valid URL's" />
<node body="This appendix documents the Mulder/Ream update algorithm in detail, with an informal proof of its correctness. &lt;br&gt;  &lt;br&gt; Prior to Leo 5.1, Leo used Bernhard Mulder's original algorithm to read @shadow files. Starting with Leo 5.1, Leo uses this algorithm to read both @clean and @shadow files. Conceptually, both algorithms work as described in the next section. &lt;br&gt;  &lt;br&gt; In February 2015 EKR realized that the @shadow algorithm could be used to update @clean (@nosent) files. Simplifying the algorithm instantly became a top priority. The new code emerged several days later, made possible by the x.sentinels array. It is an important milestone in Leo's history. &lt;br&gt; " id="376" linkTypes="3 3 3 3 3 3" links="789 790 791 792 793 794" title="The Mulder/Ream update algorithm" />
<node body="I wrote this soon after discovering Python in 2001. The conclusions are still valid today. &lt;br&gt;      &lt;br&gt; I've known for a while that Python was interesting; I attended a Python conference last year and added Python support to Leo. But last week I got that Python is something truly remarkable. I wanted to convert Leo from wxWindows to wxPython, so I began work on c2py, a Python script that would help convert from C++ syntax to Python. While doing so, I had an Aha experience. Python is more than an incremental improvement over Smalltalk or C++ or objective-C; it is &quot;something completely different&quot;. The rest of this post tries to explain this difference. &lt;br&gt; " id="377" linkTypes="3 3 3 3 3" links="795 796 797 798 799" title="Why I like Python" />
<node body=".. index:: &lt;br&gt;     pair: @; Glossary &lt;br&gt;  &lt;br&gt; \@ &lt;br&gt;     Starts a doc part. Doc parts continue until an @c &lt;br&gt;     directive or the end of the body text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @@ convention for headlines; Glossary &lt;br&gt;  &lt;br&gt; \@@ convention for headlines &lt;br&gt;     Within @asis trees only, if a headline starts with @@, Leo &lt;br&gt;     writes everything in the headline following the @@ just before the &lt;br&gt;     corresponding body text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @&lt;file&gt; node; Glossary &lt;br&gt;  &lt;br&gt; \@&lt;file&gt; node &lt;br&gt;     A node whose headline starts with &lt;br&gt;     @asis, @clean, @edit, @file, @shadow, @thin, or their longer forms. &lt;br&gt;     We often refer to outline nodes by the directives they contain. &lt;br&gt;     For example, an @file node is a node whose headline starts with @file, etc. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair:  @all; Glossary &lt;br&gt;  &lt;br&gt; \@all &lt;br&gt;     Copies the body text of all nodes in an @file tree to the external file. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @asis; Glossary &lt;br&gt;  &lt;br&gt; \@asis &lt;filename&gt; &lt;br&gt;     Creates an external file containing no Leo sentinels directly from the @asis tree. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @auto; Glossary &lt;br&gt;  &lt;br&gt; \@auto &lt;filename&gt; &lt;br&gt;  &lt;br&gt;     Imports an external file into the Leo outline, splitting the file into &lt;br&gt;     pieces if an importer exists for the give filetype. Importers presently &lt;br&gt;     exist for the following languages: C, C++, C#, HTML, INI files, Java, PHP, &lt;br&gt;     Pascal, Python and XML. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @c; Glossary &lt;br&gt;     pair: @code; Glossary &lt;br&gt;  &lt;br&gt; \@c and @code &lt;br&gt;  &lt;br&gt;     Ends a doc part and starts a code part. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @chapter; Glossary &lt;br&gt;  &lt;br&gt; \@chapter &lt;br&gt;  &lt;br&gt;     An @chapter tree represents a chapter. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @color; Glossary &lt;br&gt;      &lt;br&gt; .. index:: &lt;br&gt;     pair: @clean; Glossary &lt;br&gt;  &lt;br&gt; \@clean &lt;br&gt;  &lt;br&gt;     Creates an external file without sentinels. Section references and the &lt;br&gt;     @all and @others directives are valid in @clean trees. &lt;br&gt;  &lt;br&gt; \@color &lt;br&gt;  &lt;br&gt;     Enables syntax coloring in a node and its descendants until the next &lt;br&gt;     @nocolor directive. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @comment; Glossary &lt;br&gt;  &lt;br&gt; \@comment &lt;br&gt;  &lt;br&gt;     Sets the comment delimiters in @thin, @file and @shadow files. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @delims; Glossary &lt;br&gt;  &lt;br&gt; \@delims &lt;br&gt;  &lt;br&gt;   Sets the comment delimiters in @thin, @file and @shadow files. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @edit; Glossary &lt;br&gt;  &lt;br&gt; \@edit &lt;filename&gt; &lt;br&gt;  &lt;br&gt;     Reads an entire external file into a single node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @encoding; Glossary &lt;br&gt;  &lt;br&gt; \@encoding &lt;encoding&gt; &lt;br&gt;  &lt;br&gt;     Specifies the Unicode encoding for an external file. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @end_raw; Glossary &lt;br&gt;  &lt;br&gt; \@end_raw &lt;br&gt;  &lt;br&gt;     Ends a section of 'raw' text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @file; Glossary &lt;br&gt;  &lt;br&gt; \@file &lt;filename&gt; &lt;br&gt;  &lt;br&gt;     Creates an external file containing sentinels. When writing @file &lt;br&gt;     trees, Leo expands section references and @all and @others directives. &lt;br&gt;  &lt;br&gt;     **Important**: @file is the recommended way to create and edit most files. &lt;br&gt;     Using @file trees is **highly recommended** when sharing external files in &lt;br&gt;     a collaborative environment. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @first; Glossary &lt;br&gt;  &lt;br&gt; \@first &lt;text&gt; &lt;br&gt;  &lt;br&gt;     The @first directive allows you to place one or more lines at the very start of an &lt;br&gt;     external file, before the first sentinel. For example:: &lt;br&gt;  &lt;br&gt; 	    @first #! /usr/bin/env python &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @killcolor; Glossary &lt;br&gt;  &lt;br&gt; \@killcolor &lt;br&gt;  &lt;br&gt;     Completely disables syntax coloring in a node, regardless of other directives. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @language; Glossary &lt;br&gt;  &lt;br&gt; \@language &lt;language name&gt; &lt;br&gt;  &lt;br&gt;     Specifies the source language, which affects syntax coloring and the &lt;br&gt;     comments delimiters used in external files and syntax coloring. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @last; Glossary &lt;br&gt;  &lt;br&gt; \@last &lt;text&gt; &lt;br&gt;  &lt;br&gt;     Allows you to place lines at the very end of external files, after the last &lt;br&gt;     sentinel. For example:: &lt;br&gt;  &lt;br&gt;         @first &lt;?php &lt;br&gt;         ... &lt;br&gt;         @last ?&gt; &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @lineending; Glossary &lt;br&gt;  &lt;br&gt; \@lineending cr/lf/nl/crlf &lt;br&gt;  &lt;br&gt;     Sets the line endings for external files. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @nocolor; Glossary &lt;br&gt;  &lt;br&gt; \@nocolor &lt;br&gt;  &lt;br&gt;     Disables syntax coloring in a node and its descendants until the next @color &lt;br&gt;     directive. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @nocolor-node; Glossary &lt;br&gt;  &lt;br&gt; \@nocolor-node &lt;br&gt;  &lt;br&gt;     Completely disables coloring for one node. Descendant nodes are not affected. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @nosent; Glossary &lt;br&gt;  &lt;br&gt; \@nosent &lt;br&gt;  &lt;br&gt;     Creates external files without sentinels. Unlike @clean, @nosent trees &lt;br&gt;     are never updated from from external files. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @nowrap; Glossary &lt;br&gt;  &lt;br&gt; \@nowrap &lt;br&gt;  &lt;br&gt;     Disables line wrapping the Leo's body pane. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @others; Glossary &lt;br&gt;  &lt;br&gt; \@others &lt;br&gt;  &lt;br&gt;     Copies the body text of all nodes *except* section definition nodes in an &lt;br&gt;     @file tree to the corresponding external file. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @pagewidth; Glossary &lt;br&gt;  &lt;br&gt; \@pagewidth &lt;n&gt; &lt;br&gt;  &lt;br&gt;    Sets the page width used to break doc parts into lines. &lt;br&gt;  &lt;br&gt; ..  .. index:: &lt;br&gt;     ..  pair: \@path; Glossary &lt;br&gt;  &lt;br&gt; @path &lt;path&gt; &lt;br&gt;  &lt;br&gt;   Sets the path prefix for relative filenames for descendant \@&lt;file&gt; directives. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @raw; Glossary &lt;br&gt;  &lt;br&gt; \@raw &lt;br&gt;     Starts a section of &quot;raw&quot; text that ends *only* with the &lt;br&gt;     @end_raw directive or the end of the body text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @tabwidth; Glossary &lt;br&gt;  &lt;br&gt; \@tabwidth &lt;n&gt; &lt;br&gt;  &lt;br&gt;     Sets the width of tabs. Negative tab widths cause Leo to convert tabs to &lt;br&gt;     spaces. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @thin; Glossary &lt;br&gt;  &lt;br&gt; \@thin &lt;filename&gt; &lt;br&gt;  &lt;br&gt;     A synonym for @file. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @wrap; Glossary &lt;br&gt;  &lt;br&gt; \@wrap &lt;br&gt;  &lt;br&gt;     Enables line wrapping in Leo's body pane. &lt;br&gt; " id="378" linkTypes="1" links="122" title="\@" />
<node body=".. index:: &lt;br&gt;     pair: Body pane; Glossary &lt;br&gt;  &lt;br&gt; Body pane &lt;br&gt;  &lt;br&gt;     The pane containing the body text of the currently selected headline in the &lt;br&gt;     outline pane. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Body text; Glossary &lt;br&gt;  &lt;br&gt; Body text &lt;br&gt;  &lt;br&gt;     The text in the body pane. That is, the contents of a node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Body text box; Glossary &lt;br&gt;  &lt;br&gt; Body text box &lt;br&gt;  &lt;br&gt;     A small blue box in the icon box indicating that the node contains body &lt;br&gt;     text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Child; Glossary &lt;br&gt;  &lt;br&gt; Child &lt;br&gt;  &lt;br&gt;     The direct descendant of a node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Clone; Glossary &lt;br&gt;  &lt;br&gt; Clone &lt;br&gt;     A copy of a tree that changes whenever the original changes. &lt;br&gt;     The original and all clones are treated equally: &lt;br&gt;     no special status is given to the &quot;original&quot; node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Clone arrow; Glossary &lt;br&gt;  &lt;br&gt; Clone arrow &lt;br&gt;  &lt;br&gt;     A small red arrow in the icon box indicating that the node is a clone. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Code part; Glossary &lt;br&gt;  &lt;br&gt; Code part &lt;br&gt;  &lt;br&gt;     A part of a section definition that contains code. Code parts start with @c &lt;br&gt;     or @code directives and continue until the next doc part. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Contract; Glossary &lt;br&gt;  &lt;br&gt; Contract: &lt;br&gt;  &lt;br&gt;     To hide all descendants of a node. &lt;br&gt; " id="379" linkTypes="1" links="122" title="A - C" />
<node body=".. index:: &lt;br&gt;     pair: Demote; Glossary &lt;br&gt;  &lt;br&gt; Demote &lt;br&gt;     To move all siblings that follow a node so that they become children of the node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Descendant; Glossary &lt;br&gt;  &lt;br&gt; Descendant &lt;br&gt;     An offspring of a node.  That is, a child, grandchild, etc. of a node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Directive; Glossary &lt;br&gt;  &lt;br&gt; Directive &lt;br&gt;  &lt;br&gt;     A keyword, preceded by an '@' sign, in body text that controls Leo's &lt;br&gt;     operation. The keyword is empty for the @ directive. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Doc part; Glossary &lt;br&gt;  &lt;br&gt; Doc part &lt;br&gt;  &lt;br&gt;     A part of a section definition that contains comments. Doc parts start with &lt;br&gt;     @ and continue until the @c directive or the end of the body text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Escape convention; Glossary &lt;br&gt;  &lt;br&gt; .. _`noweb`: http://www.eecs.harvard.edu/~nr/noweb/ &lt;br&gt;  &lt;br&gt; Escape convention &lt;br&gt;  &lt;br&gt;     A convention for representing sequences of characters that would otherwise &lt;br&gt;     have special meaning. **Important**: Leo does not support escape conventions &lt;br&gt;     used by `noweb`_. Any line containing matched &lt;\&lt; and &gt;\&gt; is a section &lt;br&gt;     reference, regardless of context. To use &lt;\&lt; and &gt;\&gt; as ordinary characters, &lt;br&gt;     place them on separate lines. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Expand; Glossary &lt;br&gt;  &lt;br&gt; Expand &lt;br&gt;  &lt;br&gt;     To make the children of a node visible. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: External file; Glossary &lt;br&gt;  &lt;br&gt; External file &lt;br&gt;  &lt;br&gt;     A file outside of Leo that is connected to Leo by an @&lt;file&gt; node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: gnx; Glossary &lt;br&gt;     pair: Global Node Index; Glossary &lt;br&gt;      &lt;br&gt; .. _`format of external files`: http://leoeditor.com/appendices.html#format-of-external-files &lt;br&gt;      &lt;br&gt; Gnx (Global Node Index) &lt;br&gt;  &lt;br&gt;     A unique, immutable string permanently associated with each vnode. &lt;br&gt;     See `format of external files`_. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Grandchild; Glossary &lt;br&gt;  &lt;br&gt; Grandchild &lt;br&gt;  &lt;br&gt;     The child of a child of a node. &lt;br&gt; " id="380" linkTypes="1" links="122" title="D - G" />
<node body=".. index:: &lt;br&gt;     pair: Headline; Glossary &lt;br&gt;  &lt;br&gt; Headline &lt;br&gt;  &lt;br&gt;     The headline text of a node.  The part of the node visible in the outline pane. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Hoist; Glossary &lt;br&gt;     pair: Dehoist; Glossary &lt;br&gt;  &lt;br&gt; Hoist &amp; dehoist &lt;br&gt;  &lt;br&gt;     Hoisting a node redraws the screen that node and its descendants becomes the &lt;br&gt;     only visible part of the outline. Leo prevents the you from moving nodes &lt;br&gt;     outside the hoisted outline. Dehoisting a node restores the outline. &lt;br&gt;     Multiple hoists may be in effect: each dehoist undoes the effect of the &lt;br&gt;     immediately preceding hoist. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Icon box; Glossary &lt;br&gt;  &lt;br&gt; Icon box &lt;br&gt;  &lt;br&gt;     An icon just to the left of headline text of a node indicating whether the &lt;br&gt;     node is cloned, marked or dirty, and indicating whether the node contains &lt;br&gt;     body text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Log pane; Glossary &lt;br&gt;  &lt;br&gt; Log Pane &lt;br&gt;  &lt;br&gt;     The part of Leo's main window that shows informational messages from Leo. It &lt;br&gt;     also contains the Find tab, the Spell tab, the autocompletion tab. &lt;br&gt; " id="381" linkTypes="1" links="122" title="H - L" />
<node body=".. index:: &lt;br&gt;     pair: Mark; Glossary &lt;br&gt;  &lt;br&gt; Mark &lt;br&gt;  &lt;br&gt;     A red vertical line in the icon box of a node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Node; Glossary &lt;br&gt;  &lt;br&gt; Node &lt;br&gt;  &lt;br&gt;     The organizational unit of an outline. The combination of headline text and &lt;br&gt;     body text. Sometimes used as a synonym for tree. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Offspring; Glossary &lt;br&gt;  &lt;br&gt; Offspring &lt;br&gt;  &lt;br&gt;     A synonym for the descendants of a node. &lt;br&gt;     The children, grandchildren, etc. of a node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Organizer node; Glossary &lt;br&gt;  &lt;br&gt; Organizer node &lt;br&gt;  &lt;br&gt;     A node containing no body text. Organizing nodes may appear anywhere in an &lt;br&gt;     @file tree; they do not affect the external file in any way. In particular, &lt;br&gt;     organizing nodes do not affect indentation in external files. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Orphan node; Glossary &lt;br&gt;  &lt;br&gt; Orphan node &lt;br&gt;  &lt;br&gt;     A node that would not be copied to a external file. Orphan nodes can arise &lt;br&gt;     because an @file tree has no @others or @all directives. Sections that are &lt;br&gt;     defined but not used also create orphan nodes. &lt;br&gt;  &lt;br&gt;     Leo issues a warning when attempting to write an @file tree containing &lt;br&gt;     orphan nodes, and does not save the external file. No information is lost; &lt;br&gt;     Leo saves the information in the @file tree in the .leo file. Leo will load &lt;br&gt;     the @file tree from the .leo file the next time Leo opens the .leo file. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Outline; Glossary &lt;br&gt;  &lt;br&gt; Outline &lt;br&gt;  &lt;br&gt;     A node and its descendants. A tree. All the nodes of a .leo file. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Outline order; Glossary &lt;br&gt;  &lt;br&gt; Outline order &lt;br&gt;  &lt;br&gt;     The order that nodes appear on the screen when all nodes are expanded. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Outline pane; Glossary &lt;br&gt;  &lt;br&gt; Outline pane &lt;br&gt;  &lt;br&gt;     The pane containing a visual representation of the entire outline, or a part &lt;br&gt;     of the outline if the outline is hoisted. &lt;br&gt; " id="382" linkTypes="1" links="122" title="M - O" />
<node body=".. index:: &lt;br&gt;     pair: Parent; Glossary &lt;br&gt;  &lt;br&gt; Parent &lt;br&gt;  &lt;br&gt;     The node that directly contains a node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Plugin; Glossary &lt;br&gt;  &lt;br&gt; Plugin &lt;br&gt;  &lt;br&gt;     A way to modify and extend Leo without changing Leo's core code. &lt;br&gt;     See `Writing plugins and hooks`_. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Promote; Glossary &lt;br&gt;  &lt;br&gt; Promote &lt;br&gt;  &lt;br&gt;     To move all children of a node in an outline so that they become siblings of &lt;br&gt;     the node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: reStructuredText; Glossary &lt;br&gt;     pair: rST; Glossary &lt;br&gt;  &lt;br&gt; .. _`rST primer`: http://docutils.sourceforge.net/docs/user/rst/quickstart.html &lt;br&gt;  &lt;br&gt; reStructuredText (rST) &lt;br&gt;  &lt;br&gt;     A simple, yet powerful markup language for creating .html, or LaTeX output &lt;br&gt;     files. See the `rST primer`_. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Root; Glossary &lt;br&gt;  &lt;br&gt; Root &lt;br&gt;  &lt;br&gt;     The first node of a .leo file, outline, suboutline or @&lt;file&gt; tree. &lt;br&gt; " id="383" linkTypes="1" links="122" title="P - R" />
<node body=".. index:: &lt;br&gt;     pair: Section; Glossary &lt;br&gt;  &lt;br&gt; Section &lt;br&gt;  &lt;br&gt;     A fragment of text that can be incorporated into external files. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Section definition; Glossary &lt;br&gt;  &lt;br&gt; Section definition &lt;br&gt;  &lt;br&gt;     The body text of a section definition node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Section definition node; Glossary &lt;br&gt;  &lt;br&gt; Section definition node &lt;br&gt;  &lt;br&gt;     A node whose headline starts with a section name and whose body text defines &lt;br&gt;     a section. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Section name; Glossary &lt;br&gt;  &lt;br&gt; Section name &lt;br&gt;  &lt;br&gt;     A name enclosed in &lt;\&lt; and &gt;\&gt;. Section names may contain any characters &lt;br&gt;     except newlines and &quot;&gt;&gt;&quot;. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Section reference; Glossary &lt;br&gt;  &lt;br&gt; Section reference &lt;br&gt;  &lt;br&gt;     A section name appearing in a code part. When writing to an external file, &lt;br&gt;     Leo replaces all references by their definitions. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Sentinel; Glossary &lt;br&gt;  &lt;br&gt; Sentinel &lt;br&gt;  &lt;br&gt;     Comment lines in external files used to represent Leo's outline structure. &lt;br&gt;     Such lines start with an @ following the opening comment delimiter. &lt;br&gt;     Sentinels embed outline structure into external files. &lt;br&gt;  &lt;br&gt;     **Do not alter sentinel lines**. Doing so can corrupt the outline structure. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Setting; Glossary &lt;br&gt;  &lt;br&gt; Settings: &lt;br&gt;  &lt;br&gt;     Plugins and other parts of Leo can get options from @settings trees, &lt;br&gt;     outlines whose headline is @settings. When opening a .leo file, Leo looks &lt;br&gt;     for @settings trees in the outline being opened and also in various &lt;br&gt;     leoSettings.leo files. @settings trees allow plugins to get options without &lt;br&gt;     any further support from Leo's core code. For a full discussion of @settings &lt;br&gt;     trees, see `Customizing Leo`_. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Sibling; Glossary &lt;br&gt;  &lt;br&gt; Sibling &lt;br&gt;  &lt;br&gt;     Nodes with the same parent. Siblings of the root node have the hidden root &lt;br&gt;     node as their parent. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Target language; Glossary &lt;br&gt;  &lt;br&gt; Target language &lt;br&gt;  &lt;br&gt;     The language used to syntax color text. This determines the default comment &lt;br&gt;     delimiters used when writing external files. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Tree; Glossary &lt;br&gt;  &lt;br&gt; Tree &lt;br&gt;  &lt;br&gt;     An outline. A node and its descendants. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Underindented Line; Glossary &lt;br&gt;  &lt;br&gt; Underindent line &lt;br&gt;  &lt;br&gt;     A line of body text that is indented less then the starting line of the &lt;br&gt;     class, method or function in which it appears. Leo outlines can not &lt;br&gt;     represent such lines exactly: every line in an external file will have at &lt;br&gt;     least the indentation of any unindented line of the corresponding node in &lt;br&gt;     the outline. &lt;br&gt;      &lt;br&gt; .. index:: &lt;br&gt;     pair: uA; Glossary &lt;br&gt;  &lt;br&gt; .. _`extensible attributes`: http://leoeditor.com/customizing.html#adding-extensible-attributes-to-nodes-and-leo-files &lt;br&gt;      &lt;br&gt; uA &lt;br&gt;      &lt;br&gt;     uA's (User Attributes) are persistent Python dicts that allows scripts &lt;br&gt;     and plugins to associate additional data with each node. See &lt;br&gt;     `extensible attributes`_. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: View node; Glossary &lt;br&gt;  &lt;br&gt; View node &lt;br&gt;  &lt;br&gt;     A node that represents a view of an outline. View nodes are typically &lt;br&gt;     ordinary, non-cloned nodes that contain cloned descendant nodes. The cloned &lt;br&gt;     descendant nodes comprise most of the data of the view. Other non-cloned &lt;br&gt;     nodes may add additional information to the view. &lt;br&gt; " id="384" linkTypes="1" links="122" title="S - Z" />
<node body=".. Links used in this document. &lt;br&gt; .. _`leoBridge`:            leoBridge.html &lt;br&gt; .. _`debugging with Leo`:   debuggers.html &lt;br&gt; .. _`Using @shadow`:        atShadow.html &lt;br&gt; .. _`Python's gettext`:     http://docs.python.org/lib/module-gettext.html &lt;br&gt; .. _Emacs:                  http://www.xemacs.org/ &lt;br&gt; .. _pymacs:                 http://pymacs.progiciels-bpi.ca/index.html &lt;br&gt; .. _`Leo and Emacs`:        emacs.html &lt;br&gt;  &lt;br&gt;  &lt;br&gt; " id="385" linkTypes="1" links="123" title="@rst-no-head links" />
<node body="" id="386" linkTypes="3 3 3 3 3" links="800 801 802 803 804" title="What's new in Leo 5.2" />
<node body="" id="387" linkTypes="3 3 3 3 3" links="805 806 807 808 809" title="What's new in Leo 5.1" />
<node body="" id="388" linkTypes="3 3 3 3 3" links="810 811 812 813 814" title="What's new in Leo 5.0" />
<node body="" id="389" linkTypes="3 3 3 3 3 3" links="815 816 817 818 819 820" title="What's new in Leo 4.11" />
<node body=" &lt;br&gt; " id="390" linkTypes="3 3 3 3" links="821 822 823 824" title="What's new in Leo 4.10" />
<node body=" &lt;br&gt; " id="391" linkTypes="3 3 3" links="825 826 827" title="What's new in Leo 4.9" />
<node body="" id="392" linkTypes="3 3 3" links="828 829 830" title="What's new in Leo 4.8" />
<node body="" id="393" linkTypes="3 3 3" links="831 832 833" title="What's new in Leo 4.7" />
<node body="" id="394" linkTypes="3 3 3" links="834 835 836" title="What's new in Leo 4.6" />
<node body="" id="395" linkTypes="3" links="837" title="What's new in Leo 4.5" />
<node body="" id="396" linkTypes="3" links="838" title="What's new in Leo 4.4.8" />
<node body="" id="397" linkTypes="3" links="839" title="What's new in Leo 4.4.7" />
<node body="" id="398" linkTypes="3" links="840" title="What's new in Leo 4.4.6" />
<node body="" id="399" linkTypes="3 3 3" links="841 842 843" title="What's new in Leo 4.4.5" />
<node body="" id="400" linkTypes="3 3 3" links="844 845 846" title="What's new in Leo 4.4.4" />
<node body="" id="401" linkTypes="3" links="847" title="What's new in Leo 4.4.3" />
<node body="" id="402" linkTypes="3 3 3 3 3" links="848 849 850 851 852" title="What's new in Leo 4.4.2" />
<node body="" id="403" linkTypes="3 3 3 3 3" links="853 854 855 856 857" title="What's new in Leo 4.4.1" />
<node body="" id="404" linkTypes="3 3 3 3 3" links="858 859 860 861 862" title="What's new in Leo 4.4" />
<node body="Deletes p.v.rst2_http_attributename from all nodes after writing. &lt;br&gt;  &lt;br&gt; Deletes p.v.unknownAttributes if it then becomes empty. &lt;br&gt; " id="405" linkTypes="1" links="187" title="@bool rst3_clear_http_attributes = False" />
<node body="" id="406" linkTypes="1" links="187" title="@string rst3_http_attributename = rst_http_attribute" />
<node body="@nocolor &lt;br&gt;  &lt;br&gt; If False, add_node_marker and http_support_main  do nothing.  Otherwise add_node_marker does the following: &lt;br&gt;  &lt;br&gt; 1. add_node_marker writes a string using generate_node_marker. &lt;br&gt;  &lt;br&gt; Generates 'http-node-marker-'+str(number), where number is config.node_counter &lt;br&gt; (incremented each time add_node_marker is called. &lt;br&gt;  &lt;br&gt; 2. Enables the following code in : &lt;br&gt; @color &lt;br&gt;  &lt;br&gt;     if config.tag == 'open2': &lt;br&gt;         http_map = self.http_map &lt;br&gt;     else: &lt;br&gt;         http_map = {} &lt;br&gt;         config.anchormap = {} &lt;br&gt;         # maps v nodes to markers. &lt;br&gt;         config.node_counter = 0 &lt;br&gt;     # [snip] code to write the tree &lt;br&gt;     if config.rst2_http_server_support: &lt;br&gt;         self.http_map = http_map &lt;br&gt; " id="407" linkTypes="1" links="187" title="@bool rst3_http_server_support = False" />
<node body="" id="408" linkTypes="1" links="187" title="@string rst3_node_begin_marker = http-node-marker-" />
<node body="" id="409" linkTypes="3 3" links="863 864" title="@screenshot" />
<node body="" id="410" linkTypes="1" links="188" title="@select Urgent" />
<node body="'''Create @slide nodes under p, an @slideshow node.''' &lt;br&gt;  &lt;br&gt; n = 23 # Number of last slide to be created. &lt;br&gt;  &lt;br&gt; existing = [z.copy().h for z in p.children()  &lt;br&gt;     if g.match_word(z.h,0,'@slide')] &lt;br&gt;  &lt;br&gt; if g.match_word(p.h,0,'@slideshow'): &lt;br&gt;     b = c.undoer.beforeChangeTree(p) &lt;br&gt;     changed = False &lt;br&gt;     for n in range(1,n+1): &lt;br&gt;         h = '@slide %03d' % n &lt;br&gt;         if h not in existing: &lt;br&gt;             changed = True &lt;br&gt;             child = p.insertAsLastChild() &lt;br&gt;             child.h = h &lt;br&gt;             g.note('created %s' % h) &lt;br&gt;     if changed: &lt;br&gt;         c.undoer.afterChangeTree(p,'ins-@slide-nodes',b) &lt;br&gt;     else: &lt;br&gt;         g.note('no @slide nodes inserted') &lt;br&gt;     c.redraw() &lt;br&gt; else: &lt;br&gt;     g.error('not an @slideshow node',p.h) &lt;br&gt; " id="411" linkTypes="1" links="188" title="@@button ins-@slide-nodes" />
<node body="m = g.loadOnePlugin('screenshots') &lt;br&gt; m.make_slide_command(event={'c':c}) &lt;br&gt; " id="412" linkTypes="1" links="188" title="@@button make-slide @key=Alt-8" />
<node body="m = g.loadOnePlugin('screenshots') &lt;br&gt; m.make_slide_show_command(event={'c':c}) &lt;br&gt; " id="413" linkTypes="1" links="188" title="@@button make-slide-show @key=Alt-8" />
<node body="'''Meld Wink slides into an @slideshow folder. &lt;br&gt;  &lt;br&gt;    Copy screenshot files from the wink_dir to slideshow_dir, numbering &lt;br&gt;    the destination files to reflect &quot;holes&quot; created by @no-screenshot &lt;br&gt;    nodes. &lt;br&gt;  &lt;br&gt;    This script carefully checks that the number of screenshot files &lt;br&gt;    matches the number of screenshots referenced by the @slide nodes. &lt;br&gt;    No copying takes place if the numbers are not as expected.''' &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt;  &lt;br&gt; import glob &lt;br&gt; import os &lt;br&gt; import shutil &lt;br&gt;  &lt;br&gt; slideshow_dir = 'C:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step' &lt;br&gt;  &lt;br&gt; wink_dir = 'C:/leo.repo/trunk/leo/doc/html/slides/leo-basics-step-by-step/_files' &lt;br&gt;     # The directory containing the wink screenshots. &lt;br&gt;     # This will usually be &lt;slideshow_dir&gt;/_files. &lt;br&gt;     # **Important** You generate these screenshots using Wink's  &lt;br&gt;     # Export As Html command (!) &lt;br&gt;  &lt;br&gt; @others &lt;br&gt;  &lt;br&gt; mc = MeldController(c,p,slideshow_dir,wink_dir) &lt;br&gt; mc.run() &lt;br&gt; " id="414" linkTypes="3" links="865" title="@@button meld" />
<node body="'''Renumber @slide nodes under p, an @slideshow node.''' &lt;br&gt;  &lt;br&gt; if g.match_word(p.h,0,'@slideshow'): &lt;br&gt;     n = 1 &lt;br&gt;     for child in p.children(): &lt;br&gt;         if g.match(child.h,0,'@slide'): &lt;br&gt;             child.h = '@slide %03d' % n &lt;br&gt;             n += 1 &lt;br&gt;     c.redraw() &lt;br&gt; else: &lt;br&gt;     g.error('not an @slideshow node',p.h) &lt;br&gt; " id="415" linkTypes="1" links="188" title="@@button renumber nodes" />
<node body="def allowDir (self,p): &lt;br&gt;  &lt;br&gt;     '''Return True if we should allow scan of directory p.''' &lt;br&gt;  &lt;br&gt;     aList = ( &lt;br&gt;         # Suppressed directories. &lt;br&gt;         'Examples','Experimental', &lt;br&gt;         'Dyna plugins by e', &lt;br&gt;         'Gui plugins','Testing', &lt;br&gt;     ) &lt;br&gt;     return p.h not in aList and not p.h.startswith('  ') &lt;br&gt; " id="416" linkTypes="1" links="196" title="allowDir" />
<node body="def allowFile (self,p): &lt;br&gt;  &lt;br&gt;     '''Return True if we should allow scan of a file at p.''' &lt;br&gt;  &lt;br&gt;     aList = ( &lt;br&gt;         # Suppressed files. &lt;br&gt;         '@file bookmarks.py',       # Replaced by better @url. &lt;br&gt;         '@file rst3.py',            # Replaced by core rst3 command. &lt;br&gt;         '@file stickynotes_plus.py', # Experimental version of stickynotes &lt;br&gt;         '@file testnode.py',        # Replaced by @edit. &lt;br&gt;         # These all depend on old plugins_manager.py. &lt;br&gt;         '@file autotrees.py',  &lt;br&gt;         '@file old_plugin_manager.py', &lt;br&gt;         '@file leoupdate.py', &lt;br&gt;         # These are used only by autotrees.py. &lt;br&gt;         r'@file trees\doc.py', &lt;br&gt;         r'@file trees\news.py', &lt;br&gt;         r'@file trees\remote.py', &lt;br&gt;         r'@file trees\rss.py', &lt;br&gt;         r'@file trees\test.py', &lt;br&gt;     ) &lt;br&gt;     return p.h not in aList and p.isAnyAtFileNode() and p.h.endswith('.py') &lt;br&gt; " id="417" linkTypes="1" links="196" title="allowFile" />
<node body="def createDocs (self,output,root): &lt;br&gt;  &lt;br&gt;      for p in root.children(): &lt;br&gt;         if self.allowDir(p): &lt;br&gt;             if self.trace: print('\n**',p.h) &lt;br&gt;             child = output.insertAsLastChild() &lt;br&gt;             child.h = p.h &lt;br&gt;             for p2 in p.subtree(): &lt;br&gt;                 if self.allowFile(p2): &lt;br&gt;                     h = p2.anyAtFileNodeName() &lt;br&gt;                     s = self.getDocString(p2) &lt;br&gt;                     if self.trace: print('%5s %s' % (len(s),h)) &lt;br&gt;                     child2 = child.insertAsLastChild() &lt;br&gt;                     child2.h = h &lt;br&gt;                     child2.b = &quot;%s\n\n&quot; % s.strip() &lt;br&gt; " id="418" linkTypes="1" links="196" title="createDocs" />
<node body="def createSummary (self,output,root): &lt;br&gt;  &lt;br&gt;     summary = output.insertAsLastChild() &lt;br&gt;     summary.h = 'Summary' &lt;br&gt;     result = [] &lt;br&gt;  &lt;br&gt;     for p in root.children(): &lt;br&gt;         if self.allowDir(p): &lt;br&gt;             for p2 in p.subtree(): &lt;br&gt;                 if self.allowFile(p2): &lt;br&gt;                     h = p2.anyAtFileNodeName() &lt;br&gt;                     s = self.getDocString(p2) &lt;br&gt;                     s = self.getFirstParagraph(s).rstrip() &lt;br&gt;                     if s: &lt;br&gt;                         if not s.endswith('.'): s = s + '.' &lt;br&gt;                         result.append('%s\n%s\n\n' % (h,s)) &lt;br&gt;  &lt;br&gt;     # Sort by plugin name, ignoring case. &lt;br&gt;     def lower(s): return s.lower() &lt;br&gt;     result.sort(key=lower) &lt;br&gt;     summary.b = ''.join(result) &lt;br&gt; " id="419" linkTypes="1" links="196" title="createSummary" />
<node body="def getDocString(self,p): &lt;br&gt;  &lt;br&gt;     '''Return the docstring of the @&lt;file&gt; node p.''' &lt;br&gt;  &lt;br&gt;     trace = False # p.h.find('@file rClick.py') &gt; -1 &lt;br&gt;     if trace: g.trace('='*20) &lt;br&gt;     for p2 in p.self_and_subtree(): &lt;br&gt;         s = p2.b &lt;br&gt;         if trace: g.trace(p2.h) &lt;br&gt;         for tag in (&quot;'''&quot;,'&quot;&quot;&quot;'): &lt;br&gt;             i = s.find(tag) &lt;br&gt;             if i &gt; -1: &lt;br&gt;                 j = s.find(tag,i+3) &lt;br&gt;                 if j &gt; -1: &lt;br&gt;                     if trace: g.trace('**found**',p2.h,'\n',s) &lt;br&gt;                     return s[i+3:j] &lt;br&gt;     else: &lt;br&gt;         return '' &lt;br&gt; " id="420" linkTypes="1" links="196" title="getDocString" />
<node body="def getFirstParagraph (self,s): &lt;br&gt;  &lt;br&gt;     lines =  g.splitLines(s.strip()) &lt;br&gt;     if not lines: return '' &lt;br&gt;  &lt;br&gt;     result = [] &lt;br&gt;     for s in lines: &lt;br&gt;         if s.strip(): &lt;br&gt;             result.append('   '+s) &lt;br&gt;         else: &lt;br&gt;             break &lt;br&gt;  &lt;br&gt;     return ''.join(result) &lt;br&gt; " id="421" linkTypes="1" links="196" title="getFirstParagraph" />
<node body="def openLeoPlugins(self): &lt;br&gt;  &lt;br&gt;     fn = g.os_path_finalize_join( &lt;br&gt;         g.app.loadDir,'..','plugins','leoPlugins.leo') &lt;br&gt;  &lt;br&gt;     ok,frame = g.openWithFileName(fn, &lt;br&gt;         old_c=self.c,enableLog=True, &lt;br&gt;         gui=None,readAtFileNodesFlag=True) &lt;br&gt;  &lt;br&gt;     if ok: &lt;br&gt;         return frame.c &lt;br&gt;     else: &lt;br&gt;         g.error('can not open leoPlugins.leo') &lt;br&gt;         return None &lt;br&gt; " id="422" linkTypes="1" links="196" title="openPlugins" />
<node body="def run(self): &lt;br&gt;  &lt;br&gt;     c = self.c &lt;br&gt;     new_c = self.openLeoPlugins() &lt;br&gt;     if not new_c: return &lt;br&gt;  &lt;br&gt;     # Create the top-level output node. &lt;br&gt;     output = c.p.insertAfter() &lt;br&gt;     output.h = 'get-docstrings-output' &lt;br&gt;     output.b = '@language rest\n' &lt;br&gt;  &lt;br&gt;     # Scan the descendants of the Plugins node. &lt;br&gt;     root = g.findNodeAnywhere(new_c,'Plugins') &lt;br&gt;     if root: &lt;br&gt;         if self.trace: print('='*20) &lt;br&gt;         self.createSummary(output,root) &lt;br&gt;         self.createDocs(output,root) &lt;br&gt;         c.frame.bringToFront() # new_c.close() &lt;br&gt;         c.redraw() &lt;br&gt;     else: &lt;br&gt;         g.error('no Plugins node') &lt;br&gt;  &lt;br&gt;  &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt; " id="423" linkTypes="1" links="196" title="run" />
<node body="Org mode is kinda like Leo for Emacs: http://orgmode.org/manual/index.html &lt;br&gt;  &lt;br&gt; As a result of &quot;convergent evolution&quot; it has many of Leo's features: &lt;br&gt;  &lt;br&gt; - Outline commands: &lt;br&gt; http://orgmode.org/manual/Structure-editing.html#Structure-editing &lt;br&gt;  &lt;br&gt; - To-do lists: http://orgmode.org/manual/TODO-Items.html#TODO-Items &lt;br&gt;  &lt;br&gt; - Hyperlinks: http://orgmode.org/manual/Hyperlinks.html#Hyperlinks &lt;br&gt;  &lt;br&gt; This is natural. &lt;br&gt;  &lt;br&gt; But org mode lacks *all* of Leo's crucial scripting features: &lt;br&gt;  &lt;br&gt; 1. Org mode gives scripts *no* access to org mode outlines! There is no API, for elisp or any other language. No predefined c,g,p. In org mode, **everything is just text**. &lt;br&gt;  &lt;br&gt; 2. Org mode has no extensibility features: no plugin architecture, no event handlers, no @button. &lt;br&gt;  &lt;br&gt; 3. Org mode has no clones, generators, or positions because everything is a simple tree. &lt;br&gt;  &lt;br&gt; It is possible to create source files using org mode: &lt;br&gt; http://orgmode.org/manual/Working-With-Source-Code.html#Working-With-Source-Code &lt;br&gt;  &lt;br&gt; But org mode is feeble in comparison: &lt;br&gt;  &lt;br&gt; - No @others(!!)  noweb is used as the markup--there is *no* integration of markup with outline structure. &lt;br&gt; - Source code must be delimited with markup(!!) &lt;br&gt;   http://orgmode.org/manual/Structure-of-code-blocks.html#Structure-of-code-blocks &lt;br&gt; - No automatic tangling. &lt;br&gt; - No untangling at all. &lt;br&gt; - No automatic imports (@auto). &lt;br&gt;  &lt;br&gt; Emacs makes up for it's lack true outline structure with a huge user base, &lt;br&gt; so most (not all!) Leo's features have gotten *simulated* in an ugly, &lt;br&gt; hard-to-extend, way. But simulation has its limits: features like @button &lt;br&gt; and @test do not exist in org mode." id="424" linkTypes="1" links="198" title="post Leo vs Emacs" />
<node body="&lt;script type=&quot;text/javascript&quot;&gt; &lt;br&gt; /* &lt;![CDATA[ */ &lt;br&gt;     (function() { &lt;br&gt;         var s = document.createElement('script'), t = document.getElementsByTagName('script')[0]; &lt;br&gt;         s.type = 'text/javascript'; &lt;br&gt;         s.async = true; &lt;br&gt;         s.src = 'http://api.flattr.com/js/0.6/load.js?mode=auto'; &lt;br&gt;         t.parentNode.insertBefore(s, t); &lt;br&gt;     })(); &lt;br&gt; /* ]]&gt; */ &lt;br&gt; &lt;/script&gt; &lt;br&gt; " id="425" linkTypes="1" links="209" title="&lt;&lt; flattr head &gt;&gt;" />
<node body="&lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt; &lt;br&gt;  &lt;br&gt; &lt;!-- See: http://feed2js.org/index.php?s=style --&gt; &lt;br&gt;  &lt;br&gt; .rss_box { &lt;br&gt;     width:   0px; &lt;br&gt;     padding: 0px; &lt;br&gt;     border:  0px solid white; &lt;br&gt;     margin:  0px; &lt;br&gt; } &lt;br&gt;  &lt;br&gt; .rss_title { &lt;br&gt;     visibility:hidden; &lt;br&gt;     line-height: 0px; &lt;br&gt; } &lt;br&gt;  &lt;br&gt; .rss_items { &lt;br&gt;     font-size: 80%; &lt;br&gt; } &lt;br&gt;  &lt;br&gt; &lt;/style&gt; &lt;br&gt; " id="426" linkTypes="1" links="209" title="&lt;&lt; feed2js stylesheet &gt;&gt;" />
<node body="&lt;p&gt;&lt;blockquote&gt; &lt;br&gt;   &quot;Leo is a revolutionary step in the right direction for programming.&quot;&amp;#8213;Brian Takita &lt;br&gt; &lt;/blockquote&gt; &lt;br&gt;  &lt;br&gt; &lt;blockquote&gt; &quot;Leo is the best IDE that I have had the pleasure to use. It &lt;br&gt; has totally changed not only the way that I program, but also the way that &lt;br&gt; I store and organize all of the information that I need for the job that I &lt;br&gt; do.&quot;&amp;#8213;Ian Mulvany &lt;br&gt; &lt;/blockquote&gt; &lt;br&gt;  &lt;br&gt; &lt;blockquote&gt; &lt;br&gt; &quot;When first I opened Leo, it was out of curiosity. But having used it, I'll &lt;br&gt; never go back. They'll have to pry Leo out of my cold, dead fingers!&quot;&amp;#8213;Travers A. Hough &lt;br&gt; &lt;/blockquote&gt; &lt;br&gt; &lt;p&gt; &lt;br&gt; Leo is a &lt;br&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Personal_information_manager&quot;&gt;PIM&lt;/a&gt;,  &lt;br&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Integrated_development_environment&quot;&gt;IDE&lt;/a&gt; &lt;br&gt; and outliner that &lt;br&gt; &lt;strong&gt;accelerates the work flow&lt;/strong&gt; &lt;br&gt; of programmers, authors and web designers. &lt;br&gt; Leo's unique features &lt;strong&gt;organize data in a revolutionary way&lt;/strong&gt;: &lt;br&gt; &lt;li&gt; &lt;br&gt;   Leo outlines are views on an underlying &lt;br&gt;   &lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_acyclic_graph&quot;&gt;graph&lt;/a&gt;. &lt;br&gt; &lt;li&gt; &lt;br&gt;   Outline nodes can reside in &lt;strong&gt;many&lt;/strong&gt; places within a single outline.&lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;br&gt;   Leo is fully scriptable in &lt;a HREF=&quot;http://www.python.org/&quot;&gt;Python&lt;/a&gt;.&lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;br&gt;   Leo scripts have full access to Leo's source code and all outline data.&lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;br&gt;   &lt;a href=&quot;tutorial-programming.html&quot;&gt;Outline-oriented markup&lt;/a&gt; generates &lt;br&gt;   &lt;a href=&quot;tutorial-basics.html#creating-external-files-with-file-and-all&quot;&gt;external files&lt;/a&gt; &lt;br&gt;   from outlines.&lt;/li&gt; &lt;br&gt; &lt;/p&gt; &lt;br&gt; &lt;p&gt; &lt;br&gt;   &lt;a href=&quot;preliminaries.html#preface&quot;&gt; &lt;br&gt;     &lt;strong&gt;Learn why Leo is special&lt;/strong&gt;&lt;/a&gt;. &lt;br&gt;   &lt;br&gt; &lt;br&gt;   &lt;a href=&quot;tutorial.html&quot;&gt; &lt;br&gt;     &lt;strong&gt;Learn about Leo in two hours&lt;/strong&gt;&lt;/a&gt;. &lt;br&gt; &lt;/p&gt; &lt;br&gt; &lt;p&gt; &lt;br&gt; Furthermore: &lt;br&gt; &lt;/p&gt; &lt;br&gt; &lt;li&gt; &lt;br&gt; Leo is &lt;a href=&quot;http://www.opensource.org/&quot;&gt;&lt;i&gt;Open Software&lt;/i&gt;&lt;/a&gt;, &lt;br&gt; written in pure &lt;a HREF=&quot;http://www.python.org/&quot;&gt;Python&lt;/a&gt;. &lt;br&gt; &lt;li&gt; &lt;br&gt; Leo is a &lt;a HREF=&quot;http://www.riverbankcomputing.co.uk/software/pyqt/intro&quot;&gt;PyQt&lt;/a&gt; &lt;br&gt; app that runs on Linux, Windows and MacOS.&lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;br&gt; Leo works well with &lt;a href=&quot;http://www.gnu.org/software/emacs/&quot;&gt;emacs&lt;/a&gt;, &lt;br&gt;   &lt;a href=&quot;http://www.xemacs.org/&quot;&gt;xemacs&lt;/a&gt;, &lt;br&gt;   &lt;a href=&quot;http://www.vim.org/&quot;&gt;vim&lt;/a&gt;, and &lt;br&gt;   &lt;a href=&quot;http://ipython.org/&quot;&gt;ipython&lt;/a&gt;.&lt;/li&gt; &lt;br&gt; &lt;/p&gt; &lt;br&gt; " id="427" linkTypes="1" links="211" title="&lt;&lt; Leo is... &gt;&gt;" />
<node body="&lt;p&gt; &lt;br&gt; &lt;strong&gt;We welcome your questions and comments!&lt;/strong&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; Ask us anything at the medium traffic &lt;br&gt; &lt;a href=&quot;http://groups.google.com/group/leo-editor&quot;&gt;&lt;strong&gt;leo-editor Google Group&lt;/strong&gt;&lt;/a&gt;. &lt;br&gt; &lt;br&gt; &lt;br&gt; If you use Leo, please &lt;br&gt; &lt;a href=&quot;mailto:edreamleo@gmail.com?Subject=About%20Leo&quot; target=&quot;_top&quot;&gt; &lt;br&gt;   &lt;strong&gt;send us a postcard&lt;/strong&gt;&lt;/a&gt;, telling how you use Leo. Thanks! &lt;br&gt; &lt;/p&gt; &lt;br&gt;  &lt;br&gt; &lt;!-- &lt;br&gt; &lt;p&gt;Here are the most recent discussions...&lt;/p&gt; &lt;br&gt; &lt;script language=&quot;JavaScript&quot; &lt;br&gt;   src=&quot;http://itde.vccs.edu/rss2js/feed2js.php?src=http%3A%2F%2Fgroups.google.com%2Fgroup%2Fleo-editor%2Ffeed%2Frss_v2_0_msgs.xml&amp;chan=title&amp;num=5&amp;desc=0&amp;date=y&amp;targ=y&quot; &lt;br&gt;   type=&quot;text/javascript&quot;&gt; &lt;br&gt; &lt;/script&gt; &lt;br&gt; --&gt; &lt;br&gt; " id="428" linkTypes="1" links="211" title="&lt;&lt; Leo Google group &amp; postcard &gt;&gt;" />
<node body="&lt;p&gt;Here is a slightly reduced screenshot of Leo's main window:&lt;/p&gt; &lt;br&gt;  &lt;br&gt; &lt;!-- height/width taken from basics1.html --&gt; &lt;br&gt; &lt;img class=&quot;screenshot&quot; &lt;br&gt;     src=&quot;screen-shots/render-svg-sources.png&quot; &lt;br&gt;     width=&quot;791.2px&quot; height=&quot;692.8px&quot;  &lt;br&gt;     alt=&quot;ScreenShot&quot;/&gt; &lt;br&gt; " id="429" linkTypes="1" links="211" title="&lt;&lt; screenshot &gt;&gt;" />
<node body="&lt;!-- This works -- &lt;br&gt; &lt;iframe id=&quot;forum_embed&quot; &lt;br&gt;     src=&quot;javascript:void(0)&quot; &lt;br&gt;     scrolling=&quot;yes&quot; &lt;br&gt;     frameborder=&quot;1&quot; &lt;br&gt;     width=&quot;900&quot; &lt;br&gt;     height=&quot;700&quot;&gt; &lt;br&gt; &lt;/iframe&gt; &lt;br&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;br&gt;   document.getElementById('forum_embed').src = &lt;br&gt;      'https://groups.google.com/forum/embed/?place=forum/leo-editor' &lt;br&gt;      + '&amp;showsearch=true&amp;showpopout=true&amp;showtabs=true' &lt;br&gt;      + '&amp;parenturl=' + encodeURIComponent(window.location.href); &lt;br&gt; &lt;/script&gt; &lt;br&gt; --&gt; &lt;br&gt; " id="430" linkTypes="1" links="211" title="&lt;&lt; embed leo-editor &gt;&gt;" />
<node body="@language html &lt;br&gt;  &lt;br&gt; &lt;p class=&quot;logo&quot;&gt;&lt;a href=&quot;leo_toc.html&quot;&gt; &lt;br&gt;   &lt;img class=&quot;logo&quot; src=&quot;_static/Leo4-80-border.jpg&quot; alt=&quot;Logo&quot;/&gt;&lt;/a&gt; &lt;br&gt; &lt;/p&gt; &lt;br&gt;  &lt;br&gt; &lt;p&gt; &lt;br&gt;   &lt;a class=&quot;reference external&quot; href=&quot;leo_toc.html&quot;&gt;Table of contents&lt;/a&gt;: click the lion! &lt;br&gt; &lt;/p&gt; &lt;br&gt; &lt;p&gt; &lt;br&gt; &lt;form&gt; &lt;br&gt;   &lt;!-- background-color:skyblue3 --&gt; &lt;br&gt;   &lt;!-- border-style:solid;border-color:#87CEEB --&gt; &lt;br&gt;   &lt;input type=&quot;button&quot; &lt;br&gt;     style=&quot;background-color:#6CA6CD;&quot; &lt;br&gt;     value=&quot;Download Leo&quot; &lt;br&gt;     onClick=&quot;window.location.href='download.html'&quot;&gt; &lt;br&gt; &lt;/form&gt; &lt;br&gt; &lt;/p&gt; &lt;br&gt;  &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;screencasts.html&quot;&gt; &lt;br&gt;   Videos about Leo&lt;/a&gt;&lt;br&gt; &lt;br&gt;  &lt;br&gt; &lt;!--- &lt;br&gt; &lt;a href=&quot;http://www.youtube.com/watch?v=Zu6J-J0qFi0&quot;&gt; &lt;br&gt;   Introductory video&lt;/a&gt;&lt;br&gt; &lt;br&gt; &lt;a href=&quot;https://vimeo.com/77720098 &quot;&gt; &lt;br&gt;   Bookmarks plugin video&lt;/a&gt;&lt;br&gt; &lt;br&gt; --&gt; &lt;br&gt;    &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;tutorial.html&quot;&gt; &lt;br&gt;   Leo's Tutorial&lt;/a&gt;&lt;br&gt; &lt;br&gt;  &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;leo_toc.html&quot;&gt; &lt;br&gt;   Leo's Documentation&lt;/a&gt;&lt;br&gt; &lt;br&gt;    &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;http:screen-shots.html&quot;&gt; &lt;br&gt;   Screen shots of Leo&lt;/a&gt;&lt;br&gt; &lt;br&gt;    &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;testimonials.html&quot;&gt; &lt;br&gt;   Quotes from Leo&amp;#8217;s Users&lt;/a&gt;&lt;br&gt; &lt;br&gt;    &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;slides.html&quot;&gt; &lt;br&gt;   Tutorial Slide Shows&lt;/a&gt;&lt;br&gt; &lt;br&gt;    &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;http://webchat.freenode.net/?channels=%23leo&amp;uio=d4&quot;&gt; &lt;br&gt;   #leo IRC&lt;/a&gt;&lt;br&gt; &lt;br&gt;  &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;http://groups.google.com/group/leo-editor&quot;&gt; &lt;br&gt;   leo-editor: Google Groups&lt;/a&gt;&lt;br&gt; &lt;br&gt;    &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;https://github.com/leo-editor&quot;&gt; &lt;br&gt;   leo-editor: GitHub&lt;/a&gt;&lt;br&gt; &lt;br&gt;    &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;https://github.com/leo-editor/snippets&quot;&gt; &lt;br&gt;   leo-editor: Code Snippets&lt;/a&gt;&lt;br&gt; &lt;br&gt;  &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;https://github.com/leo-editor/leo-editor/issues&quot;&gt; &lt;br&gt;   Report a bug&lt;/a&gt;&lt;br&gt; &lt;br&gt;    &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;http://leo.zwiki.org&quot;&gt; &lt;br&gt;   Leo&amp;#8217;s Wiki&lt;/a&gt;&lt;br&gt; &lt;br&gt;    &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;http://leo-editor.readthedocs.org/en/latest/&quot;&gt; &lt;br&gt;   Leo&amp;#8217;s API documentation&lt;/a&gt;&lt;br&gt; &lt;br&gt;    &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;http://www.mind-mapping.org/&quot;&gt; &lt;br&gt;   Mind Mapping&lt;/a&gt;&lt;br&gt; &lt;br&gt;  &lt;br&gt; &lt;a class=&quot;reference external&quot; href=&quot;leoLinks.html&quot;&gt; &lt;br&gt;   More links...&lt;/a&gt;&lt;br&gt; &lt;br&gt;    &lt;br&gt; &lt;/p&gt; &lt;br&gt; &lt;p&gt; &lt;br&gt; &lt;div id=&quot;searchbox&quot; style=&quot;&quot;&gt; &lt;br&gt;   &lt;h3&gt;Search&lt;/h3&gt; &lt;br&gt;     &lt;input id='q' type=&quot;text&quot; name=&quot;q&quot; onkeypress=&quot;search(event)&quot;&gt; &lt;br&gt;   &lt;div&gt;&lt;button onclick=&quot;search(null)&quot;&gt;Google search&lt;/button&gt;&lt;/div&gt; &lt;br&gt;   &lt;div class=&quot;searchtip&quot; style=&quot;font-size: 90%&quot;&gt; &lt;br&gt;     Use quotes for &quot;@file&quot; and similar symbols. &lt;br&gt;   &lt;/div&gt; &lt;br&gt; &lt;/div&gt; &lt;br&gt; &lt;/p&gt; &lt;br&gt;  &lt;br&gt; &lt;p&gt;Leo: Leonine Editor with Outlines&lt;/p&gt; &lt;br&gt;  &lt;br&gt; &lt;p&gt;Written by &lt;a HREF=&quot;ekr.html&quot;&gt;Edward K. Ream&lt;/a&gt; &lt;br&gt; &lt;&lt; flattr icon &gt;&gt; &lt;br&gt; &lt;/p&gt; &lt;br&gt; " id="431" linkTypes="3" links="866" title="&lt;&lt; sidebar contents &gt;&gt; (home page)" />
<node body="" id="432" linkTypes="3 3 3" links="867 868 869" title="Next" />
<node body="" id="433" linkTypes="3 3 3 3 3 3 3 3 3" links="870 871 872 873 874 875 876 877 878" title="Maybe" />
<node body=".. _`Download Python`: http://www.python.org/download/ &lt;br&gt; .. _`packaged version`: https://sourceforge.net/projects/leo/files/Leo/ &lt;br&gt; .. _`Leo's download page`: https://sourceforge.net/projects/leo/files/Leo/ &lt;br&gt; .. _`next slide`: slide-002.html &lt;br&gt;  &lt;br&gt; **Installing on Windows: using Leo's single-click installer**  &lt;br&gt;  &lt;br&gt; 1. Install Python: `Download Python`_, save to your desktop, then &lt;br&gt;    double-click on the saved file. &lt;br&gt;  &lt;br&gt;    Python is software for creating and running computer programs. &lt;br&gt;    Leo requires Python 2.6 or later, or Python 3.0 or later. &lt;br&gt;  &lt;br&gt; 2. Install Qt. Get the binary package of PyQt from:  &lt;br&gt;    http://www.riverbankcomputing.co.uk/software/pyqt/download &lt;br&gt;  &lt;br&gt;    The version of PyQt that you download must match the version of your Python. &lt;br&gt;  &lt;br&gt; 3. Download the latest Leo installer from `Leo's download page`_. &lt;br&gt;    It will be called something like LeoSetup-&lt;version&gt;.exe &lt;br&gt;  &lt;br&gt; 4. Run the installer. &lt;br&gt;  &lt;br&gt; **Installing Leo from Linux packages** &lt;br&gt;  &lt;br&gt; Linux users are best served by the `packaged version`_ available at &lt;br&gt; SourceForge. You can also install Leo manually, as discussed in the &lt;br&gt; `next slide`_. &lt;br&gt;  &lt;br&gt; **Installing Leo from sources** &lt;br&gt;  &lt;br&gt; See the `next slide`_. &lt;br&gt; " id="434" linkTypes="3" links="879" title="@slide Overview" />
<node body=".. _`Download Python`: http://www.python.org/download/ &lt;br&gt; .. _`Leo's download page`: https://sourceforge.net/projects/leo/files/Leo/ &lt;br&gt;  &lt;br&gt; **Installing Leo from sources** &lt;br&gt;  &lt;br&gt; 1. Install Python: `Download Python`_, save to your desktop, then &lt;br&gt;    double-click on the saved file. &lt;br&gt;  &lt;br&gt;    Leo requires Python 2.6 or later, or Python 3.0 or later. &lt;br&gt;  &lt;br&gt; 2. Install Qt. Get PyQt from:  &lt;br&gt;    http://www.riverbankcomputing.co.uk/software/pyqt/download &lt;br&gt;  &lt;br&gt;    The version of PyQt that you download must match the version of your Python. &lt;br&gt;  &lt;br&gt; 3. Install Leo: Download the most recent .zip file from `Leo's &lt;br&gt;    download page`_ to your desktop or other location. Unzip the .zip &lt;br&gt;    file to the folder of your choice. &lt;br&gt; " id="435" linkTypes="3" links="880" title="@slide Installing Leo from sources" />
<node body="**Running Leo from a console** &lt;br&gt;  &lt;br&gt; To run Leo directly from a console, do the following: &lt;br&gt;  &lt;br&gt; 1. Go to the Leo directory:: &lt;br&gt;  &lt;br&gt;     cd &lt;path-to-leo-directory&gt; &lt;br&gt;  &lt;br&gt; 2. Start launchLeo.py using Python:: &lt;br&gt;  &lt;br&gt;     python launchLeo.py %* &lt;br&gt;  &lt;br&gt; " id="436" linkTypes="3" links="881" title="@slide Running Leo from a console" />
<node body="Using shell scripts (Linux) or .bat files (Windows) &lt;br&gt; can make it easier to open Leo files. &lt;br&gt;  &lt;br&gt; **Linux** &lt;br&gt;  &lt;br&gt; Put this in a shell script called leo:: &lt;br&gt;  &lt;br&gt;     #!/bin/sh  &lt;br&gt;     python &lt;path-to-leo-directory&gt;launchLeo.py $1 &lt;br&gt;  &lt;br&gt; **Windows** &lt;br&gt;  &lt;br&gt; Put this in leo.bat:: &lt;br&gt;  &lt;br&gt;     cd &lt;path-to-leo-folder&gt; &lt;br&gt;     python &lt;path-to-leo-folder&gt;launchLeo.py %* &lt;br&gt;  &lt;br&gt; On either platform, the following will open x.leo:: &lt;br&gt;  &lt;br&gt;     leo x.leo &lt;br&gt; " id="437" linkTypes="3" links="882" title="@slide Scripts &amp; .bat files" />
<node body="The first time you start Leo, a dialog will ask you for a unique &lt;br&gt; identifier. This string helps ensure that each Leo node has a &lt;br&gt; unique identity. &lt;br&gt;  &lt;br&gt; This identifier can be any string 3 characters or more in length. &lt;br&gt; In a shared environment, a cvs or bzr login name works well. &lt;br&gt;  &lt;br&gt; Pick a string you don't mind making public: it will appear in &lt;br&gt; files that Leo creates. &lt;br&gt;  &lt;br&gt; Leo stores this identifier in the file ~/.leo/.leoID.txt. &lt;br&gt; You can change this identifier at any time by editing .leoID.txt. &lt;br&gt; " id="438" linkTypes="3" links="883" title="@slide Setting .leoID.txt" />
<node body=".. _`Edward K. Ream`:   ekr.html &lt;br&gt; .. _`leo-editor`:       http://groups.google.com/group/leo-editor &lt;br&gt; .. _`Python Tutorial`:  http://docs.python.org/tutorial/ &lt;br&gt;  &lt;br&gt; Leo is a free program distributed under the MIT license. This means that not &lt;br&gt; only can you use the program freely including commercially, the full &lt;br&gt; installation comes with source code that you can modify as you wish, as long as &lt;br&gt; you give credit to the author of the program, `Edward K. Ream`_. &lt;br&gt;  &lt;br&gt; Leo is written in Python--a full featured, powerful programming language that &lt;br&gt; is comparatively easy to learn and use. For an excellent introduction to Python &lt;br&gt; for non-programmers, see the `Python Tutorial`_. Not only is Leo written in Python, it is &lt;br&gt; scriptable via Python, meaning that you can embed Python commands in your &lt;br&gt; outlines and execute them. &lt;br&gt;  &lt;br&gt; Leo is under active development and all are welcome to contribute. For more &lt;br&gt; information, see the `leo-editor`_ Google Group. &lt;br&gt;  &lt;br&gt; Not only is Leo free software, it is supported software. Post questions and bug &lt;br&gt; reports to the `leo-editor`_ Google Group. &lt;br&gt; " id="439" linkTypes="3" links="884" title="@slide Free software" />
<node body="@nocolor-node &lt;br&gt;  &lt;br&gt; The directory containing the wink screenshots. &lt;br&gt; This will usually be &lt;slideshow_dir&gt;/_files. &lt;br&gt;  &lt;br&gt; **Important** You generate these screenshots using Wink's  &lt;br&gt; Export As Html command (!) &lt;br&gt; " id="440" linkTypes="1" links="218" title="@wink_path = ../doc/html/slides/leo-basics-step-by-step/_files" />
<node body="This is a step-by-step introduction to show you &lt;br&gt; how to use Leo outlines. &lt;br&gt;  &lt;br&gt; " id="441" linkTypes="3 3" links="885 886" title="@slide ((no-slide" />
<node body=".. The workbook.leo window. &lt;br&gt;  &lt;br&gt; Leo opens the **workbook file** when you start &lt;br&gt; Leo without a filename. &lt;br&gt;  &lt;br&gt; The body has focus--it is colored a pale pink, and &lt;br&gt; contains a blinking cursor. &lt;br&gt;  &lt;br&gt; **Note**: on some monitors the colors will be almost &lt;br&gt; invisible.  You can choose pane colors to suit your &lt;br&gt; taste. &lt;br&gt;  &lt;br&gt; .. image:: slide-002.png &lt;br&gt;  &lt;br&gt; " id="442" linkTypes="3 3" links="887 888" title="@slide ((Open notebook file" />
<node body="Ctrl-H edits the presently selected headline. &lt;br&gt;  &lt;br&gt; You can type Ctrl-H at any time, regardless of &lt;br&gt; where the focus is. &lt;br&gt;  &lt;br&gt; The body pane is now blue, indicating that it no &lt;br&gt; longer has focus. &lt;br&gt;  &lt;br&gt; .. image:: slide-003.png &lt;br&gt;  &lt;br&gt; " id="443" linkTypes="3 3" links="889 890" title="@slide ((Ctrl-H edits headline" />
<node body="I typed &quot;to do&quot; in the headline. &lt;br&gt;  &lt;br&gt; .. image:: slide-004.png &lt;br&gt;  &lt;br&gt; " id="444" linkTypes="3 3" links="891 892" title="@slide ((&quot;to do&quot; node" />
<node body="Typing the &lt;return&gt; key ends editing of the headline &lt;br&gt; and puts focus back in the body pane. &lt;br&gt;  &lt;br&gt; Notice that the **icon box** to the left of the &lt;br&gt; headline now has a darker outline that it had &lt;br&gt; before. This indicates that the contents of the &lt;br&gt; node has been changed. We say the node is &lt;br&gt; **dirty**. &lt;br&gt;  &lt;br&gt; .. image:: slide-005.png &lt;br&gt;  &lt;br&gt; " id="445" linkTypes="3 3" links="893 894" title="@slide ((Return ends editing" />
<node body="You can use Leo without ever using the mouse. For &lt;br&gt; instance, you can select any Leo pane by using &lt;br&gt; keystrokes instead of clicking the pane: &lt;br&gt;  &lt;br&gt; - Regardless of where the focus is, Alt-D puts &lt;br&gt;   focus in the body pane and Alt-T puts focus in &lt;br&gt;   the outline pane. &lt;br&gt;  &lt;br&gt; - With the focus in the tree pane, hitting the &lt;br&gt;   &lt;return&gt; key puts the focus in the body pane. &lt;br&gt;  &lt;br&gt; " id="446" linkTypes="3 3" links="895 896" title="@slide ((no-slide focus keys" />
<node body="Ctrl-S saves the outline. &lt;br&gt;  &lt;br&gt; Notice that the icon box once again has a gray outline, &lt;br&gt; indicating that the node has not been changed since &lt;br&gt; the file was last saved. &lt;br&gt;  &lt;br&gt; .. Arrow to icon box. &lt;br&gt;  &lt;br&gt; .. image:: slide-007.png &lt;br&gt;  &lt;br&gt; " id="447" linkTypes="3 3" links="897 898" title="@slide ((Ctrl-S saves outline" />
<node body="Ctrl-I inserts a new node. &lt;br&gt;  &lt;br&gt; .. image:: slide-008.png &lt;br&gt;  &lt;br&gt; " id="448" linkTypes="3 3" links="899 900" title="@slide ((Ctrl-I inserts a new node" />
<node body="I typed &quot;go shopping&quot; followed by a return. &lt;br&gt;  &lt;br&gt; The focus is now in the body pane. &lt;br&gt;  &lt;br&gt; .. image:: slide-009.png &lt;br&gt;  &lt;br&gt; " id="449" linkTypes="3 3" links="901 902" title="@slide ((&quot;go shopping&quot;" />
<node body="Whatever I type will appear in the body pane. &lt;br&gt;  &lt;br&gt; I added a shopping list. &lt;br&gt;  &lt;br&gt; The blue square in the icon area indicates that the body pane contains text. &lt;br&gt;  &lt;br&gt; .. Arrow at icon box. &lt;br&gt;  &lt;br&gt; .. buy milk &lt;br&gt; .. buy eggs. &lt;br&gt;  &lt;br&gt; .. image:: slide-010.png &lt;br&gt;  &lt;br&gt; " id="450" linkTypes="3 3" links="903 904" title="@slide ((typing text (icon box has blue square)" />
<node body="Ctrl-R moves a node right. &lt;br&gt;  &lt;br&gt; The &quot;go shopping&quot; node becomes a **child** &lt;br&gt; of the &quot;to do&quot; node. &lt;br&gt;  &lt;br&gt; The &quot;to do&quot; node is the **parent** node. &lt;br&gt;  &lt;br&gt; .. image:: slide-011.png &lt;br&gt;  &lt;br&gt; " id="451" linkTypes="3 3" links="905 906" title="@slide ((Ctrl-R" />
<node body="Ctrl-L moves the &quot;go shopping&quot; node left. &lt;br&gt;  &lt;br&gt; The &quot;go shopping&quot; node becomes a **sibling** &lt;br&gt; of the &quot;to do&quot; node. &lt;br&gt;  &lt;br&gt; .. image:: slide-012.png &lt;br&gt;  &lt;br&gt; " id="452" linkTypes="3 3" links="907 908" title="@slide ((Ctrl-L" />
<node body="Leo has unlimited undo/redo capabilities. &lt;br&gt;  &lt;br&gt; Here, I typed Ctrl-Z to undo the previous move. &lt;br&gt; The &quot;go shopping&quot; node is once again a child of &lt;br&gt; the &quot;to do&quot; node. &lt;br&gt;  &lt;br&gt; **Note**: Ctrl-Shift-Z redoes a previous undo. &lt;br&gt;  &lt;br&gt; .. image:: slide-013.png &lt;br&gt;  &lt;br&gt; " id="453" linkTypes="3 3" links="909 910" title="@slide ((undo/redo" />
<node body="Let's add a new node.  I hit Ctrl-I. &lt;br&gt;  &lt;br&gt; .. image:: slide-014.png &lt;br&gt;  &lt;br&gt; " id="454" linkTypes="3 3" links="911 912" title="@slide ((new node" />
<node body="I type &quot;fix car&quot; followed by the &lt;return&gt; key. &lt;br&gt;  &lt;br&gt; .. image:: slide-015.png &lt;br&gt;  &lt;br&gt; " id="455" linkTypes="3 3" links="913 914" title="@slide ((&quot;fix car&quot;" />
<node body="I decide that fixing the car should have first priority. &lt;br&gt;  &lt;br&gt; I type Ctrl-U to move the &quot;fix car&quot; node up. &lt;br&gt; It becomes the first child of the &quot;to do&quot; node. &lt;br&gt;  &lt;br&gt; .. image:: slide-016.png &lt;br&gt;  &lt;br&gt; " id="456" linkTypes="3 3" links="915 916" title="@slide ((Ctrl-U" />
<node body="After creating the to-do list, I want to hide it &lt;br&gt; by **collapsing** the &quot;to do&quot; node. &lt;br&gt;  &lt;br&gt; I could do that by clicking the black triangle &lt;br&gt; to the left of the &quot;to do&quot; node. &lt;br&gt;  &lt;br&gt; However, using the mouse is not recommended-- &lt;br&gt; there are much easier ways. &lt;br&gt;  &lt;br&gt; .. arrow points to black triangle. &lt;br&gt;  &lt;br&gt; .. image:: slide-017.png &lt;br&gt;  &lt;br&gt; " id="457" linkTypes="3 3" links="917 918" title="@slide ((contracting nodes" />
<node body="The focus is in the tree pane, so I can select the &quot;to do&quot; &lt;br&gt; node merely by using the Up-Arrow key. &lt;br&gt;  &lt;br&gt; If, for some reason, the focus is in the body pane, &lt;br&gt; I can select the previous node in either of two ways: &lt;br&gt;  &lt;br&gt; 1. Type Alt-T to put focus in the tree pane &lt;br&gt;    followed by the Up-Arrow key. &lt;br&gt;  &lt;br&gt; 2. Type Alt-Up-Arrow.  This selects the previous &lt;br&gt;    node and also puts focus in the tree pane. &lt;br&gt;  &lt;br&gt; Now the &quot;to do&quot; node is selected. &lt;br&gt;  &lt;br&gt; .. image:: slide-018.png &lt;br&gt;  &lt;br&gt; " id="458" linkTypes="3 3" links="919 920" title="@slide ((Up-Arrow" />
<node body="With the &quot;to-do&quot; node selected, &lt;br&gt; hitting the Left-Arrow key will contract the node. &lt;br&gt;  &lt;br&gt; .. &quot;to do&quot; contracted. &lt;br&gt;  &lt;br&gt; .. image:: slide-019.png &lt;br&gt;  &lt;br&gt; " id="459" linkTypes="3 3" links="921 922" title="@slide ((Left-Arrow" />
<node body="To expand the &quot;to do&quot; node, &lt;br&gt; I merely hit the Right-Arrow key. &lt;br&gt;  &lt;br&gt; We can now see the entire to-do list. &lt;br&gt;  &lt;br&gt; .. image:: slide-020.png &lt;br&gt;  &lt;br&gt; " id="460" linkTypes="3 3" links="923 924" title="@slide ((20 Right-Arrow" />
<node body="The arrow keys do different things depending on &lt;br&gt; which pane has focus. Using arrow keys is **much** &lt;br&gt; easier than using the mouse. &lt;br&gt;  &lt;br&gt; **Focus in outline pane** &lt;br&gt;  &lt;br&gt;     The **plain** arrow keys **select** nodes, &lt;br&gt;     expanding or contracting nodes as needed. &lt;br&gt;  &lt;br&gt;     The **shift** arrow keys **move** nodes. The &lt;br&gt;     Shift-Left-Arrow and Shift-Up-Arrow contract &lt;br&gt;     nodes as needed. **Note**: the &lt;br&gt;     Shift-Down-Arrow and Shift-Right-Arrow keys &lt;br&gt;     never expand nodes. &lt;br&gt;  &lt;br&gt; **Focus in body pane** &lt;br&gt;  &lt;br&gt;     As usual, the **plain** arrow keys move the &lt;br&gt;     cursor and the **shift** arrow keys move the &lt;br&gt;     cursor and extend the solution. &lt;br&gt;  &lt;br&gt;     The **alt** arrow keys move the focus to the &lt;br&gt;     outline pane and then select nodes. The &lt;br&gt;     **alt-shift** arrow keys move the focus to the &lt;br&gt;     outline pane and then move nodes. &lt;br&gt;  &lt;br&gt; ..  - The Up-Arrow and Down-Arrow keys select &lt;br&gt; ..  the previous or next visible nodes. &lt;br&gt;  &lt;br&gt; ..  - The Right-Arrow key contracts a node if the node &lt;br&gt; ..  is expanded. Otherwise the Right-Arrow key &lt;br&gt; ..  selects the node's parent. &lt;br&gt;  &lt;br&gt; ..  - The Left-Arrow key does nothing if the selected &lt;br&gt; ..  node has no children.  If the node does have &lt;br&gt; ..  children, the Left-Arrow key expands the node &lt;br&gt; ..  (if the children or invisible) or selects the &lt;br&gt; ..  first child (if the children are visible). &lt;br&gt;  &lt;br&gt; ..  This is exactly how Windows explorer works, and &lt;br&gt; ..  it quickly becomes second nature. &lt;br&gt;  &lt;br&gt; " id="461" linkTypes="3 3" links="925 926" title="@slide ((no-slide Arrow keys: summary" />
<node body="We can copy and paste nodes and all their descendants. &lt;br&gt;  &lt;br&gt; Using the arrow keys as necessary, I select the &lt;br&gt; &quot;to do&quot; node. &lt;br&gt;  &lt;br&gt; The Shift-Ctrl-C key copies the selected outline. &lt;br&gt;  &lt;br&gt; I want to do the paste *after* the to-do list, so I collapse &lt;br&gt; the original node before doing the paste: &lt;br&gt;  &lt;br&gt; .. image:: slide-022.png &lt;br&gt;  &lt;br&gt; " id="462" linkTypes="3 3" links="927 928" title="@slide ((Shift-Ctrl-C copies" />
<node body="And here is the pasted node. &lt;br&gt;  &lt;br&gt; .. image:: slide-023.png &lt;br&gt;  &lt;br&gt; " id="463" linkTypes="3 3" links="929 930" title="@slide ((The pasted node" />
<node body="Expanding the node shows that the copy operation &lt;br&gt; copied the node and all its descendants. &lt;br&gt;  &lt;br&gt; .. image:: slide-024.png &lt;br&gt;  &lt;br&gt; " id="464" linkTypes="3 3" links="931 932" title="@slide ((expanding the pasted node" />
<node body="This concludes the step-by-step introduction to &lt;br&gt; Leo's outlines. &lt;br&gt;  &lt;br&gt; You now know how to do the following: &lt;br&gt;  &lt;br&gt; - Create new nodes. &lt;br&gt; - Edit the headline and body text of any node. &lt;br&gt; - Reorganize nodes.  &lt;br&gt; - Expand and contract nodes. &lt;br&gt; - Copy and paste nodes and their descendants. &lt;br&gt;  &lt;br&gt; Mastering these skills is essential to using Leo &lt;br&gt; effectively and enjoyably. &lt;br&gt;  &lt;br&gt; " id="465" linkTypes="3 3" links="933 934" title="@slide ((no-slide end slide" />
<node body="For me, scripting is the most fun part of Leo. &lt;br&gt;  &lt;br&gt; Leo can execute any body text as a **Leo script**, &lt;br&gt; Python scripts that have full access to all data &lt;br&gt; in any open Leo outline, as well as full access to &lt;br&gt; all parts of Leo's source code. &lt;br&gt;  &lt;br&gt; Leo's Ctrl-B (execute-script) command runs the &lt;br&gt; body text of a node as a Leo script. &lt;br&gt; " id="466" linkTypes="3" links="935" title="@slide Introduction" />
<node body=".. _`Scripting Chapter`: scripting.html &lt;br&gt; .. _`Leo's Users Guide`: leo_toc.html &lt;br&gt;  &lt;br&gt; Leo scripts execute in an environment containing &lt;br&gt; three predefined objects: c, g and p. &lt;br&gt;  &lt;br&gt; **g** is Leo's leoGlobals module. This module &lt;br&gt; contains several dozen utility functions and &lt;br&gt; classes. &lt;br&gt;  &lt;br&gt; **c** is the **commander** of the outline &lt;br&gt; containing the script. Commanders defined &lt;br&gt; all of Leo's commands, as well as other data. &lt;br&gt;  &lt;br&gt; **p** is the **position** of the presently &lt;br&gt; selected node. Positions represent positions &lt;br&gt; in the traversal of Leo outlines. &lt;br&gt;  &lt;br&gt; This slide give a few examples of how to use &lt;br&gt; c, g and p in Leo scripts. For full details &lt;br&gt; about scripting in Leo, see the `Scripting Chapter`_ &lt;br&gt; in `Leo's Users Guide`_. &lt;br&gt; " id="467" linkTypes="3" links="936" title="@slide c, g and p" />
<node body="The c, g and p objects give Leo scripts access to &lt;br&gt; all parts of Leo and Leo outlines. There are many &lt;br&gt; **official ivars** (instance variables) that &lt;br&gt; scripts may use. Here are a few: &lt;br&gt;  &lt;br&gt; **c.frame** is the frame representing the actual &lt;br&gt; parts of Leo screen. For any frame, **frame.c** is &lt;br&gt; the frame's commander, so c.frame.c is always c. &lt;br&gt;  &lt;br&gt; **g.app** is the **application object** &lt;br&gt; representing the entire Leo application. The ivars &lt;br&gt; of g.app represent Leo's global variables. &lt;br&gt;  &lt;br&gt; **p.v** is the **vnode** at position p. A vnode &lt;br&gt; represents an outline node. Vnodes hold most of &lt;br&gt; the data in Leo outlines. For any vnode v, v.h is &lt;br&gt; the node's headline, and v.b is the node's body &lt;br&gt; text. As a convenience, for any position p, p.h &lt;br&gt; and p.b are synonyms for p.v.h and p.v.b. &lt;br&gt; **Important**: because of clones, a vnode may &lt;br&gt; appear in several positions in a traversal. &lt;br&gt; " id="468" linkTypes="3" links="937" title="@slide Official ivars" />
<node body="g.es is a function that prints its arguments to Leo's log pane. &lt;br&gt;  &lt;br&gt; Here is the hello world program as a Leo script:: &lt;br&gt;  &lt;br&gt;     g.es('Hello world!') &lt;br&gt;  &lt;br&gt; Leo scripts may also use Python's print command &lt;br&gt; provided that Leo is running in a console. &lt;br&gt; " id="469" linkTypes="3" links="938" title="@slide Hello world" />
<node body=".. _`Python properties`: http://docs.python.org/library/functions.html &lt;br&gt;  &lt;br&gt; Given any position p, **p.h** is the headline text &lt;br&gt; of p.v, and **p.b** is the body text of p.v. &lt;br&gt;  &lt;br&gt; p.h and p.b are `Python properties`_, which means &lt;br&gt; you can set the headline and body text by &lt;br&gt; assigning to them:: &lt;br&gt;  &lt;br&gt;     p.h = p.h + ' more' &lt;br&gt;  &lt;br&gt; In order to see the result of changing a headline, &lt;br&gt; Leo scripts must redraw the outline pane, like this:: &lt;br&gt;  &lt;br&gt;     c.redraw() &lt;br&gt; " id="470" linkTypes="3" links="939" title="@slide p.h and p.b" />
<node body=".. _`Python iterator`: http://docs.python.org/library/stdtypes.html#iterator-types &lt;br&gt;  &lt;br&gt; Commanders and positions define `Python &lt;br&gt; iterators`_ that return lists of positions in Leo &lt;br&gt; outlines. These iterators are the easiest way of &lt;br&gt; gaining access to the nodes of Leo outlines. Here &lt;br&gt; are few examples (there are many more): &lt;br&gt;  &lt;br&gt; - **c.all_positions()** returns all the positions &lt;br&gt;   of the outline in order. Cloned nodes will &lt;br&gt;   appear several times in this list. &lt;br&gt;  &lt;br&gt; - **c.all_unique_nodes()** returns all the vnodes &lt;br&gt;   of the outline. &lt;br&gt;  &lt;br&gt; - **p.self_and_subtree()** returns p and all its &lt;br&gt;   descendant positions. &lt;br&gt;  &lt;br&gt; - **p.children()** returns all the positions of &lt;br&gt;   all p's direct children. &lt;br&gt; " id="471" linkTypes="3" links="940" title="@slide Iterators" />
<node body="Using iterators, it is easy to gain access to all &lt;br&gt; the data in a Leo outline. For example, the &lt;br&gt; following script prints all headlines in an &lt;br&gt; outline, indented to show outline level:: &lt;br&gt;  &lt;br&gt;     for p in c.all_positions(): &lt;br&gt;         g.es(' '*p.level(),p.h) &lt;br&gt;  &lt;br&gt; The output of this script, when run from LeoDocs.leo, &lt;br&gt; will look something like this:: &lt;br&gt;  &lt;br&gt;     Startup &lt;br&gt;      @file doc-startup.txt &lt;br&gt;       Buttons &lt;br&gt;        Disabled buttons &lt;br&gt;        ... and hundreds of other nodes. &lt;br&gt;  &lt;br&gt; **Note**: p.level() is a method of the position &lt;br&gt; class that returns the outline level of the node &lt;br&gt; at position p: 0 for top-level nodes, 1 for their &lt;br&gt; children, and so on. &lt;br&gt; " id="472" linkTypes="3" links="941" title="@slide Using iterators" />
<node body="Leo scripts can be composed of more than one node, &lt;br&gt; just as external files are organized. The Execute &lt;br&gt; Script command **preprocesses** the script before &lt;br&gt; executing it, by expanding section references and &lt;br&gt; \@others directives &lt;br&gt;  &lt;br&gt; For example, I organize my complex script as follows. &lt;br&gt; I create a top-level node containing just:: &lt;br&gt;  &lt;br&gt;     '''docstring''' &lt;br&gt;     @others &lt;br&gt;     controller(c).run() &lt;br&gt;  &lt;br&gt; A child node will contain the following:: &lt;br&gt;  &lt;br&gt;     class controller: &lt;br&gt;         def __init__(self,c): &lt;br&gt;             self.c = c &lt;br&gt;         @others &lt;br&gt;  &lt;br&gt; And the children of the top-level class node will &lt;br&gt; contain all the methods of the controller class. &lt;br&gt; This organization is simple, flexible and powerful. &lt;br&gt; " id="473" linkTypes="3" links="942" title="@slide Building scripts from outlines" />
<node body="The c and g constants give you access to all of &lt;br&gt; Leo's source code. Here, we'll discuss just two of &lt;br&gt; them. There are hundreds more you can use. &lt;br&gt;  &lt;br&gt; **g.openWithFileName** opens a .leo file.  For example:: &lt;br&gt;  &lt;br&gt;     ok, frame = g.openWithFileName(fileName,c) &lt;br&gt;     new_c = frame.c &lt;br&gt;  &lt;br&gt; The return frame value represents the frame of the visual &lt;br&gt; outline.  frame.c is the frame's commander, so new_c is &lt;br&gt; the commander of the newly-created outline. &lt;br&gt;  &lt;br&gt; " id="474" linkTypes="3 3" links="943 944" title="@slide g.openWithFileName" />
<node body=".. _`Python debugger`: http://docs.python.org/library/pdb.html &lt;br&gt; .. _`Pudb debugger`: http://pypi.python.org/pypi/pudb &lt;br&gt;  &lt;br&gt; **g.pdb** opens pdb, the `Python debugger`_.  To use this, &lt;br&gt; you must be running Leo from a console. &lt;br&gt;  &lt;br&gt; The pudb plugin changes g.pdb so that it uses the &lt;br&gt; full-screen `Pudb debugger`_ instead of pdb. &lt;br&gt; " id="475" linkTypes="3 3" links="945 946" title="@slide g.pdb" />
<node body=".. _`Scripting Chapter`: scripting.html &lt;br&gt; .. _`Leo's Users Guide`: leo_toc.html &lt;br&gt;  &lt;br&gt; This concludes our brief introduction to scripting in Leo. &lt;br&gt;  &lt;br&gt; For full details about scripting in Leo, see the &lt;br&gt; `Scripting Chapter`_ in `Leo's Users Guide`_. &lt;br&gt; " id="476" linkTypes="3" links="947" title="@slide Further reading" />
<node body="" id="477" linkTypes="1" links="220" title="@wink_path = ../doc/html/slides/using-leos-minibuffer/_files" />
<node body="Leo's **minibuffer** appears at the bottom of Leo's main window. &lt;br&gt;  &lt;br&gt; You use the minibuffer to execute commands by name, and also &lt;br&gt; to accumulate arguments to commands. &lt;br&gt;  &lt;br&gt; Type &lt;Alt-x&gt; to put the cursor in the minibuffer. &lt;br&gt;  &lt;br&gt; .. sc 1: cursor in the minibuffer &lt;br&gt;  &lt;br&gt; .. image:: slide-001.png &lt;br&gt;  &lt;br&gt; " id="478" linkTypes="3 3" links="948 949" title="@slide Introduction" />
<node body="You could type the full command name in the minibuffer, &lt;br&gt; followed by the &lt;return&gt; key to invoke the command, &lt;br&gt; but that would be **way** too much work. &lt;br&gt;  &lt;br&gt; Instead, you can use **tab completion** to avoid having to &lt;br&gt; do much typing. With tab completion, there is no need to &lt;br&gt; remember the exact names of Leo's commands. &lt;br&gt;  &lt;br&gt; .. no screenshot &lt;br&gt; " id="479" linkTypes="3" links="950" title="@slide Tab completion" />
<node body="For example, suppose you want to print out the list of Leo's &lt;br&gt; commands. You might remember only that there are several &lt;br&gt; related commands and that they all start with &quot;print&quot;. &lt;br&gt; Just type:: &lt;br&gt;  &lt;br&gt;     &lt;alt-x&gt;pri&lt;tab&gt; &lt;br&gt;  &lt;br&gt; You will see &quot;print-&quot; in the minibuffer. &lt;br&gt; The **Completion tab** in the log pane shows &lt;br&gt; all the commands that start with &quot;print-&quot;. &lt;br&gt;  &lt;br&gt; .. sc 2: The Completion tab contains print- items &lt;br&gt;  &lt;br&gt; .. image:: slide-003.png &lt;br&gt;  &lt;br&gt; " id="480" linkTypes="3 3" links="951 952" title="@slide Example" />
<node body="Now just type &quot;c&lt;tab&gt;&quot; and you will see one the single &lt;br&gt; print-commands command in the minibuffer. Finally, type &lt;br&gt; &lt;return&gt; to execute the command. &lt;br&gt;  &lt;br&gt; .. sc 3:  Only the print-commands command in the Completion tab. &lt;br&gt;  &lt;br&gt; .. image:: slide-004.png &lt;br&gt;  &lt;br&gt; " id="481" linkTypes="3 3" links="953 954" title="@slide Example, continued" />
<node body="You will see the output of the print-commands command &lt;br&gt; in the commands tab, and focus returns to the body pane. &lt;br&gt;  &lt;br&gt; .. sc 4: show the Commands tab. &lt;br&gt;  &lt;br&gt; .. image:: slide-005.png &lt;br&gt;  &lt;br&gt; " id="482" linkTypes="3 3" links="955 956" title="@slide Example, concluded" />
<node body="Using the minibuffer quickly becomes second nature. When in &lt;br&gt; doubt about what the valid completions are, you simply hit &lt;br&gt; the &lt;tab&gt; key. &lt;br&gt;  &lt;br&gt; Here are a few more details you should know about: &lt;br&gt;  &lt;br&gt; - You can use &lt;BackSpace&gt; in the minibuffer to show more &lt;br&gt;   alternatives. &lt;br&gt;  &lt;br&gt; - You can hit &lt;Ctrl-G&gt; at any time in Leo to put focus in &lt;br&gt;   the body pane.  This is the way to exit the minibuffer &lt;br&gt;   without executing any command. &lt;br&gt;  &lt;br&gt; .. no screenshot &lt;br&gt; " id="483" linkTypes="3" links="957" title="@slide Details" />
<node body="Several of Leo's commands use the minibuffer to get arguments. &lt;br&gt;  &lt;br&gt; For example, Leo's find command accumulates the search and &lt;br&gt; replace strings in the minibuffer. &lt;br&gt;  &lt;br&gt; To invoke the find command, type &lt;Ctrl-F&gt;. This puts the &lt;br&gt; focus in the minibuffer and shows the Find tab. &lt;br&gt; **Important**: the Find tab just shows you the status of &lt;br&gt; search and replace operations. You control those operations &lt;br&gt; from the minibuffer. &lt;br&gt;  &lt;br&gt; .. sc 5  (missing the cursor) &lt;br&gt;  &lt;br&gt; .. image:: slide-007.png &lt;br&gt;  &lt;br&gt; " id="484" linkTypes="3 3" links="958 959" title="@slide Arguments" />
<node body="Now type the search string, say &quot;def&quot;. &lt;br&gt;  &lt;br&gt; .. sc 6: searching for &quot;def&quot;. &lt;br&gt;  &lt;br&gt; .. image:: slide-008.png &lt;br&gt;  &lt;br&gt; " id="485" linkTypes="3 3" links="960 961" title="@slide Search string" />
<node body="You can invoke the find by typing &lt;return&gt;. &lt;br&gt;  &lt;br&gt; However, suppose you want to replace &quot;def&quot; with &quot;foo&quot;. &lt;br&gt;  &lt;br&gt; Type &lt;Shift-Ctrl-R&gt;. The minibuffer prompts for the replacement string. &lt;br&gt; Notice that the status area now shows &quot;def&quot; as the Find string. &lt;br&gt;  &lt;br&gt; .. sc 7: Replace String: def With: &lt;br&gt;  &lt;br&gt; .. image:: slide-009.png &lt;br&gt;  &lt;br&gt; " id="486" linkTypes="3 3" links="962 963" title="@slide Replace string" />
<node body="Type &quot;foo&quot; and hit return to start the find-next command. &lt;br&gt;  &lt;br&gt; .. sc 8 show &quot;def&quot; selected. &lt;br&gt;  &lt;br&gt; .. image:: slide-010.png &lt;br&gt;  &lt;br&gt; " id="487" linkTypes="3 3" links="964 965" title="@slide Doing the find" />
<node body="Here, Leo has found the next instance of &quot;def&quot; in the body pane. &lt;br&gt;  &lt;br&gt; - To make the replacement, hit &lt;Ctrl-minus&gt;. &lt;br&gt;  &lt;br&gt; - To continue searching without making a replacement, hit &lt;F3&gt;. &lt;br&gt;  &lt;br&gt; - To end the search, hit &lt;Ctrl-G&gt;. &lt;br&gt;  &lt;br&gt; This concludes the discussion of the minibuffer. &lt;br&gt;  &lt;br&gt; .. image:: slide-011.png &lt;br&gt; " id="488" linkTypes="3 3" links="966 967" title="@slide Doing the replace" />
<node body="" id="489" linkTypes="1" links="221" title="@wink_path ../doc/html/slides/clones-and-views/sc_files" />
<node body="Clones are one of Leo's most unusual and most useful features. &lt;br&gt;  &lt;br&gt; A **clone** is a node that appears in more than one place in a Leo outline. &lt;br&gt;  &lt;br&gt; Here, we have cloned node A by selecting A and doing Ctrl=` (clone-node) &lt;br&gt;  &lt;br&gt; Clones are marked with a small red *clone arrow** in the icon box. &lt;br&gt; Deleting the penultimate clone removes the red arrow from the node. &lt;br&gt;  &lt;br&gt; .. sc 1: Clone of A. &lt;br&gt;  &lt;br&gt; .. image:: slide-001.png &lt;br&gt;  &lt;br&gt; " id="490" linkTypes="3 3" links="968 969" title="@slide Clones and views" />
<node body="Changing the headline or body text of a clone changes the headline or body &lt;br&gt; text of all other clones of that node. Furthermore, changing any descendants &lt;br&gt; of a clone, including inserting, deleting or moving nodes, results in the &lt;br&gt; same changes being made to all other clones. &lt;br&gt;  &lt;br&gt; In fact, all clones of a node are actually *the exactly the same node*, so &lt;br&gt; any change to one clone inevitably affects all other clones. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="491" linkTypes="3 3" links="970 971" title="@slide Clones are the same node" />
<node body="Changing the headline of node A changes the headlines of all cloned nodes. &lt;br&gt;  &lt;br&gt; .. sc 2: Rename the node to B. &lt;br&gt;  &lt;br&gt; .. image:: slide-003.png &lt;br&gt;  &lt;br&gt; " id="492" linkTypes="3 3" links="972 973" title="@slide Changing headlines" />
<node body="Here we have created a node C following the first clone of B. &lt;br&gt;  &lt;br&gt; .. sc 3: Create node C &lt;br&gt;  &lt;br&gt; .. image:: slide-004.png &lt;br&gt;  &lt;br&gt; " id="493" linkTypes="3 3" links="974 975" title="@slide A new node" />
<node body="Moving C to the right makes C a child of node B. &lt;br&gt; As you can see, C appears as a child of both cloned nodes. &lt;br&gt;  &lt;br&gt; Even the expansion state of cloned nodes are identical: &lt;br&gt; both clones are now expanded. &lt;br&gt;  &lt;br&gt; .. sc 4: move C right. &lt;br&gt;  &lt;br&gt; .. image:: slide-005.png &lt;br&gt;  &lt;br&gt; " id="494" linkTypes="3 3" links="976 977" title="@slide Adding a child node" />
<node body="Here, I have created a new node D with Ctrl-I (insert-node). &lt;br&gt;  &lt;br&gt; The node appears as a child of both cloned nodes. &lt;br&gt;  &lt;br&gt; In general, **any** change to one clone produces the &lt;br&gt; corresponding change in all other clones. &lt;br&gt;  &lt;br&gt; .. sc 5: Insert node &lt;br&gt;  &lt;br&gt; .. image:: slide-006.png &lt;br&gt;  &lt;br&gt; " id="495" linkTypes="3 3" links="978 979" title="@slide Creating a new child" />
<node body="Changing a node marks all clones of that node as changed. &lt;br&gt; When I save the Leo outline, Leo automatically writes all &lt;br&gt; the external files that contain dirty nodes. &lt;br&gt;  &lt;br&gt; For example, the cloned spam node appears in two places. &lt;br&gt;  &lt;br&gt; .. sc 6: @file node is dirty &lt;br&gt;  &lt;br&gt; .. image:: slide-007.png &lt;br&gt;  &lt;br&gt; " id="496" linkTypes="3 3" links="980 981" title="@slide Keeping track of changes" />
<node body="Changing either clone marks both as changed and marks any &lt;br&gt; ancestor @file nodes as changed as well. &lt;br&gt;  &lt;br&gt; This ensures that saving the .leo file will also save all &lt;br&gt; changed external files. &lt;br&gt;  &lt;br&gt; .. sc 7: @file node is dirty &lt;br&gt;  &lt;br&gt; .. image:: slide-008.png &lt;br&gt;  &lt;br&gt; " id="497" linkTypes="3 3" links="982 983" title="@slide Keeping track of changes: 2" />
<node body="Clones are important because they allow you to create as &lt;br&gt; many views of the data in the outline as you like. In &lt;br&gt; effect, Leo becomes a supremely flexible filing cabinet. Any &lt;br&gt; ordinary node can act like a folder in the filing cabinet. &lt;br&gt; Using clones, you can &quot;file&quot; a node in as many folders as &lt;br&gt; you like. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="498" linkTypes="3 3" links="984 985" title="@slide Views" />
<node body="In Leo, a **view** is simply a subset of the nodes of the &lt;br&gt; outline. We represent a view as **ordinary** node, called a &lt;br&gt; **view node** (1). The children of the view node are the subset of &lt;br&gt; nodes that define the view. It's that simple. &lt;br&gt;  &lt;br&gt; With Leo, you can have as many view nodes as you like. There &lt;br&gt; is no such thing as a single, &quot;correct&quot; view of data. &lt;br&gt;  &lt;br&gt; .. sc 8: Ordinary node with clones. &lt;br&gt;  &lt;br&gt; .. image:: slide-010.png &lt;br&gt;  &lt;br&gt; " id="499" linkTypes="3 3" links="986 987" title="@slide Views: 2" />
<node body="I use view nodes to focus attention on a set of disparate &lt;br&gt; nodes. For example, when I fix a bug in Leo, I create a **bug &lt;br&gt; node** containing all the data in Leo's source code that &lt;br&gt; relates to the bug. As I discover code related to the bug, I &lt;br&gt; clone nodes and move them under the bug node. I'll also add &lt;br&gt; ordinary nodes as children of the bug node. These nodes &lt;br&gt; contain the original bug report, descriptions of how I fixed &lt;br&gt; the bug, test data, or any other notes I might want to keep. &lt;br&gt;  &lt;br&gt; .. sc 9: bug node &lt;br&gt;  &lt;br&gt; .. image:: slide-011.png &lt;br&gt;  &lt;br&gt; " id="500" linkTypes="3 3" links="988 989" title="@slide Bug nodes" />
<node body="Once I have created the bug node, I concentrate *only* on &lt;br&gt; that node and its children. I can examine the bug node and &lt;br&gt; its children without having to jump around the outline. &lt;br&gt; Everything I need is in one place. This extremely narrow &lt;br&gt; focus makes it *much* easier to fix bugs. to jump around the &lt;br&gt; outline. It doesn't matter how big or complex the outline &lt;br&gt; is: I am only dealing with the bug node and its children. &lt;br&gt;  &lt;br&gt; **Important**: I can fix the bug by changing the clones in &lt;br&gt; the view node. When I save the Leo file, Leo will save all &lt;br&gt; the @&lt;file&gt; nodes that contain any changed clone. Everything &lt;br&gt; &quot;just works&quot;. &lt;br&gt;  &lt;br&gt; .. no screenshot &lt;br&gt; " id="501" linkTypes="3 3" links="990 991" title="@slide Bug nodes: 2" />
<node body="" id="502" linkTypes="1" links="222" title="@wink_path = ../doc/html/slides/external-files/_files" />
<node body="Trees whose root headline starts with \@file, \@auto or &lt;br&gt; \@edit create **external files** on your file system. Here &lt;br&gt; are some example headlines:: &lt;br&gt;  &lt;br&gt;   @file myClass.py &lt;br&gt;   @auto ../graphics/circles.cpp &lt;br&gt;   @edit ~/.leo/.leoID.txt &lt;br&gt;  &lt;br&gt; As you can see, these nodes specify file names, which can be &lt;br&gt; an absolute path or a path relative to the directory &lt;br&gt; containing the Leo outline. &lt;br&gt;  &lt;br&gt; Collectively, nodes that create external files are known as &lt;br&gt; **@&lt;file&gt; nodes.** Leo defines several other kinds of &lt;br&gt; @&lt;file&gt; nodes, but this slideshow will not discuss them. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt;  &lt;br&gt;  &lt;br&gt; " id="503" linkTypes="3 3" links="992 993" title="@slide External files" />
<node body="Leo automatically loads all @&lt;file&gt; trees when you open a &lt;br&gt; Leo outline, and Leo writes any modified @&lt;file&gt; tree when &lt;br&gt; you save an outline. Reading external files is very fast &lt;br&gt; because of an efficient file-caching scheme. &lt;br&gt;  &lt;br&gt; A single Leo outline may be connected to dozens of external &lt;br&gt; files: this makes Leo work like an Integrated Development &lt;br&gt; Environment (IDE). Leo outlines act like project files. For &lt;br&gt; example, one Leo outline, leoPyRef.leo, contains \@file &lt;br&gt; trees for all of Leo's core source files. Another Leo &lt;br&gt; outline, leoPluginsRef.leo, creates the external files for &lt;br&gt; all of Leo's plugins, and LeoDocs.leo contains all of Leo's &lt;br&gt; documentation. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="504" linkTypes="3 3" links="994 995" title="@slide Loading and saving files" />
<node body="Leo stores the structure of \@file trees in external files &lt;br&gt; themselves using comment lines called **sentinel lines**. &lt;br&gt; Sentinel lines allow Leo to keep track of outlines &lt;br&gt; structure, including clone relationships. Using \@file is &lt;br&gt; **highly recommended** whenever possible. In particular, &lt;br&gt; using \@file allows you to **share outline structure** with &lt;br&gt; others merely by sharing external files. External files &lt;br&gt; created from \@file nodes contain **all** essential data: &lt;br&gt; The .leo file contains only the headline of the \@file node. &lt;br&gt; All the data resides in the external files. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="505" linkTypes="3 3" links="996 997" title="@slide Sentinel lines" />
<node body="In some situations it is not appropriate to use sentinel &lt;br&gt; comments in external files. In that case you use \@auto and &lt;br&gt; \@edit trees to connect Leo outlines to existing external &lt;br&gt; files without creating sentinel files. Not all of Leo's &lt;br&gt; features can be used with \@auto and \@edit trees, but that &lt;br&gt; can't be helped. In particular, Leo can not preserve outline &lt;br&gt; structure exactly. Leo's &quot;degraded&quot; operation for such trees &lt;br&gt; is similar to that found in all other editors and IDE's. &lt;br&gt;  &lt;br&gt; The rest of this slide show will discuss \@file trees and &lt;br&gt; their capabilities. We will then discuss \@auto and \@edit. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="506" linkTypes="3 3" links="998 999" title="@slide Avoiding sentinels" />
<node body="To repeat, it's best to use \@file to create external files &lt;br&gt; if at all possible. The next series of slides will show you &lt;br&gt; how to create external files with \@file trees. &lt;br&gt;  &lt;br&gt; To create a new external file, create an \@file node giving &lt;br&gt; the path to the external file. This path can be a full, &lt;br&gt; absolute path, but usually it is more convenient to use a &lt;br&gt; relative path. All relative paths in @&lt;file&gt; nodes are &lt;br&gt; relative to Leo's **load directory**, the directory &lt;br&gt; containing the .leo file for the present outline. In most &lt;br&gt; cases, we can ignore the path prefix entirely. &lt;br&gt;  &lt;br&gt; .. sc 1: @file myFile.py &lt;br&gt;  &lt;br&gt; .. image:: slide-005.png &lt;br&gt;  &lt;br&gt; " id="507" linkTypes="3 3" links="1000 1001" title="@slide Using @file trees" />
<node body="The body text of the @file node contains typical code for a &lt;br&gt; file that defines a single Python class. Informally, it says &lt;br&gt; that external file consists of import statements, followed &lt;br&gt; by the class MyDemoClass. &lt;br&gt;  &lt;br&gt; The next few slides will discuss this pattern line-by-line. &lt;br&gt;  &lt;br&gt; .. sc 2: top-level node &lt;br&gt; ..  &lt;&lt; imports &gt;&gt; &lt;br&gt; ..  class MyDemoClass: &lt;br&gt; ..      @others &lt;br&gt;  &lt;br&gt; .. image:: slide-006.png &lt;br&gt;  &lt;br&gt; " id="508" linkTypes="3 3" links="1002 1003" title="@slide Top-level design pattern" />
<node body="The &lt;&lt; imports &gt;&gt; line is a **section reference**. &quot;Imports&quot; &lt;br&gt; is the **section name**. This line tells Leo to insert the &lt;br&gt; **section definition** into the output file at the place &lt;br&gt; where section reference occurs. &lt;br&gt;  &lt;br&gt; .. sc 3: top-level node (with imports line highlighted) &lt;br&gt;  &lt;br&gt; .. image:: slide-007.png &lt;br&gt;  &lt;br&gt; " id="509" linkTypes="3 3" links="1004 1005" title="@slide Section references" />
<node body="**Section definition nodes** create section definitions. &lt;br&gt; Section definition nodes contain a section name in the &lt;br&gt; headline. The body text contains the section definition. &lt;br&gt;  &lt;br&gt; Therefore, the definition of &lt;&lt; imports &gt;&gt; are the lines:: &lt;br&gt;  &lt;br&gt;     import os &lt;br&gt;     import sys &lt;br&gt;  &lt;br&gt; Each section definition node must be a descendant of the &lt;br&gt; node containing the section reference. &lt;br&gt;  &lt;br&gt; .. sc 4: &lt;&lt; imports node &gt;&gt; &lt;br&gt;  &lt;br&gt; .. image:: slide-008.png &lt;br&gt;  &lt;br&gt; " id="510" linkTypes="3 3" links="1006 1007" title="@slide Section definitions" />
<node body="The **@others directive** is similar to a section reference; &lt;br&gt; \@others tells Leo to insert text into the output file. &lt;br&gt; Instead of inserting the body text of one particular node, &lt;br&gt; as in a section reference, \@others tells Leo to insert the &lt;br&gt; body text of all nodes that **aren't** section definition &lt;br&gt; nodes. That's where the name comes from: it inserts all the &lt;br&gt; **other** nodes. &lt;br&gt;  &lt;br&gt; .. sc 5: top-level node (with @others line highlighted) &lt;br&gt;  &lt;br&gt; .. image:: slide-009.png &lt;br&gt;  &lt;br&gt; " id="511" linkTypes="3 3" links="1008 1009" title="@slide The @others directive" />
<node body="Let us use the term **reference** to mean either a section &lt;br&gt; reference or an \@others directive. The **expansion** of a &lt;br&gt; reference is the set of all lines that Leo writes to the &lt;br&gt; output file as the result of that reference. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="512" linkTypes="3 3" links="1010 1011" title="@slide References &amp; expansions" />
<node body="The indentation of references is significant. Leo indents &lt;br&gt; each line of the expansion of a reference by the total &lt;br&gt; amount of leading whitespace that is in effect at the point &lt;br&gt; of the reference. This allows Leo to handle languages like &lt;br&gt; Python in which indentation is especially important. &lt;br&gt;  &lt;br&gt; In our example, there is no leading whitespace before the &lt;br&gt; reference to &lt;&lt; imports &gt;&gt;, but there are four spaces before &lt;br&gt; the \@others directives. This means that Leo writes the &lt;br&gt; import statements without additional indentation, but Leo &lt;br&gt; adds 4 spaces before all nodes written as the result of the &lt;br&gt; \@others directive. &lt;br&gt;  &lt;br&gt; .. sc 7: highlight indentation of @others &lt;br&gt;  &lt;br&gt; .. image:: slide-012.png &lt;br&gt;  &lt;br&gt; " id="513" linkTypes="3 3" links="1012 1013" title="@slide Indentation" />
<node body="Indentation is controlled **only** by the &lt;br&gt; indentation of references. The outline level of nodes in &lt;br&gt; expansions does not affect indentation in any way. &lt;br&gt;  &lt;br&gt; This **decoupling** of outline structure from indentation is &lt;br&gt; very important: it allows you to create **organizer nodes** &lt;br&gt; without affecting the external file in any significant way &lt;br&gt; (other than sentinel comments). &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="514" linkTypes="3 3" links="1014 1015" title="@slide Indentation, 2" />
<node body="Any node may contain one or more section references, and any &lt;br&gt; node may also contain a single \@others directive. &lt;br&gt;  &lt;br&gt; A. The expansion of a section reference is just exactly the &lt;br&gt;    expansion of the body of the section definition node. &lt;br&gt;    That expansion may include expansions of *other* &lt;br&gt;    references appearing in that node. &lt;br&gt;  &lt;br&gt; B. The expansion of an @others directive is the expansion of &lt;br&gt;    all descendant nodes that aren't section definition nodes &lt;br&gt;    and are not included in the expansion of \@others nodes &lt;br&gt;    deeper in the tree. This means that no node is ever &lt;br&gt;    included in the expansion of more than one \@other &lt;br&gt;    directive. Non-section-definition nodes are included in &lt;br&gt;    the expansion of the nearest \@others directive. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="515" linkTypes="3 3" links="1016 1017" title="@slide Expansions: 2" />
<node body="Each node in an \@file tree, except the \@file node itself, &lt;br&gt; must be part of the expansion of exactly one reference. When &lt;br&gt; writing an external file, Leo makes the following checks: &lt;br&gt;  &lt;br&gt; 1. Each section must be defined. There must be a section &lt;br&gt;    reference in an ancestor of each section definition node. &lt;br&gt;  &lt;br&gt; 2. There must be no **orphan nodes**.  A section definition node is an &lt;br&gt;    orphan if no ancestor node contains a reference to that node. &lt;br&gt;    A non-definition node is an orphan if no ancestor node contains an &lt;br&gt;    \@others directive. &lt;br&gt;  &lt;br&gt; Leo will issue an error if these checks are not satisfied. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="516" linkTypes="3 3" links="1018 1019" title="@slide Orphan nodes" />
<node body="Here is a common pattern for a file that defines two &lt;br&gt; classes, SpamClass and EggsClass. The top-level node &lt;br&gt; includes imports, and then uses \@others to include the &lt;br&gt; expansion of the rest of the outline. &lt;br&gt;  &lt;br&gt; .. sc 8: only @others at the top level. &lt;br&gt; ..  &lt;&lt; imports &gt;&gt; &lt;br&gt; ..  @others &lt;br&gt; ..  ======== children &lt;br&gt; ..    SpamClass &lt;br&gt; ..      @others &lt;br&gt; ..    EggsClass &lt;br&gt; ..      @others &lt;br&gt;  &lt;br&gt; .. image:: slide-016.png &lt;br&gt;  &lt;br&gt; " id="517" linkTypes="3 3" links="1020 1021" title="@slide Using multiple @others nodes" />
<node body="The first child node creates the expansion of SpamClass. The &lt;br&gt; lines:: &lt;br&gt;  &lt;br&gt;     class SpamClass: &lt;br&gt;         '''A class representing spam.''' &lt;br&gt;  &lt;br&gt; have no extra indentation, because the \@others in the &lt;br&gt; top-level node has no leading whitespace. &lt;br&gt;  &lt;br&gt; However, the two methods of the class will have 4 spaces of &lt;br&gt; indentation because the \@others directive in *this* node is &lt;br&gt; indented by 4 spaces. &lt;br&gt;  &lt;br&gt; .. sc 9: SpamClass &lt;br&gt;  &lt;br&gt; .. image:: slide-017.png &lt;br&gt;  &lt;br&gt; " id="518" linkTypes="3 3" links="1022 1023" title="@slide SpamClass" />
<node body="The second child node creates the expansion of EggsClass in &lt;br&gt; a similar manner. It's always perfectly clear what nodes are &lt;br&gt; included in \@others directives. \@others refers to all &lt;br&gt; descendant nodes of *this* node. &lt;br&gt;  &lt;br&gt; .. sc 10: EggsClass &lt;br&gt;  &lt;br&gt; .. image:: slide-018.png &lt;br&gt;  &lt;br&gt; " id="519" linkTypes="3 3" links="1024 1025" title="@slide EggsClass" />
<node body="You can use \@others to &quot;comment out&quot; all descendant nodes as &lt;br&gt; shown. This works in Python because the indentation of the &lt;br&gt; \@others directive causes the expansion of all descendant &lt;br&gt; nodes to have 4 extra spaces. &lt;br&gt;  &lt;br&gt; .. sc 11: &lt;br&gt; ..  if 0: &lt;br&gt; ..      @others &lt;br&gt;  &lt;br&gt; .. image:: slide-019.png &lt;br&gt;  &lt;br&gt; " id="520" linkTypes="3 3" links="1026 1027" title="@slide Using @others to group code" />
<node body="This concludes our brief discussion of \@file nodes. The next &lt;br&gt; few slides discuss two alternatives to \@file, \@auto and &lt;br&gt; \@edit. &lt;br&gt;  &lt;br&gt; \@auto and \@edit create external files without sentinel &lt;br&gt; lines. The cost of avoiding sentinel lines is that Leo can &lt;br&gt; not preserve outline structure exactly. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="521" linkTypes="3 3" links="1028 1029" title="@slide Summary of @file" />
<node body="When Leo reads an **@auto node**, Leo will automatically &lt;br&gt; create an outline that shows the class, functions or other &lt;br&gt; units of the external file. &lt;br&gt;  &lt;br&gt; Leo can only do this if Leo has an **importer** for the &lt;br&gt; external file. At present, Leo has importers for C, elisp, &lt;br&gt; HTML, .ini files, Java, Javascript, Pascal, PHP, Python and &lt;br&gt; xml. Leo determines the language using the file's extension. &lt;br&gt; If no parser exists for a language, Leo copies the entire &lt;br&gt; body of the external file into the \@auto node. &lt;br&gt;  &lt;br&gt; .. no sc &lt;br&gt; " id="522" linkTypes="3 3" links="1030 1031" title="@slide Using @auto nodes" />
<node body="Here is an example of an actual Python file imported into Leo. &lt;br&gt;  &lt;br&gt; The importer has created the entire outline, including &lt;br&gt; the body text of the root \@auto node. &lt;br&gt;  &lt;br&gt; The importer created an \@others directive (1) to place the &lt;br&gt; expansion of the descendant nodes properly, before the &lt;br&gt; final top-level lines of the file (2). &lt;br&gt;  &lt;br&gt; .. sc 12: Showing tree of nodes imported by @auto &lt;br&gt;  &lt;br&gt; .. image:: slide-022.png &lt;br&gt;  &lt;br&gt; " id="523" linkTypes="3 3" links="1032 1033" title="@slide @auto example" />
<node body="When Leo reads and **@edit node**, Leo reads the entire &lt;br&gt; contents of the external file into the body text of the &lt;br&gt; \@edit node. Any changes to the external file will appear in &lt;br&gt; the \@edit node the next time Leo loads the external file. &lt;br&gt; Rather than creating new files with @edit, it is more common &lt;br&gt; to use @edit to connect Leo with files that already exist on &lt;br&gt; your file system. &lt;br&gt;  &lt;br&gt; .. sc 13: Showing @edit node. &lt;br&gt;  &lt;br&gt; .. image:: slide-023.png &lt;br&gt;  &lt;br&gt; " id="524" linkTypes="3 3" links="1034 1035" title="@slide Using @edit nodes" />
<node body="This is section 1 &lt;br&gt; " id="525" linkTypes="1" links="226" title="section 1" />
<node body=".. _`slashdot`: http://slashdot.org/comments.pl?sid=38848&amp;amp;cid=4171478 &lt;br&gt;  &lt;br&gt; August 28, 2002, on `slashdot`_. &lt;br&gt;  &lt;br&gt; Hello, my full name is David Speed Ream. I am known as Speed to friends and enemies alike, but I gladly answer to David or most any other handle. I am an unabashed and biased fan of Leo, the fact that it was written by my brother Edward only slightly coloring my already colored glasses. I have been testing and using Leo in software production for over 4 years. My company currently has over 50,000 lines of code in over 100 source files that are written using Leo. &lt;br&gt;  &lt;br&gt; My comments are from two points of view, the first being software project manager for a complicated, multi-module software product, and the second being as a production line coder. For me, Leo’s greatest and only real drawback is the learning curve. This learning curve can be shallow is if all that is required is that someone code using Leo. However, in our company we allocate 40 to 80 hours *on top* of the normal coding load for someone to come up to speed on Leo. The ROI (return on investment) is calculated by me to be on the order of 3 months. So if I hire a consultant for less than 3 months, I don’t teach him Leo, even though all source code in our company must reside in Leo files for the reasons I won’t go into now. &lt;br&gt;  &lt;br&gt; I consider that my coders are 15 to 30 percent more efficient in their daily operations than my competition’s people. This indefensible claim of mine is based on the changes in my productivity as Leo grew from a test document production tool to the primary production method for all our assembly, c and cpp source code. &lt;br&gt;  &lt;br&gt; Personally, I hate to deal with documentation when I write code, except: &lt;br&gt;  &lt;br&gt; 1) When I am first sitting down to solve a new problem. Then the documentation becomes quite long-winded and pontificatory, as if I were the only one on earth smart enough to solve the problem - or &lt;br&gt;  &lt;br&gt; 2) When I come back to code I or someone else has written and find the documentation insufficient to understand the code without study (seems to be most of the time). &lt;br&gt;  &lt;br&gt; So I do not require my engineers or myself to do a great job of documentation, nor do I use Leo for that purpose. Rather, it is Leo’s outlining and organizing ability, and Leo’s ability to create source files from within the outline that give me what I think is a tremendous competitive advantage. Each of my company’s products run on all versions of windows from Win 3.1 to XP. In our flagship software piece, there are ten main modules, and each module is maintained by one single Leo file. In the CODEC module, one Leo file named compress.leo organizes and creates seven .asm files, forty-four .c files, twenty .h files, two .def files, four .mak files, etc. etc. etc. This one file can be checked out from source code control and given to an engineer for the addition of a new feature. &lt;br&gt;  &lt;br&gt; In it are contained all the known issues for the CODEC, each issue arranged in its own clone section. One clone section groups together every routine, variable or type definition that must change between different versions of Windows. These sections could be from six different c source files, two assembly files, and eight .h files. Another clone section groups together those sections relating to memory problems, which change according to the memory configuration and TSR configuration (or lack thereof) on the target machine. Another clone section groups sections that fail (or don’t fail) if the routine in question was accidentally run during the dreaded ‘interrupt time’. Another clone section is a section containing clones, each of which is named after the major bug that was fixed when the engineer who fixed the bug grouped a bunch of routines, definitions, etc. together to fix the bug. &lt;br&gt;  &lt;br&gt; None of the above clone sections was ‘designed’ into the document. Just the opposite happens. When the codec was first written, there was just a single Leo file with a bunch of sections for each c routine or assembly module. As the product grew and was tested on various platforms, each failure of the module was organized into clones each time a failure was fixed. This is what I call “SELF DOCUMENTING CODE”. This has nothing to do with me sitting and documenting anything. Its just that the STRUCTURE of a bug fix (or product enhancement) lives on long after the coding is done, as long as no one is foolish enough to delete the cloned sections that ‘DOCUMENT’ what happened. &lt;br&gt;  &lt;br&gt; In actual practice, this organizational ‘history’ is so powerful that I can’t begin to describe it. A ‘REVERSE LEARNING CURVE’ happens when an engineer gets a Leo file that already has the ‘interrupt time sensitive’ routines grouped together by the last unfortunate soul who had to work on them. There may not be any more written documentation, but the knowledge contained in the structure can be breathtaking. It is certainly time saving. I find this particularly true in my own case. Often I’ll look at some code that seems totally unfamiliar and think ‘what idiot wrote this crap’. Then I’ll look at the version control comments and realize that I wrote the crap. Then for sure I know the documentation is non-existent, but the clones I used to develop it are still there, and they always serve to refresh my memory in an indescribable way. &lt;br&gt;  &lt;br&gt; Enough of this commentary, I just looked at the clock. Best wishes to anyone willing to try Leo for a week. I hope you will be glad you did. &lt;br&gt; " id="526" linkTypes="1" links="238" title=" Speed Ream's slashdot article" />
<node body="The Word outlines are very useful. But Leo makes Word look like a clunky toy. &lt;br&gt;  &lt;br&gt; #1 Reason would probably be clone nodes. One node can point to another. Another way of putting this is is that a leaf can be on more than one tree. For example, suppose you have a list of recipes. You simultaneously put a single recipe under multiple categories or even multiple hierarchies. You could put &quot;3 bean enchilada&quot; simultaneously under Recipes-Mexican and Food-Gas. Another example would be, if you are a biologist trying to decide under which genus to put a new species, you could put the species under two simultaneously. In effect, you can build a 3-D tree. &lt;br&gt;  &lt;br&gt;  &lt;br&gt; #2 Reason would probably be that Leo outlines can be embedded in external text files. So, a Leo outline is more than an outline, it is a meta-structure that can be added to another text without changing that text, but rather providing an external road map to the text. Microsoft Word has a text (xml) version with a commenting convention, so Leo can even be used to add outlines into Word docs, although it isn't set up to do that now. For example, see http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm In this case, the upper window of Leo is the meta-structure, and the bottom window is the file to which the meta-structure is being applied, viewed one node at a time. &lt;br&gt;  &lt;br&gt; I may not have made #2 very clear, but it is actually a very useful feature. It takes some getting used to before one sees all of the possibilities tho. One way to think of it is that Leo allows you to throw external documents into your outline, and yet the external document remains independent and can still be edited separately. &lt;br&gt;  &lt;br&gt; Some other cool things about Leo which Word doesn't feature: &lt;br&gt; 1. Pure xml output that is easy to transform into other formats (next version of Word will have true XML format, but not as easy to work with). One consequence of this is that Leo files can be transformed pretty easily to web pages with their outlining capability intact. &lt;br&gt; 2. Easy to add features since is programmed in Python and open source. Maybe your average user can't start hacking on it, but a surprising amount can be tacked on... &lt;br&gt; 3. Free, opensource, multi-platform &lt;br&gt; 4. Leo is scriptable with Python. It should be possible to build a Tickler into Leo using Python scripting, for example. &lt;br&gt; " id="527" linkTypes="1" links="238" title="Joe Orr" />
<node body="First of all, kudos to you for the excellent progress you've been making with Leo. I upgraded today after about three months of using and older version and I was thrilled to see all the great improvements that have happened so fast. I especially love the ability to go to next clone. I think you're really showing what open source can do and your current trajectory puts you on track to kick Emacs into the dustbin of computing history. &lt;br&gt;  &lt;br&gt; So today I copied all my data (personal information manager and project management stuff) out of my old outliner (ThoughtManager, which syncs with and runs on the Palm) and put it into Leo. It took me hours to do it and then to rearrange it the way I really wanted it. But having the ability to make clones and have different ways to view my data is, as you know, fabulous. In my case, for personal information and project management things, I used the flexibility of clones to allow me to see my data in several different views: 1) by project, the logical hierarchical breakdown by topic, 2) by person, so whenever I'm talking to someone I can easily see all the pending items related to them which may be spread over multiple projects, 3) by priority, so I can see what needs to get done sooner and what can wait for later and, 4) a special case of priority called &quot;Today&quot; for the things I'm going to focus on in the coming hours. &lt;br&gt;  &lt;br&gt; Now here's why I don't miss the ability of my old outliner to sync the entire outline with the Palm. It turns out the main thing I really want in the Palm is the top category &quot;Today&quot; so all I have to do is have Leo flatten that one heading into a text file (and it kindly remembers the name and directory of the file I used last time) and then I'm done because I've told the Palm Hotsync manager that that file should be sent to Palm memo pad every time I sync. The Palm Hotsync manager does a nice job of sending a text file to the Palm memo pad and even breaks the file up into multiple memo records if it's too big to fit in just one. So that gives me enough to be able to browse (or full text search) the small amount of data that I really want right inside my Palm (which is also my cell phone). Quick and dirty but it works. &lt;br&gt;  &lt;br&gt; For times when I want my whole outline with me, Leo wins again because thanks to its cross platform nature I can take my whole outline with me on my Mac iBook, even though I usually edit it on a Windows PC (which is the only kind of machine my old outliner would run on). Quite frankly, although my old outliner was able to shoehorn the whole thing into my palm/cellphone, it was a pain to access it on the small screen and slow processor. Now when I anticipate I'll need the whole thing, for example when I'm going to a meeting, I can put it on my Mac iBook (under X and Fink for now until Python can do it native under Aqua) and have real, full access to it all. &lt;br&gt;  &lt;br&gt; I think now in addition to being great for programming Leo is also a great PIM. Being able to flatten a strategically chosen portion of the outline into a known file name that the Palm sync manager has been told to send to the Palm on every sync does the trick for me. I wonder if you would consider something like an @flatten directive so I can have that done automatically for me every time I save my outline? For now it's up to me to flatten the node I want manually, although once I've done that the transfer to the Palm is automatic. &lt;br&gt;  &lt;br&gt; You're my hero! Thank you so much. &lt;br&gt; " id="528" linkTypes="1" links="238" title="Dan Winkler" />
<node body="Another day, another breakthrough using Leo--now I realize Leo is the best URL bookmark manager there is.  No more bookmarks menus or favorites lists inside the browser for me.  With the @url directive I can just double click on the URL to open it in my browser.  Leo lets me arrange the URLs in a hierarchy (or multiple hierarchies), attach notes to them, save clippings of things I read on the sites.  It's sooo much better than anything the browsers have built in and it lets me easily use different browsers on different platforms and different machines (try that with the browsers' built-in bookmark managers). &lt;br&gt;  &lt;br&gt; When using Leo as a project manager and personal information manager as I do I can heavily annotate every task and project with helpful and relevant URLs.  And since URLs can be of the file:// form, they're not just for web pages or HTML documents;  I can link to any file on my disk of any type to be opened by any program. &lt;br&gt;  &lt;br&gt; Leo is a quantum leap for me in terms of how many projects I can manage and how much information I can find and organize and store in a useful way.  I'm a data-mining army of one now and the web is my playground. Every time I find a web page that has interesting links to others, those links get stored in my Leo outline too, right where I can find them and make practical use of them.  I can easily accept dozens of valuable links every day and integrate them into what I'm doing in a way that I'm confidant they won't get lost or forgotten.  Before I always used to get bogged down by the difficulty of managing bookmarks inside the browser.  But now I'm no longer the victim of information overload buried in the knowledge landslide of the Internet;  instead I'm the professional strip miner with the world's biggest bulldozer.  I eagerly plunge into mountains of data and emerge with all the valuable information nuggets neatly stored and organized.  And my storehouse of knowledge is a flexible thing where I can reorganize and prioritize and massage the data to my heart's content as I learn more about it and decide to use it in different ways for different purposes.  It's the difference between the pick axe and the steam shovel for me. &lt;br&gt; " id="529" linkTypes="1" links="238" title="Dan Winkler 2" />
<node body="This year my accountant is getting a beautiful printout generated by LaTeX and Leo. I have a complicated tax situation this year, but I got it all laid out and organized in Leo. Then I had each of the nodes that had something my accountant needs to see write the data out to a file in the form a LaTeX table. &lt;br&gt;  &lt;br&gt; Sometimes a row of a table would have a result that was calculated by adding up a list of numbers. For that I used the modern day equivalent of an adding machine paper tape--I stored a lisp s-expression in a Leo comment. I like s-expressions for this because once I put the opening &quot;(+&quot; on one line and the closing &quot;)&quot; on another line, I can fill in additional numbers just by typing them and can even annotate them with comments. So in the middle of generating a LaTeX file I might have something like this:: &lt;br&gt;  &lt;br&gt;     @ &lt;br&gt;     (+ &lt;br&gt;     1165.26 1823.70 ; May 2002 &lt;br&gt;     123.38 ; June 2002 &lt;br&gt;     13.50 ; July 2002 &lt;br&gt;     13.21 ; October 2002 &lt;br&gt;     55.25 ; November 2002 &lt;br&gt;     ) &lt;br&gt;     @c &lt;br&gt;  &lt;br&gt; That's an annotated record of how I arrived at the number the accountant will actually see. I can just paste it into any lisp or scheme interpreter and get the total. Adding additional numbers is easy. &lt;br&gt;  &lt;br&gt; For next year, I think I might take this a step further. What I did this year is good for adding up numbers to get a total for one row of a LaTeX table. But it turns out I'd also like some more processing done on those tables (which I had to do by hand this time--I'd like the rows sorted in reverse order by magnitude (so that the big numbers jump out at you from the start of the tables) and I'd like a total of all the rows in the table. So I think next year, instead of having an s-expression that computes the total of one row for me, I think I'll use s-expressions that generate whole tables, formatted for LaTex, from the underlying data. So I'm thinking next year my s-expressions might look more like this:: &lt;br&gt;  &lt;br&gt;     @ &lt;br&gt;     (table &quot;Widget Related Expenses&quot; &lt;br&gt;         (&quot;widget insurance&quot; (+ &lt;br&gt;                         1165.26 1823.70 ; May 2002 &lt;br&gt;                         123.38 ; June 2002 &lt;br&gt;                         13.50 ; July 2002 &lt;br&gt;                         13.21 ; October 2002 &lt;br&gt;                         55.25 ; November 2002 &lt;br&gt;                       )) &lt;br&gt;          (&quot;widget shipping&quot; (+ &lt;br&gt;                         472.15 651.94 ; May 2002 &lt;br&gt;                         54 ; June 2002 &lt;br&gt;                        )) &lt;br&gt;          (&quot;widget cleaning&quot; (+ &lt;br&gt;                         165.26 183.70 ; May 2002 &lt;br&gt;                         123.38 ; June 2002 &lt;br&gt;                         13.50 ; July 2002 &lt;br&gt;                         13.21 ; October 2002 &lt;br&gt;                         55.25 ; November 2002 &lt;br&gt;                        )) &lt;br&gt;     ) &lt;br&gt;     @c &lt;br&gt;  &lt;br&gt; The job of that &quot;table&quot; function would be to return the LaTeX code needed to display a table with the category names and values, sorted descending by magnitude, with the total displayed. It's sort of a poor man's way of doing a spreadsheet inside Leo and then making it look great using LaTeX. The idea would be as I wanted to add more data, I'd add it to the s-expression and then reevaluate the whole thing by pasting it into a lisp interpreter and then copying the result back into the same Leo node for LaTeX to process.---Dan &lt;br&gt; " id="530" linkTypes="1" links="238" title="Dan Winkler 3" />
<node body="&quot;Not sure why you said 'you can specify a computer program as an outline like thing in an outliner like setting.' Why not just say, 'write a computer program in an outline?' Is there some nuance I am missing?&quot;---EKR &lt;br&gt;  &lt;br&gt; There are probably a million reasons I said it like that, but I think the main one is my ever present, brightly burning belief that a program should be designed before its coded. Remember those guys, back in the day, who after receiving their programming assignment, would go to the keyboard and start pounding out C code? Remember their finished product? Remember how long it took them to finally complete the project? &lt;br&gt;  &lt;br&gt; Meanwhile, when receiving an assignment, I'd spend hours to days with a bunch of paper, drawing diagrams. By the time I sat down at the terminal, I knew my data structures and algorithms. The hours to days head start of the &quot;start coding immediately&quot; guys evaporated because for me, coding was just a secretarial task, and I was required to do less refactoring, or even worse, kludging. Later, sometimes I'd substitute an outliner for the diagrams on paper; in the days of functional decomposition, an outliner was the perfect fit. &lt;br&gt;  &lt;br&gt; Back to your question: If all I needed to do was **write** a program, I'd just sit down at a computer and start pounding out C or Python or Lua or whatever. But that's not my style. I need to **design** a program, and after all, a design is just a specification of how the program is going to be written. &lt;br&gt;  &lt;br&gt; So it seems to me that I *design* the program on Leo, and then, when the time comes, I flip a switch and Leo *writes* the program for me. That's how I'd view what I've heard about Leo. &lt;br&gt; " id="531" linkTypes="1" links="238" title="Steve Litt" />
<node body="I am a microbiologist mostly analyzing large numbers of bacteria genomes for which I use almost entirely Python tools. A couple of years ago while working at Yale University I gave Leo go for writing Python and organizing my notes with. &lt;br&gt;  &lt;br&gt; Not only do I now use Leo is a central repository for scripts I write as I explore the data, generate plots, start analyses with third party applications etc., but also for storing and organizing ideas for research and notes parsed out of PDFs of academic papers. And that's just for work! &lt;br&gt;  &lt;br&gt; I have a calendar, addresses all my general PIM-type info, and notes for any project I'm tinkering with. In short whether I'm at work or play Leo is usually involved :-) &lt;br&gt; " id="532" linkTypes="1" links="238" title="Dave Williams" />
<node body="A new user recently said to me, &quot;Leo is powerful and flexible -- and complex and bewildering&quot;. This is true. I believe it is always the goal of developers to make their software less complex and bewildering but keep in mind that Leo has been in development for over 20 years...This puts it right up there with Vim and Emacs in terms of maturity. My own experience with Vim and Emacs have been quite similar to my experience with Leo. All three are powerful and flexible and complex and bewildering in their own right. &lt;br&gt;  &lt;br&gt; I believe with tools of this weight and impact, there will always be an investment in learning them. They're all vast forests of features filled with hidden treasures and in the case of each of them he/she that invests in the tool will be rewarded for their effort. It is, however, the responsibility of the community (led by the developers) to help make that treasure hunt as enjoyable and adventurous as possible, as any good treasure hunt should be.  &lt;br&gt;  &lt;br&gt; And this is where Leo does not falter, in the helpfulness of its community (small though it may be). I will reiterate what Edward has said many times, do not struggle on your own if you are lost, confused, or bewildered. Please ask questions. If the documentation or examples do not meet your needs, please ask questions. In my own experience as a once new user (though there may be the occasional disagreement) you will not be chided, scorned, or belittled but will be met with more even more help than you originally asked for. -- john lunzer &lt;lunzer@gmail.com&gt;" id="533" linkTypes="1" links="238" title="John Lunzer" />
<node body="Offray Cárdenas &lt;br&gt;  &lt;br&gt; This idea of an always present outline has been key to me for organizing writings. Some coworkers have found in the past that this helps them when we're correcting their text. &lt;br&gt;  &lt;br&gt; &gt; Leo's clones let you organize any data as you want, even if all folds are collapsed. &lt;br&gt;  &lt;br&gt; For me this is the most powerful but misunderstood feature of Leo. Most of the people which compares it with other IDE rant about why Leo doesn't works more automatically imposing structure, but in Leo you're in charger. You impose infrastructure... &lt;br&gt;  &lt;br&gt; For me the second main insight of Leo (besides emergent always present tree structure on almost any file) was to have a tree that is a programmable structure that can be understood and changed by any node inside that tree. I think that Leo brings structure and self-referentiality to the dumb flat file word. So you can create a tree from one (or several) files, deconstruct and reconstruct it they way you want and automatize the way in behaves and talks with the external world...The more I start to focus on interactive writing and going away of the unix inspired OS world, the more the second insight become important to me. I didn't need to deconstruct/reconstruct or impose structure over flat files but to use outlining for structure thought by (interactive) writing and I need the outline be a fully programmable object. That's the essence of most of my Leo experience... &lt;br&gt;  &lt;br&gt; Thanks for Leo and all the key inspiration it brings. And, as always, thanks to the Leo community for the food for thought. &lt;br&gt; " id="534" linkTypes="1" links="239" title="Offray Cárdenas" />
<node body="My only input is what makes Leo so special to me. &lt;br&gt;  &lt;br&gt; After learning just a few things about Leo, and after replacing section references mostly with @others, writing code becomes a game rather than a chore. &lt;br&gt;  &lt;br&gt; As soon as an idea becomes complicated, I add a new @others, and break down the complication into chunks until all the complications are now simple. &lt;br&gt;  &lt;br&gt; I'll typically clone that section an the bottom of the outline, then add enough logic at a parent level so that the complication can be tested with control B. &lt;br&gt;  &lt;br&gt; This is my backward implementation of unit testing. This kind of 'unit testing' never has to be refactored when the code is (invariably) improved. &lt;br&gt;  &lt;br&gt; The cloned 'test piece' can be relegated to a testing section, and the new chunks subsequently cloned into whatever structure make real sense for the project. &lt;br&gt;  &lt;br&gt; In practice, this is just fun for me. &lt;br&gt;  &lt;br&gt; Coding without Leo is not really fun any more. I recently finished a c++ socket server using Microsoft's Visual Studio, in concert with someone who didn't have Leo. Microsoft's tools are great, and the project went off without a hitch, but the fun was just plain gone. &lt;br&gt;  &lt;br&gt; Anyway, thanks for the great perspective on Leo. &lt;br&gt; " id="535" linkTypes="1" links="239" title="Speed's comments" />
<node body="Install Python and Qt, as described above (`Installing Packages`_). &lt;br&gt;  &lt;br&gt; Now you have a choice.  You can use Leo's binary (single-click) installer &lt;br&gt; or download Leo's sources directly. &lt;br&gt; " id="536" linkTypes="3 3 3" links="1036 1037 1038" title="Installing Leo on Windows" />
<node body=".. _`install Leo from a debian package`: installing.html#installing-from-a-debian-package &lt;br&gt; .. _`install Leo using pip`: installing.html#installing-using-pip &lt;br&gt; .. _`install Leo from sources`: installing.html#installing-from-sources-linux &lt;br&gt;  &lt;br&gt; If you are using Debian/Ubuntu, it's best to &lt;br&gt; `install Leo from a debian package`_, as described next. &lt;br&gt; This provides file associations, icons, launcher items, etc. &lt;br&gt;  &lt;br&gt; .. Otherwise, you may `install Leo using pip`_ or `install Leo from sources`_. &lt;br&gt;  &lt;br&gt; Otherwise, you may `install Leo from sources`_. &lt;br&gt; " id="537" linkTypes="3 3" links="1039 1040" title="Installing Leo on Linux" />
<node body=".. .. http://groups.google.com/group/leo-editor/browse_thread/thread/92ae059cc5213ad3 &lt;br&gt;  &lt;br&gt; Many thanks to Ludwig Schwardt for the following installation instructions. Using the HomeBrew installation method is *much* easier than before. &lt;br&gt;  &lt;br&gt; **Note from EKR**: When upgrading MacOS, it's probably a good idea to uninstall pyqt, sip and qt first:: &lt;br&gt;  &lt;br&gt;     brew remove pyqt sip qt &lt;br&gt;     brew install qt sip pyqt &lt;br&gt;  &lt;br&gt; I (Ludwig) recently received a new MacBook Pro and did a fresh upgrade to Mac OS 10.7 (Lion). I then used the opportunity to test out installation procedures of various software on a clean system. My main finding is that the excellent Homebrew (mxcl.github.com/homebrew/) makes things much easier these days. &lt;br&gt;  &lt;br&gt; Why Homebrew? It does not try to replace every single bit of functionality on your Mac with their own version, like Macports or fink. It reuses the existing libraries as far as possible. No need to reinstall Python, for example (one of my pet gripes when people try to install new software on their Macs, and the source of much confusion and pain). It installs to /usr/local, the standard place to find third-party libraries and headers, instead of the obscure /opt or /sw. It's simple to use and to extend. &lt;br&gt;  &lt;br&gt; Here is my installation write-up: &lt;br&gt;  &lt;br&gt; - Read the Homebrew installation instructions at http://brew.sh/ &lt;br&gt;  &lt;br&gt; - Make sure you have Xcode installed (test it by confirming that &quot;gcc&quot; runs in the Terminal). Only the smaller command-line tools are required; there is no need to get the full Xcode beast. &lt;br&gt;  &lt;br&gt; - In preparation for Homebrew, the best option in my opinion is to delete /usr/local via:: &lt;br&gt;  &lt;br&gt;     sudo rm -rf /usr/local &lt;br&gt;  &lt;br&gt;   and install any software in it via HomeBrew instead. &lt;br&gt;    &lt;br&gt;   The HomeBrew package manager is so easy to use that you will find replacing deleted packages a snap. &lt;br&gt;    &lt;br&gt;   If deleting /usr/local fills you with dread (you do not want to lose your beloved third-party software), the second-best option is to make sure you have write permission for the directory via:: &lt;br&gt;  &lt;br&gt;     sudo chown -R &lt;your user name&gt;:admin /usr/local &lt;br&gt;  &lt;br&gt;   If you don't know your username, run &quot;whoami&quot;. :-) This is useful because homebrew actually discourages you from installing third-party software as the superuser (the usual Mac apps in /Applications are also installed as the normal user, for that matter). &lt;br&gt;  &lt;br&gt; - Install Homebrew (http://mxcl.github.com/homebrew/) by running the &lt;br&gt;   following command in the Terminal:: &lt;br&gt;      &lt;br&gt;     ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; &lt;br&gt;  &lt;br&gt; - Run &quot;brew doctor&quot; and check any further suggestions to improve your system. &lt;br&gt;  &lt;br&gt;   EKR note: I thought I had installed command-line tools after installing the XCode page. I hadn't, and &quot;brew doctor&quot; told me so. &lt;br&gt;  &lt;br&gt; - Run &quot;brew update&quot; to get the latest formulas &lt;br&gt;  &lt;br&gt; - Install sip and note the caveat:: &lt;br&gt;  &lt;br&gt;     brew install sip &lt;br&gt;  &lt;br&gt;   This warns you to add the local python directory to your PYTHONPATH. &lt;br&gt;   Make a note of what this is (especially if you are not on Lion!). &lt;br&gt;  &lt;br&gt; - Add the following lines to your ~/.bash_profile &lt;br&gt;   (or ~/.profile on Leopard). This is the default for LION:: &lt;br&gt;  &lt;br&gt;       export PATH=/usr/local/bin:$PATH &lt;br&gt;       # This is for SIP (and PyQt) as suggested by Homebrew &lt;br&gt;       export PYTHONPATH=/usr/local/lib/python2.7/site-packages:$PYTHONPATH &lt;br&gt;  &lt;br&gt; - Install PyQt:: &lt;br&gt;  &lt;br&gt;     brew install pyqt &lt;br&gt;   &lt;br&gt; - Open a new Terminal tab / window so that the above settings take effect, and install Leo. I downloaded the Leo-4.9-final-a.zip, unzipped it, and ran &quot;python launchLeo.py&quot; inside the Leo directory. &lt;br&gt;  &lt;br&gt; It would really be great to get a Leo formula going for Homebrew. As mentioned before, the main question is just where to place all the Leo files in the /usr/local hierarchy. &lt;br&gt; " id="538" linkTypes="1" links="244" title="Installing Leo on MacOs 10.7 (Lion) and later" />
<node body="**Important**: This section tells how to set up git_ so that you can grab &lt;br&gt; the latest sources using ``git clone``. However, you can get a nightly &lt;br&gt; snapshot of Leo's git repository (without installing git) from &lt;br&gt; http://www.greygreen.org/leo/ &lt;br&gt;  &lt;br&gt; Many users will want to track the development version of Leo, in order to stay &lt;br&gt; on top of the latest features and bug fixes. Running the development version is &lt;br&gt; quite safe and easy, and it's also a requirement if you want to contribute to &lt;br&gt; Leo. &lt;br&gt;  &lt;br&gt; 1. First, you need to get git from http://git-scm.com/. &lt;br&gt; 2. Get Leo from GitHub by doing:: &lt;br&gt;  &lt;br&gt;         git clone https://github.com/leo-editor/leo-editor (http access) &lt;br&gt;      &lt;br&gt;    or:: &lt;br&gt;     &lt;br&gt;         git clone git@github.com:leo-editor/leo-editor.git (ssh access) &lt;br&gt;  &lt;br&gt; And that's it! You can run leo/core/leo.py directly. When you want to refresh the &lt;br&gt; code with latest modifications from GitHub, run git pull. &lt;br&gt;  &lt;br&gt; " id="539" linkTypes="1" links="244" title="Contributing to Leo with git" />
<node body="The first time you start Leo, a dialog will ask you for a unique identifier. If &lt;br&gt; you are using a source code control system such as git, use your git login name. &lt;br&gt; Otherwise your initials will do. &lt;br&gt;  &lt;br&gt; Leo stores this identifier in the file .leoID.txt. Leo attempts to create &lt;br&gt; leoID.txt in the .leo sub-directory of your home directory, then in Leo's config &lt;br&gt; directory, and finally in Leo's core directory. You can change this identifier &lt;br&gt; at any time by editing .leoID.txt. &lt;br&gt; " id="540" linkTypes="1" links="245" title="Running Leo the first time" />
<node body="On startup, Leo looks for two arguments of the form:: &lt;br&gt;  &lt;br&gt;     --script scriptFile &lt;br&gt;  &lt;br&gt; If found, Leo enters batch mode. In batch mode Leo does not show any windows. &lt;br&gt; Leo assumes the scriptFile contains a Python script and executes the contents of &lt;br&gt; that file using Leo's Execute Script command. By default, Leo sends all &lt;br&gt; output to the console window. Scripts in the scriptFile may disable or enable &lt;br&gt; this output by calling app.log.disable or app.log.enable &lt;br&gt;  &lt;br&gt; Scripts in the scriptFile may execute any of Leo's commands except the Edit Body &lt;br&gt; and Edit Headline commands. Those commands require interaction with the user. &lt;br&gt; For example, the following batch script reads a Leo file and prints all the &lt;br&gt; headlines in that file:: &lt;br&gt;  &lt;br&gt;     path = r&quot;&lt;path-to-folder-containing-the-leo-folder&gt;\\leo\\test\\test.leo&quot; &lt;br&gt;  &lt;br&gt;     g.app.log.disable() # disable reading messages while opening the file &lt;br&gt;     flag,newFrame = g.openWithFileName(path,None) &lt;br&gt;     g.app.log.enable() # re-enable the log. &lt;br&gt;  &lt;br&gt;     for p in newFrame.c.all_positions(): &lt;br&gt;         g.es(g.toEncodedString(p.h,&quot;utf-8&quot;)) &lt;br&gt; " id="541" linkTypes="1" links="245" title="Running Leo in batch mode" />
<node body=".. _`associating .leo files with python.exe`: http://leoeditor.com/installing.html#creating-windows-file-associations &lt;br&gt;  &lt;br&gt; Leo sends more detailed error messages to stderr, &lt;br&gt; the output stream that goes to the console window. In Linux and MacOS &lt;br&gt; environments, python programs normally execute with the console window visible. &lt;br&gt;  &lt;br&gt; On Windows, you can run Leo with the console window visible by `associating .leo files with python.exe`_ *not* pythonw.exe. &lt;br&gt; " id="542" linkTypes="1" links="245" title="Running Leo from a console window" />
<node body="Leo uses os.expanduser('~') to determine the HOME directory if no HOME environment variable exists. &lt;br&gt;  &lt;br&gt; Leo puts several files in your HOME/.leo directory: .leoID.txt, .leoRecentFiles.txt, and myLeoSettings.leo. &lt;br&gt; " id="543" linkTypes="1" links="245" title="The .leo directory" />
<node body="See the instructions are in LeoPy.leo in:: &lt;br&gt;  &lt;br&gt;     Notes:How To:How to add support for a new language section. &lt;br&gt;  &lt;br&gt; This section contains clones of all relevant parts of Leo that you will change. Coming in Leo 4.4: Leo will use JEdit's language description files to drive the syntax colorer. To add support for a new language, just add another such description file. &lt;br&gt; " id="544" linkTypes="1" links="250" title="How can I add support for a new language?" />
<node body="@language rest &lt;br&gt;  &lt;br&gt; I'm trying to create a interactive chart in a embedded in a new leo pane using matplotlib. However, I am not sure about the the best way to implement this. I would appreciate some guidance on this please? The questions I would like answered are: &lt;br&gt;  &lt;br&gt; 1. How do I create a new blank pane for embedding a chart as well as other QtWidgets. &lt;br&gt;  &lt;br&gt; 2. Can I do this in a script or do I need to work with leo source? &lt;br&gt;  &lt;br&gt; I want to create a data processing and visualization tool kit in leo. Like Excel but using nodes instead of columns. Nodes will have data and I want to create new data nodes by applying python functions to data in existing nodes. The thing missing is the visualization within a leo pane (I can easily launch a chart in it's own window). &lt;br&gt;  &lt;br&gt; ----- Terry Brown &lt;br&gt;  &lt;br&gt; You can run this script from any body pane:: &lt;br&gt;  &lt;br&gt;     ''' &lt;br&gt;     A script that adds a MatPlotLib pane to Leo. &lt;br&gt;      &lt;br&gt;     After running this script, right click on one of the pane dividers and &lt;br&gt;     select Insert. A new pane with a button 'Action' appears. Click it, and &lt;br&gt;     select &quot;Add matplot&quot; from the context menu. &lt;br&gt;     ''' &lt;br&gt;      &lt;br&gt;     from leo.core.leoQt import QtWidgets &lt;br&gt;      &lt;br&gt;     class MatplotPaneProvider: &lt;br&gt;         def __init__(self, c): &lt;br&gt;             self.c = c &lt;br&gt;             if hasattr(c, 'free_layout'): &lt;br&gt;                 splitter = c.free_layout.get_top_splitter() &lt;br&gt;                 if splitter: &lt;br&gt;                     splitter.register_provider(self) &lt;br&gt;         def ns_provides(self): &lt;br&gt;             return[('Add matplot', '_add_matplot_pane')] &lt;br&gt;         def ns_provide(self, id_): &lt;br&gt;             if id_ == '_add_matplot_pane': &lt;br&gt;                 c = self.c &lt;br&gt;                 w = QtWidgets.QSlider() ### w = myMatplotWidget() &lt;br&gt;                 return w &lt;br&gt;         def ns_provider_id(self): &lt;br&gt;             # used by register_provider() to unregister previously registered &lt;br&gt;             # providers of the same service &lt;br&gt;             # provider ID is not the same as the service id_ above &lt;br&gt;             return &quot;completely unique value here&quot; &lt;br&gt;      &lt;br&gt;     MatplotPaneProvider(c) &lt;br&gt;  &lt;br&gt; ----- OP &lt;br&gt;  &lt;br&gt; I have managed to get a matplotlib graph embedded within a pane in leo as a widget. I now need some help with how to interact with the widget using scripts in leo. I am unsure about the following: &lt;br&gt;   &lt;br&gt; *1/ How do I expose the widget within the leo environment?*  &lt;br&gt;  &lt;br&gt; If you were only going to have one and you weren't going to destroy it, you could just do something simple like c._matplot = self in its constrictor (assuming c was passed to the constructor). &lt;br&gt;  &lt;br&gt; If you're going to have more than one and they may be destroyed, it might be simplest to let the free_layout / nested_splitter system manage them:: &lt;br&gt;  &lt;br&gt;     ts = c.free_layout.get_top_splitter() &lt;br&gt;     matplotters = ts.findChildren(myMatplotWidget) &lt;br&gt;  &lt;br&gt; should return a list of the widgets of your class in the layout, but only if they're in the main window, widgets in extra windows opened from the &quot;Open window&quot; context menu item would be missed, I can add a find_children() method to complement the find_child() method the splitters already have to account for this. &lt;br&gt;  &lt;br&gt; Detail: the above is just using Qt's QObject.findChildren(), the nested_splitter find_child() and (not yet written) find_children() versions search the extra windows as well. &lt;br&gt;  &lt;br&gt; Here I have created a self.mat in your MatplotPaneProvider class to make the windget accessible but it doesn't feel like the correct way to do this. &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt;  &lt;br&gt;     mat = MatplotPaneProvider(c) &lt;br&gt;     mat.mat.someMethod() &lt;br&gt;     mat.mat.someOtherMethod() &lt;br&gt;      &lt;br&gt; @language rest &lt;br&gt;   &lt;br&gt; 2. I would also like to make the widget accessible from any script within leo. What's the leo way of doing this? &lt;br&gt;  &lt;br&gt; See above &lt;br&gt;   &lt;br&gt; 3. If I create more than 1 pane containing these widgets. How do I switch between them in scripts? &lt;br&gt;  &lt;br&gt; See above &lt;br&gt;  &lt;br&gt; 4. Running this script more than once creates multiple items for Add Matplot when pressing the Action button. How do I stop this from happening? I have already tried returning a unique integer in * ns_provider_id *but that did not work.* &lt;br&gt;   &lt;br&gt; The value returned by ns_provider_id should be unique for the provider class, but constant. So it can just return something like &quot;matplotlib provider ver 1&quot; &lt;br&gt; " id="545" linkTypes="1" links="250" title="How can I create a pane for matplotlib charts?" />
<node body="Find the @file leoApp.py node in leoPy.leo. In the ctor for the LeoApp class set self.use_psyco to True or False. You will find this ctor in the node:: &lt;br&gt;  &lt;br&gt;     Code--&gt;Core classes...--&gt;@file leoApp.py--&gt;app.__init__ &lt;br&gt;  &lt;br&gt; Note that this ivar can not be set using settings in leoSettings.leo because Leo uses g.app.use_psyco before processing configuration settings. &lt;br&gt; " id="546" linkTypes="1" links="250" title="How can I enable and disable support for psyco?" />
<node body="Put the following in the style-sheet: &lt;br&gt;  &lt;br&gt;     QTextEdit#richTextEdit { background-image: url('/home/tbrown/Desktop/cow2.jpg'); } &lt;br&gt;  &lt;br&gt; If you wanted node specific backgrounds Leo would have to start setting an attribute on the body widget, probably the gnx, so you could do:: &lt;br&gt;  &lt;br&gt;     QTextEdit#richTextEdit[leo_gnx='tbrown.20130430222443.19340'] {  &lt;br&gt;         background-image: url('/home/tbrown/Desktop/cow2.jpg');  &lt;br&gt;     } &lt;br&gt; " id="547" linkTypes="1" links="250" title="How can I put background images in the body pane?" />
<node body="You can 'revert' to old key bindings as follows: &lt;br&gt;  &lt;br&gt; 1. Open leoSettings.leo. &lt;br&gt;  &lt;br&gt; 2. Find the node 'Keyboard shortcuts'. &lt;br&gt;  &lt;br&gt; 3. Disable the old bindings by moving the node '@keys EKR bindings: Emacs keys + modes' so that it is a child of the node: '@ignore Unused key bindings'. &lt;br&gt;  &lt;br&gt; 4. Notice that there are two child nodes of the node '@ignore Unused key bindings' that refer to legacy key bindings: &lt;br&gt;  &lt;br&gt;    - '@keys Legacy Leo shortcuts with important Emacs bindings' &lt;br&gt;  &lt;br&gt;    - '@keys Legacy Leo bindings'. &lt;br&gt;  &lt;br&gt; 5. Move **one** of these two legacy nodes up one level so that it is a child of the node 'Keyboard shortcuts'. It should **not** be a child of the node '@ignore Unused key bindings'. &lt;br&gt; " id="548" linkTypes="1" links="250" title="How can I use Leo's legacy key bindings?" />
<node body="c.frame.menu.createMenuItemsFromTable will append items to the end of an existing menu. For example, the following script will add a new item at the end of the 'File' menu:: &lt;br&gt;  &lt;br&gt;     def callback(*args,**keys): &lt;br&gt;         g.trace() &lt;br&gt;  &lt;br&gt;     table = ((&quot;Test1&quot;,None,callback),) &lt;br&gt;  &lt;br&gt;     c.frame.menu.createMenuItemsFromTable('File',table) &lt;br&gt;  &lt;br&gt; Plugins can do anything with menus using c.frame.menu.getMenu. For example, here is a script that adds a Test menu item after the 'Open With' menu item in the File menu:: &lt;br&gt;  &lt;br&gt;     def callback(*args,**keys): &lt;br&gt;         g.trace() &lt;br&gt;  &lt;br&gt;     fileMenu = c.frame.menu.getMenu('File') &lt;br&gt;  &lt;br&gt; # 3 is the position in the menu.  Other kinds of indices are possible:: &lt;br&gt;  &lt;br&gt;     fileMenu.insert(3,'command',label='Test2',command=callback) &lt;br&gt; " id="549" linkTypes="1" links="250" title="How do I add a new menu item from a plugin?" />
<node body="You set most colors in the following settings node:: &lt;br&gt;  &lt;br&gt;     @data qt-gui-plugin-style-sheet &lt;br&gt;      &lt;br&gt; However, settings for colors that can change during Leo's execution are found in the node:: &lt;br&gt;  &lt;br&gt;     Body pane colors &lt;br&gt;      &lt;br&gt; These settings are as follows, with the defaults as shown:: &lt;br&gt;      &lt;br&gt;     @color body_cursor_background_color = None &lt;br&gt;     @color body_cursor_foreground_color = None &lt;br&gt;     @color body_insertion_cursor_color = None &lt;br&gt;     @color body_text_background_color = None &lt;br&gt;     @color body_text_foreground_color = None &lt;br&gt;     @color command_mode_bg_color = #f2fdff &lt;br&gt;     @color command_mode_fg_color = None &lt;br&gt;     @color insert_mode_bg_color = #fdf5f5 &lt;br&gt;     @color insert_mode_fg_color = black &lt;br&gt;     @color overwrite_mode_bg_color = azure2 &lt;br&gt;     @color overwrite_mode_fg_color = black &lt;br&gt;     @color unselected_body_bg_color = #ffffef &lt;br&gt;     @color unselected_body_fg_color = black &lt;br&gt; " id="550" linkTypes="1" links="250" title="How do I set selection colors?" />
<node body="When using the Qt gui, you specify fonts using the node in leoSettings.leo called:: &lt;br&gt;  &lt;br&gt;     @data qt-gui-plugin-style-sheet &lt;br&gt;  &lt;br&gt; As usual, you will probably want to put this node in your myLeoSettings.leo file. &lt;br&gt; " id="551" linkTypes="1" links="250" title="How do I specify qt fonts?" />
<node body="You have two options:  &lt;br&gt;  &lt;br&gt; - Get git write access, and add the @file file to the plugins directory. &lt;br&gt;  &lt;br&gt; - Just send the @file file to me at edreamleo@gmail.com. &lt;br&gt; " id="552" linkTypes="1" links="250" title="How do I submit a plugin?" />
<node body="You can get the latest official releases of Leo at http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106 &lt;br&gt;  &lt;br&gt; However, if at all possible, it is better to use git to get the latest sources. See the next entry. &lt;br&gt; " id="553" linkTypes="1" links="251" title="Where can I get official releases of Leo?" />
<node body="Many users will want to track the development version of Leo, in order to stay on top of the latest features and bug fixes. Running the development version is quite safe and easy, and it's also a requirement if you want to contribute to Leo. &lt;br&gt;  &lt;br&gt; 1. First, you need to get git from http://git-scm.com/. &lt;br&gt;  &lt;br&gt; 2. Get Leo from GitHub by doing:: &lt;br&gt;  &lt;br&gt;         git clone https://github.com/leo-editor/leo-editor (http access) &lt;br&gt;      &lt;br&gt;    or:: &lt;br&gt;     &lt;br&gt;         git clone git@github.com:leo-editor/leo-editor.git (ssh access) &lt;br&gt;  &lt;br&gt; And that's it! You can run the launchLeo script (in the top-level branch directory) directly. When you want to refresh the code with latest modifications from GitHub, 'run git pull'. &lt;br&gt; " id="554" linkTypes="1" links="251" title="How do I use git to get the latest sources from Leo's GitHub site?" />
<node body="Daily snapshots are available at http://www.greygreen.org/leo/ &lt;br&gt; " id="555" linkTypes="1" links="251" title="How can I get recent snapshots of Leo?" />
<node body="You can simply unpack Leo anywhere and run from there.  You don't need the installer. &lt;br&gt;  &lt;br&gt; From a console window, cd to the top-level leo folder.  Run Leo as follows:: &lt;br&gt;  &lt;br&gt;     python launchLeo.py &lt;br&gt;  &lt;br&gt; To run Leo with Qt look and feel, use the --gui=qt option:: &lt;br&gt;  &lt;br&gt;     python launchLeo.py --gui=qt &lt;br&gt;  &lt;br&gt; To load Leo's source, load leoPyRef.leo:: &lt;br&gt;  &lt;br&gt;     python launchLeo.py --gui=qt leo\\core\\leoPyRef.leo &lt;br&gt; " id="556" linkTypes="1" links="252" title="Leo's installer failed, what do I do?" />
<node body="Missing modules can cause installation problems. If the installer doesn't work (or puts up a dialog containing no text), you may install Leo from the .zip file as described at `How to install Leo on Windows`_. However you are installing Leo, be sure to `run Leo in a console`_. because as a last resort Leo prints error messages to the console. &lt;br&gt;  &lt;br&gt;  &lt;br&gt; " id="557" linkTypes="1" links="252" title="Common problems" />
<node body="First, read the tutorial_. This will be enough to get you started if you just want to use Leo as an outliner_. If you intend to use Leo for programming, read the `programming tutorial`_, then look at Leo's source code in the file LeoPy.leo. Spend 5 or 10 minutes browsing through the outline. Don't worry about details; just look for the following common usage patterns: &lt;br&gt;  &lt;br&gt; - The (Projects) tree shows how to use clones to represent tasks. &lt;br&gt;  &lt;br&gt; - Study @file leoNodes.py. It shows how to define more than one class in single file. &lt;br&gt;  &lt;br&gt; - Most other files show how to use a single @others directive to define one class. &lt;br&gt;  &lt;br&gt; - Most methods are defined using @others, *not* section definition nodes. &lt;br&gt; " id="558" linkTypes="1" links="253" title="What's the best way to learn to use Leo?" />
<node body="You will lose much of Leo's power if you don't use clones. See `Clones`_ and `Views`_ for full details. &lt;br&gt; " id="559" linkTypes="1" links="253" title="Why should I use clones?" />
<node body=".. https://groups.google.com/d/msg/leo-editor/4s44H9cUJGY/ewRBDBSw-A8J &lt;br&gt;  &lt;br&gt; For the last several weeks I've used clones in a new, more effective way, inspired by git's stash/unstash commands. Here are the main ideas. &lt;br&gt;  &lt;br&gt; 1. [Most important] I avoid putting clones in two different *external* files. &lt;br&gt;  &lt;br&gt; For any task, I create a task node that resides in @file leoToDo.txt. I clone that node and put it in the outline, *never* in any other @file node. This instantly eliminates clone wars. &lt;br&gt;  &lt;br&gt; 2. I use top-level &quot;stashed&quot; nodes/trees in my local copy of leoPy.leo. &lt;br&gt;  &lt;br&gt; These clones are *not* written to any external file, so they would be lost if I lost leoPy.leo. But the risks are negligible because all stashed nodes are clones of nodes that *do* exist in external files. &lt;br&gt;  &lt;br&gt; 3. I have two main stashed trees: recent files and recent code. &lt;br&gt;  &lt;br&gt; The &quot;recent files&quot; tree contains clones of all the @file nodes I have worked on recently. This speeds up access to them. That happens surprisingly often--often enough to be well worth maintaining the tree. Furthermore, because Leo's new pylint command now works on trees, I can check all recently-changed files simply by running pylint on the &quot;recent files&quot; tree. &lt;br&gt;  &lt;br&gt; The &quot;recent code&quot; tree is even more valuable, for three reasons. The first is obvious--it speeds access to recently-changed nodes. &lt;br&gt;  &lt;br&gt; Second, the &quot;recent code&quot; tree allows me to work on multiple tasks without getting overwhelmed by details and loose nodes lying around. I add organizer nodes as needed to make accessing the nodes faster, and also to jog my memory about what I was doing when I changed those nodes ;-) &lt;br&gt;  &lt;br&gt; Third, the &quot;recent code&quot; tree allows me *not* to put clones in the @file leoProjects.txt tree. This leads me to... &lt;br&gt;  &lt;br&gt; 4. I use clones in a stylized way when fixing and committing bugs. &lt;br&gt;  &lt;br&gt; I always use clones when working on a project. A &quot;task&quot; node contains clones of all nodes related to the task. The task node typically remains in leoToDo.txt until the task is completely finished. While working on the bug, I create a clone of the task node, and move that clone to the bottom top-level node of the outline. Among other things, this makes it easy to limit searches without actually choosing &quot;suboutline only&quot; in the Find panel. This workflow is decades old. &lt;br&gt;  &lt;br&gt; The following is the heart of the new workflow. When a task is complete, I do the following: &lt;br&gt;  &lt;br&gt; A. First, I create a **stashed-task** node, containing all the clones that were previously in the task node. &lt;br&gt;  &lt;br&gt; The *stashed-task* becomes pre-writing for the commit log. The *task* node instantly becomes pre-writing for the release notes, so if it needs to discuss any code in the clones that have just been moved to the stashed-task node, I write those words immediately, while all details are fresh in my mind. &lt;br&gt;  &lt;br&gt; B. Now I move the cloned task node that is in leoToDo.txt to the appropriate place in leoProjects.txt. &lt;br&gt;  &lt;br&gt; C. Next I do the commit. &lt;br&gt;  &lt;br&gt; The *other* clone of the task node, and the stashed task node are still within easy reach, and I typically use both nodes to create the commit log. The commit will typically consist of the changed leoToDo.txt and leoProjects.txt and whatever .py files the task itself changed. Happily, leoToDo.txt and leoProjects.txt are now up-to-date because of steps A and B. &lt;br&gt;  &lt;br&gt; D. Finally, I clean up. &lt;br&gt;  &lt;br&gt; I delete the top-level clone of the task node, and move the stashed-task &lt;br&gt; node to the &quot;recent code&quot; tree. &lt;br&gt;  &lt;br&gt; E. Later, when it appears that activity has died down on various projects, I'll delete nodes from the &quot;recent files&quot; an &quot;recent code&quot; trees. This is a minor judgment call: I want to leave nodes in the trees while they are useful, but not significantly longer than that. I do *not* regard these trees as permanently useful. leoProjects.txt should contain *all* permanent notes about a project. &lt;br&gt;  &lt;br&gt; ===== Conclusions &lt;br&gt;  &lt;br&gt; This work flow may seem complicated. Believe me, it is not. It's easier to use than to describe. &lt;br&gt;  &lt;br&gt; This workflow has big advantages: &lt;br&gt;  &lt;br&gt; 1. Clone wars are gone for good. &lt;br&gt; 2. All recent data is easily available. &lt;br&gt; 3. Task nodes and stashed-task nodes provide natural places for proto-documentation. &lt;br&gt; 4. Banning clones from leoProjects.txt forces me to complete the first draft of the documentation before committing the fix. &lt;br&gt; " id="560" linkTypes="1" links="253" title="How does EKR use clones?" />
<node body="Use methods for any code that is used (called or referenced) more than once. &lt;br&gt;  &lt;br&gt; Sections_ are convenient in the following circumstances: &lt;br&gt;  &lt;br&gt; - When you want to refer to snippets of code the can not be turned into methods. For example, many plugins start with the code like this:: &lt;br&gt;  &lt;br&gt;     &lt;&lt; docstring &gt;&gt; &lt;br&gt;     &lt;&lt; imports &gt;&gt; &lt;br&gt;     &lt;&lt; version history &gt;&gt; &lt;br&gt;     &lt;&lt; globals &gt;&gt; &lt;br&gt;  &lt;br&gt;     None of these sections could be replaced by methods. &lt;br&gt;  &lt;br&gt; - When you want to refer to a snippet of code that shares local variables with the enclosing code. This is surprisingly easy and safe to do, *provided* the section is used only in one place. `Section names`_ in such contexts can be clearer than method names.  For example:: &lt;br&gt;  &lt;br&gt;     &lt;&lt; init ivars for writing &gt;&gt; &lt;br&gt;  &lt;br&gt; In short, I create sections when convenient, and convert them to functions or methods if they need to be used in several places. &lt;br&gt; " id="561" linkTypes="1" links="253" title="When is using a section better than using a method?" />
<node body="A **dangerous** delete is a deletion of a node so that all the data in the node is deleted *everywhere* in an outline. The data is gone, to be retrieved only via undo or via backups. It may not be obvious which deletes are dangerous in an outline containing clones. Happily, there is a very simple rule of thumb:: &lt;br&gt;  &lt;br&gt;     Deleting a non-cloned node is *always* dangerous. &lt;br&gt;     Deleting a cloned node is *never* dangerous. &lt;br&gt;  &lt;br&gt; We could also consider a delete to be dangerous **if it results in a node being omitted from an external file.** This can happen as follows. Suppose we have the following outline (As usual, A' indicates that A is marked with a clone mark):: &lt;br&gt;  &lt;br&gt;     - @file spam.py &lt;br&gt;         - A' &lt;br&gt;             - B &lt;br&gt;     - Projects &lt;br&gt;         - A' &lt;br&gt;             - B &lt;br&gt;  &lt;br&gt; Now suppose we clone B, and move the clone so the tree looks like this:: &lt;br&gt;  &lt;br&gt;     - @file spam.py &lt;br&gt;         - A' &lt;br&gt;             - B' &lt;br&gt;     - Projects &lt;br&gt;         - A' &lt;br&gt;             - B' &lt;br&gt;         - B' &lt;br&gt;  &lt;br&gt; If (maybe much later), we eliminate B' as a child of A will get:: &lt;br&gt;  &lt;br&gt;     - @file spam.py &lt;br&gt;         - A' &lt;br&gt;     - Projects &lt;br&gt;         - A' &lt;br&gt;         - B &lt;br&gt;  &lt;br&gt; B has not been destroyed, but B is gone from @file spam.py! So in this sense deleting a clone node can also be called dangerous. &lt;br&gt; " id="562" linkTypes="1" links="253" title="When is deleting a node dangerous?" />
<node body="Cross-file clones are cloned nodes in one outline that refer to data in another outline. This is a frequently requested feature. For example:: &lt;br&gt;  &lt;br&gt;     I would absolutely love to have the leo files in different project &lt;br&gt;     directories, and a &quot;master&quot; leo file to rule them all. &lt;br&gt;  &lt;br&gt; However, cross-file clones will never be a part of Leo. Indeed, cross-file clones would violate the principle that data should be defined and managed in exactly one place. Just as human managers would not willingly accept shared responsibility for even a single line of code, every piece of Leonine data should be the responsibility of one and *only* one .leo file. &lt;br&gt;  &lt;br&gt; The problem is fundamental. If the *same* (cloned) data were &quot;owned&quot; by two different Leo files we would have a classic &quot;multiple update problem&quot; for the data. Each outline could change the data in incompatible ways, and whichever outline changed the data last would &quot;win.&quot; &lt;br&gt;  &lt;br&gt; To make such a scheme workable and safe, one would have to devise a scheme that would keep the data in &quot;component&quot; .leo files consistent even when the component .leo files changed &quot;randomly&quot;, without the &quot;master&quot; .leo file being in *any* way in &quot;control&quot; of the changes. Good luck :-) &lt;br&gt;  &lt;br&gt; Let us be clear: it's no good having a scheme that works *most* of the time, it must work *all* the time, even with unexpected or even pathological file updates. If it doesn't you are asking for, and will eventually get, catastrophic data loss, without being aware of the loss for an arbitrarily long period of time. Even with a source code control system this would be an intolerable situation. &lt;br&gt; " id="563" linkTypes="1" links="253" title="Why doesn't Leo support cross-file clones?" />
<node body=".. _`This FAQ entry`: FAQ.html#how-can-i-use-leo-to-develop-leo-itself &lt;br&gt;  &lt;br&gt; Here is the workflow I use to develop Leo. The intention is to help present and potential developers use Leo effectively. &lt;br&gt;  &lt;br&gt; Overview: &lt;br&gt;  &lt;br&gt; - Develop in an outline containing all of Leo's source files. Close this outline rarely: this keeps the code I am using stable while I'm hacking the code. &lt;br&gt;  &lt;br&gt; - Test in a *separate* .leo file, say test.leo. In fact, I often test in a private file, ekr.leo, so that test.leo doesn't get continually updated on git with trivial changes. &lt;br&gt;  &lt;br&gt; These two points are covered in a bit more detail in `This FAQ entry`_. &lt;br&gt;  &lt;br&gt; Additional tips: &lt;br&gt;  &lt;br&gt; A. Avoid using the mouse whenever possible. For example, use alt-tab to switch between windows. &lt;br&gt;  &lt;br&gt; B. Always develop Leo in a console. This allows you to see the output of g.trace. &lt;br&gt;  &lt;br&gt; Speaking of g.trace, I hardly ever use 'print' because g.trace prints the name of the function or method in which it appears. The typical pattern for enabling traces is:: &lt;br&gt;  &lt;br&gt;     trace = True and not g.unitTesting &lt;br&gt;     if trace: g.trace(whatever) &lt;br&gt;  &lt;br&gt; This pattern is especially useful when a method contains multiple calls to g.trace. &lt;br&gt;  &lt;br&gt; C. I use scripts to open particular Leo files. These are batch files on Windows, and aliases on Linux, but invoking them is the same on either platform:: &lt;br&gt;  &lt;br&gt;     all:     opens all my main development files using the qt-tabs gui. &lt;br&gt;     t:       opens test.leo. &lt;br&gt;     e:       opens ekr.leo.  I use this file for private testing. &lt;br&gt;     d:       opens LeoDocs.leo. &lt;br&gt;     s:       opens LeoPy.leo. &lt;br&gt;     plugins: opens leoPlugins.leo. &lt;br&gt;     gui:     opens leoGui.leo. &lt;br&gt;     u:       opens unitTest.leo. &lt;br&gt;  &lt;br&gt; These run Leo with Python 3.x. There are similar scripts, ending in 2, that run Leo with Python 2.x. For example, u2 opens unitTest.leo with Python 2.x. Thus, to run a test, I alt-tab to an available console window, then type 'e' or 't' or 'u' or, if I want Python 2.x, 'e2' or 't2' or 'u2'. &lt;br&gt;  &lt;br&gt; D. Use clones to focus attention on the task at hand. For more details, see the tutorial's introduction to `clones`_. &lt;br&gt;  &lt;br&gt; E. For thousand of example of my programming style, see leoPy.leo and leoGuiPlugins.leo. The projects section in leoPy.leo contains many examples of using clones to create view nodes. I typically delete the clones in the views shortly before a release. &lt;br&gt;  &lt;br&gt; Writing documentation: &lt;br&gt;  &lt;br&gt; - Use postings as pre-writing for documentation. I don't mind blabbing on and on about Leo because all my posts become pre-writing for Leo's documentation. I simply copy posts to nodes in the &quot;documentation to-do&quot; section. At release time, I edit these nodes and put them in Leo's main documentation or the release notes. This posting is an example. &lt;br&gt;    &lt;br&gt; - Use the vr command to debug reStructuredText documentation. The viewrendered pane updates as you type. This makes Leo a killer app for rST. &lt;br&gt;     &lt;br&gt; Administrative tips: &lt;br&gt;  &lt;br&gt; - Never rely on memory. A project like this contains thousands and thousands of details. Everything eventually goes into a Leo node somewhere. If it doesn't it surely *will* be forgotten. &lt;br&gt;  &lt;br&gt; - Do easy items first. This keeps to-do lists short, which keeps energy high. &lt;br&gt; " id="564" linkTypes="1" links="253" title="How does EKR (Leo's developer) use Leo?" />
<node body="Some people seem to think that it is difficult to understand how Leo handles &quot;clone wars&quot;: differing values for a cloned nodes that appear in several external files. That's not true. The rule is:: &lt;br&gt;  &lt;br&gt;     **The last clone that Leo reads wins.** &lt;br&gt;  &lt;br&gt; That is, for any cloned node C, Leo takes the value of C.h and C.b to be the values specified by the last copy that Leo reads. &lt;br&gt;  &lt;br&gt; There is only one complication:: &lt;br&gt;  &lt;br&gt;     **Leo reads the entire outline before reading any external files.** &lt;br&gt;  &lt;br&gt; Thus, if C appears in x.leo, y.py and z.py, Leo will choose the value for C in x.py or y.py, depending on which @&lt;file&gt; node appears later in the outline. &lt;br&gt;  &lt;br&gt; **Note**: Whenever Leo detects multiple values for C when opening an outline, Leo creates a &quot;Recovered nodes&quot; tree. This tree contains all the various values for C, nicely formatted so that it is easy to determine where the differences are. &lt;br&gt;  &lt;br&gt; " id="565" linkTypes="1" links="253" title="How does Leo handle clone conflicts?" />
<node body="Use @clean or @auto unless everyone in your work group uses Leo.  In that case, using @file is best. &lt;br&gt;  &lt;br&gt; Leo's repository contains **reference** .leo files. These reference files should contain nothing but @file nodes. Reference files should change only when new external files get added to the project. &lt;br&gt;  &lt;br&gt; Leo's `git repository`_ and Leo distributions contain the following reference files: LeoPyRef.leo, LeoPluginsRef.leo and leoGuiPluginsRef.leo. Developers should use local copies of reference files for their own work. For example, instead of using LeoPyRef.leo directly, I use a copy called LeoPy.leo. &lt;br&gt; " id="566" linkTypes="1" links="254" title="How should I use Leo with git, etc.?" />
<node body="Most people will find using @clean trees to be most useful. Use @auto-rst, @auto-vimoutline or @auto-org when using rST, vimoutline or Emacs org mode files. &lt;br&gt; " id="567" linkTypes="1" links="254" title="How can I use Leo cooperatively without sentinels?" />
<node body=".. .. http://groups.google.com/group/leo-editor/browse_thread/thread/61019e45d75a6f18/71ee770ee4421222 &lt;br&gt;  &lt;br&gt; 1. Archive and remove the previous version of Leo. &lt;br&gt; 2. Download the nightly snapshot zip file. &lt;br&gt; 3. Unzip it into the same place as the previous version. &lt;br&gt; 4. Enjoy your up-to-date Leo code... &lt;br&gt;  &lt;br&gt; To make this work, it's important to keep your folder containing Leo separate from your .mySettings.leo and any data files. &lt;br&gt; " id="568" linkTypes="1" links="254" title="What's the recommended way to upgrade Leo?" />
<node body="The code that handles the rclick menu is in the QtIconBarClass class in qt_frame.py. &lt;br&gt;  &lt;br&gt; Show that the  top-level button contains structure, do this:: &lt;br&gt;  &lt;br&gt;     @string mod_scripting_subtext = ▾ &lt;br&gt;  &lt;br&gt; An alternative: ▼ U=25BC: Black Down-Pointing Triangle. &lt;br&gt;  &lt;br&gt; It's reasonable to have the top-level button just be a placeholder for subsidiary @rclick nodes. To do that without getting a warning when clicking the top-level button, set its script to &quot;empty string&quot;. &lt;br&gt; " id="569" linkTypes="1" links="255" title="How can I create buttons with dropdown menus?" />
<node body="Put @command nodes as children of an @commands node in myLeoSettings.leo. This makes the the @command nodes available to all opened .leo files. &lt;br&gt;  &lt;br&gt; Using @command rather than @button means that there is never any need to disable scripts. There is no need for @button. To see the list of your @command nodes, type:: &lt;br&gt;  &lt;br&gt;     &lt;alt-x&gt;@c&lt;tab&gt; &lt;br&gt;      &lt;br&gt; Similarly to see the list of your @command nodes, type:: &lt;br&gt;  &lt;br&gt;     &lt;alt-x&gt;@b&lt;tab&gt; &lt;br&gt; " id="570" linkTypes="1" links="255" title="How can I make commonly-used scripts widely accessible?" />
<node body="Start your file with:: &lt;br&gt;  &lt;br&gt;     ''' &lt;br&gt;     &lt;&lt; docstring &gt;&gt; &lt;br&gt;     ''' &lt;br&gt;  &lt;br&gt; The &lt;&lt; docstring &gt;&gt; section can just contain:: &lt;br&gt;  &lt;br&gt;     @language rest # or md &lt;br&gt;     @wrap &lt;br&gt;     @others &lt;br&gt;  &lt;br&gt; This allows the &quot;interior&quot; of the docstring to be colored using rST (or markdown). &lt;br&gt; The children of the &lt;&lt; docstring &gt;&gt; node form the actual docstring. No section names are required! &lt;br&gt;  &lt;br&gt; This pattern organizes large docstrings in a Leonine way. The only drawback is that the actual external file contains sentinel lines separating the parts of the docstring. In practice, it's no big deal, especially if each child starts with a blank line. &lt;br&gt; " id="571" linkTypes="1" links="255" title="How can I organize large docstrings?" />
<node body="Leo's pylint command hangs Leo while it is running. The top-level leo-editor folder contains pylint-leo.py and pylint-leo-rc.txt. To run pylint outside of Leo, create a .bat or .sh file to run leo-editor/pylint-leo.py. On Windows, I use this pylint.bat file:: &lt;br&gt;  &lt;br&gt;     python2 c:\leo.repo\leo-editor\pylint-leo.py ^ &lt;br&gt;     rc=c:\leo.repo\leo-editor\leo\test\pylint-leo-rc.txt %* &lt;br&gt;  &lt;br&gt; The -h option produces this:: &lt;br&gt;  &lt;br&gt;     Usage: pylint-leo.py [options] &lt;br&gt;      &lt;br&gt;     Options: &lt;br&gt;       -h, --help   show this help message and exit &lt;br&gt;       -a           all &lt;br&gt;       -c           core &lt;br&gt;       -e           external &lt;br&gt;       -f FILENAME  filename, relative to leo folder &lt;br&gt;       -g           gui plugins &lt;br&gt;       -m           modes &lt;br&gt;       -p           plugins &lt;br&gt;       -s           silent &lt;br&gt;       -u           user commands &lt;br&gt;       -v           report pylint version &lt;br&gt;  &lt;br&gt; My typical usage is pylint -a -s &lt;br&gt; " id="572" linkTypes="1" links="255" title="How can I run pylint outside of Leo?" />
<node body="Use .leo files to test settings rather than to contain data. These files would typically contain just an @settings tree, and one or two nodes illustrating their effect. Opening such files limits the effects of experimental/non-standard/risky settings. This is a great tip to know. &lt;br&gt;  &lt;br&gt; For example, the files leo10pt.leo, leo12pt.leo, leo14-12pt.leo and leo14pt.leo in the leo/config folder make it easy to compare different font settings. &lt;br&gt;  &lt;br&gt; As another example, when starting the vim-mode project I created a .leo file containing @bool vim-mode = True. By opening this file I test vim mode without interfering with my normal work flow. &lt;br&gt; " id="573" linkTypes="1" links="255" title="How can I test settings easily?" />
<node body="@language rest &lt;br&gt;  &lt;br&gt; File under things-I-didn't-know-but-should-have: &lt;br&gt;  &lt;br&gt; Instead of creating batch files all over the place to fire up python programs, and then having to cope with annoying &quot;Terminate batch job (Y/N)?&quot; with Ctrl-C/Break you can ask python setuptools to create an .exe in the Python\Scripts folder. &lt;br&gt;  &lt;br&gt; in same folder as foo.py create setup.py, populate like so:: &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt;  &lt;br&gt;     from setuptools import setup &lt;br&gt;      &lt;br&gt;     setup( &lt;br&gt;         name='Foo for you', &lt;br&gt;         version='0.3', &lt;br&gt;         py_modules=['foo'], &lt;br&gt;         entry_points=''' &lt;br&gt;             [console_scripts] &lt;br&gt;             foo = foo &lt;br&gt;             ''' &lt;br&gt;         ) &lt;br&gt;      &lt;br&gt; @language rest &lt;br&gt;  &lt;br&gt; Then run &quot;pip --editable install . &quot; in the same folder. Foo.exe will be created in C:\pythonxx\Scripts. As long as that folder is in path you can use foo like any other command line program. Furthermore the &quot;editable&quot; parameter means we can continue to edit and change foo.py and the changes are always live. &lt;br&gt;  &lt;br&gt; Yeah! No more &quot;pushd ..\path\to\data\folder &amp;&amp; python ..\path\to\code\foo.py &lt;br&gt; --do-stuff-here ...&quot; for me. :) &lt;br&gt;  &lt;br&gt; Works for Leo too -- with the existing setup.py. It creates leo.exe and leoc.exe for Windowed mode (no log messages to console) and console mode respectively. &lt;br&gt; " id="574" linkTypes="1" links="255" title="How can I use setuptools instead of .bat files?" />
<node body="I am going through something similar Matt Wilkie went through in this post https://groups.google.com/forum/?fromgroups=#!searchin/leo-editor/leopyref/leo-editor/pWyd5ae952I/kvxf_H-QBq4J &lt;br&gt;  &lt;br&gt; Basically I can find interesting functions in LeoPyRef.leo but I don't know how to access them from my new leo scripts. &lt;br&gt;  &lt;br&gt; I don't get the difference when I have to call them using g.Functionname(), c.functionname(), or when those wont do. &lt;br&gt;  &lt;br&gt; How can I call the function &quot;insertIconFromFile&quot;? How can I know how to call functions found in LeoPyRef.leo? &lt;br&gt;  &lt;br&gt; ----- &lt;br&gt;  &lt;br&gt; Ok, in order to print icons, the code is this:: &lt;br&gt;  &lt;br&gt;     c.editCommands.insertIconFromFile(path) &lt;br&gt;  &lt;br&gt; I'm quoting from this Leo manual &lt;br&gt; http://leoeditor.com/scripting.html#important-objects, &lt;br&gt; http://leoeditor.com/scripting.html#inserting-and-deleting-icons &lt;br&gt;  &lt;br&gt; Although I still have a mess on which functions can be called how, and where to find the list of classes that can be called such as &quot;editCommands&quot; and the rest that they might exist. Thanks! &lt;br&gt;  &lt;br&gt; I suppose you could say that there is no general solution, but the situation isn't really all that difficult. &lt;br&gt;  &lt;br&gt; Start with c. We know what that is: it is a commander object representing an open outline. &lt;br&gt;  &lt;br&gt; There are **official ivars** of c, all referring to wrapper classes defined in leoFrame.py:: &lt;br&gt;  &lt;br&gt;     c.frame         an instance of leoFrame. &lt;br&gt;     c.frame.tree    an instance of  leoTree. &lt;br&gt;     c.frame.body    an instance of leoBody. &lt;br&gt;     c.frame.log     an instance of leoLog. &lt;br&gt;  &lt;br&gt; The tree, body and log objects have a *wrapper* object:: &lt;br&gt;  &lt;br&gt;     c.frame.tree.wrapper &lt;br&gt;     c.frame.body.wrapper &lt;br&gt;     c.frame.log.wrapper &lt;br&gt;  &lt;br&gt; See http://leoeditor.com/scripting.html#c-frame-body-bodyctrl for a description of the high-level text interface supported by all high-level text widgets, including the log and body classes. &lt;br&gt;  &lt;br&gt; These wrapper classes have a widget ivar, which is a reference to the corresponding Qt widget object.  For example:: &lt;br&gt;  &lt;br&gt;     import PyQt4.QtGui as QtGui &lt;br&gt;     w =3D c.frame.body.wrapper.widget &lt;br&gt;     g.es(w) &lt;br&gt;     g.es(isinstance(w,QtGui.QTextBrowser) &lt;br&gt;  &lt;br&gt; yields:: &lt;br&gt;  &lt;br&gt;     (LeoQTextBrowser) 62418136 &lt;br&gt;     True &lt;br&gt;  &lt;br&gt; As shown, the LeoQTextBrowser class is a real (subclass of) QTextBrowser. &lt;br&gt;  &lt;br&gt; ==== Terry &lt;br&gt;  &lt;br&gt; I'm not aware of a general solution to the problem of finding the various pieces of Leo's class structure. Basically there are all these classes defined in the source, and instances of these are attached to each other in a hierarchical network (with loops). &lt;br&gt;  &lt;br&gt; I've written an introspection function which lists the methods and instance variables (and class variables) of an arbitrary object by name and by type. I should release it. It builds its lists in a Leo outline, so you can navigate around that outline and expand nodes by introspection as needed. &lt;br&gt;  &lt;br&gt; It occurs to me that the same code could be used to search Leo's runtime object hierarchy for you, i.e. you enter 'insertIconFromFile' and it recursively searches for it. &lt;br&gt;  &lt;br&gt; ----- &lt;br&gt;  &lt;br&gt; I didn't really finish the above para. The problem is that it's hard to guess what the names of the attachment points are, and the attaching is done in a variety of places, sometimes by factory functions which further obscure linkages. Not a fault with Leo, just the way programs work. So the tool I've written may be the best approach to mapping Leo's runtime structure. Another thing it could do, try and map 'major' classes, or at least classes from leo.core.* - i.e. ignore the built in types. &lt;br&gt; " id="575" linkTypes="1" links="255" title="How can scripts call functions from Leo's core?" />
<node body="Leo makes it easy to create and run unit tests from individual outline nodes or trees. A node whose headline starts with @test defines a unit test. The body text of the @test node contains a **self-contained** unit test. For example, this creates a complete unit test:: &lt;br&gt;  &lt;br&gt;     @test fails  (headline) &lt;br&gt;     assert False (body text) &lt;br&gt;  &lt;br&gt; To run this test, select the @test node and do:: &lt;br&gt;  &lt;br&gt;     &lt;alt-x&gt;run-selected-unit-tests-locally. &lt;br&gt;  &lt;br&gt; Leo will create and run the unit test automatically. &lt;br&gt;  &lt;br&gt; To see all of Leo's unit testing commands, do:: &lt;br&gt;  &lt;br&gt;     &lt;alt-x&gt;run&lt;tab&gt; &lt;br&gt;  &lt;br&gt; Leo pre-defines 'c', 'g' and 'p' in unit tests just as in scripts. &lt;br&gt;  &lt;br&gt; For more details about unit testing, see: http://leoeditor.com/unitTesting.html &lt;br&gt;  &lt;br&gt; **Notes for Leo developers** &lt;br&gt;  &lt;br&gt; leo/test/unitTest.leo contains all of Leo's own unit tests. &lt;br&gt;  &lt;br&gt; Running all tests is not necessary.  Just select:: &lt;br&gt;  &lt;br&gt;     Active Unit Tests &lt;br&gt;  &lt;br&gt; and then do Alt-4 (run-selected-unit-tests-locally). &lt;br&gt;  &lt;br&gt; **Note**: Some tests will likely fail on machines other than EKR's. You only need to be concerned about unit tests that start failing after you make your changes. &lt;br&gt; " id="576" linkTypes="1" links="255" title="How do I run unit tests from Leo?" />
<node body="If I want to use leo to make mathematical notes, how can I type in some special mathematical symbols? Or is there a good way to make mathematical notes using leo? &lt;br&gt;  &lt;br&gt; ===== Terry &lt;br&gt;  &lt;br&gt; I use itex2MML with reStructuredText.  So within Leo you're looking at LaTeX math markup, and you get outputs in PDF and XHTML, with MathML in the latter. &lt;br&gt;  &lt;br&gt; ===== Jose &lt;br&gt;  &lt;br&gt; I've been doing this for about a year now.  I use the math docutils directive.  A custom .XCompose file (for example: https://github.com/kragen/xcompose)  also helps. &lt;br&gt;  &lt;br&gt; ===== Terry &lt;br&gt;  &lt;br&gt; I think math was added to docutils after I started using itex2mml, neater to use docutils built in math now I think. &lt;br&gt;  &lt;br&gt; Although having said that, playing with docutils math a bit suggests itex2mml gives more complete support for both MathML and perhaps LaTeX math (with the PDF target). &lt;br&gt;  &lt;br&gt; ===== Jose &lt;br&gt;  &lt;br&gt; Terry, your setup is probably more flexible, but I haven't had any problems with docutils math. It seems to support all the syntax that I've found necessary. &lt;br&gt;  &lt;br&gt; I forgot to mention that the viewrendered plug-in doesn't display math correctly.  I'm not sure what the problem is, I remember trying to figure it out a while back, but I never got anywhere.  It's not really a big problem though, I have scripts to compile nodes to html/pdfs and open them in firefox/pdf reader; math works fine that way. &lt;br&gt;  &lt;br&gt; ===== offray &lt;br&gt;  &lt;br&gt; Is not properly Leo, but is python related, tailored for math and with a web interface and has leo bindings, check IPython: http://ipython.org/ &lt;br&gt;  &lt;br&gt; I'm using it for all my math related writing and I think that point the future of interactive writing in Python. I dream of a body pane on leo with the features of the python qt console. &lt;br&gt; " id="577" linkTypes="1" links="255" title="How to use leo to make mathematical notes?" />
<node body="Running a unit test locally, without exiting Leo, saves a lots of time.  It's much faster than having to load unitTest.leo or even a small .leo file. &lt;br&gt;  &lt;br&gt; The question is, how to use the newest code?  imp.reload often doesn't work. But there is a trick that does work.  Clone the code under development and put it under an @test node.  The script in the @test node uses @others to gain access to the code, not an import. &lt;br&gt;  &lt;br&gt; For instance, here is the @test node I use to develop the new javascript importer:: &lt;br&gt;  &lt;br&gt;     g.cls() &lt;br&gt;     p1 = p.copy() &lt;br&gt;     if c.isChanged(): &lt;br&gt;         c.save() &lt;br&gt;     import leo.plugins.importers.basescanner as basescanner &lt;br&gt;     @others &lt;br&gt;     scanner = JavaScriptScanner(c.importCommands, atAuto = False) &lt;br&gt;     h = '@ignore js-test' &lt;br&gt;     p = g.findNodeAnywhere(c, h) &lt;br&gt;     if p: &lt;br&gt;         while p.firstChild(): &lt;br&gt;             p.firstChild().doDelete() &lt;br&gt;     else: &lt;br&gt;         p = c.insertHeadline() &lt;br&gt;         p.h = h &lt;br&gt;     c.selectPosition(p) &lt;br&gt;     fn = r'c:\prog\jQuery-short2.js' &lt;br&gt;     s = open(fn, 'r').read() &lt;br&gt;     print('Sources..\n\n%s\n\n' % s) &lt;br&gt;     scanner.scan(s, p) &lt;br&gt;     c.selectPosition(p1) &lt;br&gt;     c.redraw() &lt;br&gt;     print('done') &lt;br&gt;  &lt;br&gt; To repeat, the code under test is a child of this node, so the script uses @others to gain access to it.  It's super fast. &lt;br&gt;  &lt;br&gt; You could call this an extension of the &quot;stupendous Aha&quot;." id="578" linkTypes="1" links="255" title="Tip: run unit tests locally using clones" />
<node body="I had a need to figure out why a part of some python code I had written was taking too long. I pulled the code into Leo and the relevant part of the outline looked something like this:: &lt;br&gt;  &lt;br&gt;     + Main module &lt;br&gt;     -- Generate cryptographic key &lt;br&gt;     -- Hashing algorithm &lt;br&gt;  &lt;br&gt; etc. So I cloned just the segment I wanted to profile and pulled it under a new section:: &lt;br&gt;  &lt;br&gt;     + Main module &lt;br&gt;     -- [clone] Generate cryptographic key &lt;br&gt;     -- Hashing algorithm &lt;br&gt;  &lt;br&gt;     + Profiling Experiment &lt;br&gt;     -- [clone] Generate cryptographic key &lt;br&gt;  &lt;br&gt; And in the body of the &quot;Profiling experiment&quot;, I used this code:: &lt;br&gt;  &lt;br&gt;     code_under_here = &quot;&quot;&quot; &lt;br&gt;     @others &lt;br&gt;     &quot;&quot;&quot; &lt;br&gt;  &lt;br&gt;     from timeit import Timer &lt;br&gt;     t = Timer(&quot;print my_key_generator()&quot;, code_under_here) &lt;br&gt;     print t.timeit(number = 10) &lt;br&gt;  &lt;br&gt; And then I hit Control-B to execute the Profiling Experiment body. This let me make adjustments to the code in the clone body and keep hitting Control-B to execute the code with the timeit module to see immediately if what I had done was making a difference. &lt;br&gt;  &lt;br&gt; The great thing about this was that I just used the Leo @others construct to create a wrapper around the code and did not need to litter my code with debug or profiling statements.---Kayvan &lt;br&gt; " id="579" linkTypes="1" links="255" title="What is an easy way to profile code?" />
<node body="The name &quot;Stupendous Aha&quot; is a bit ironical.  From one point of view it may seem obvious. Nevertheless, it was a true Aha for me. &lt;br&gt;  &lt;br&gt; Unit tests permanent check of the correctness of a piece of code. Test Driven Development expands this view. But unit tests are much more important.  In fact, unit tests are *general-purpose helper scripts* that can be run at any time. &lt;br&gt;  &lt;br&gt; 1. Unit tests codify and make explicit desired or expected behavior. &lt;br&gt;  &lt;br&gt; 2. Unit tests are a way of &quot;maintaining attention&quot; on a problem.  Unit &lt;br&gt; tests don't forget, and they are permanent. &lt;br&gt;  &lt;br&gt; 3. Unit tests *do whatever we want*, and they do it automatically. &lt;br&gt;  &lt;br&gt; In short, unit tests are a *master tool* for any programmer or designer. &lt;br&gt; " id="580" linkTypes="1" links="255" title="What is the Stupendous Aha and why does it matter?" />
<node body="**Question**: It would be nice if Leo could open empty files. I tend to be &quot;document oriented&quot; rather than &quot;application oriented&quot; in my thinking and prefer &quot;create empty file at location -&gt; open it with program&quot; to &quot;start program -&gt; create new file -&gt; save it at location&quot;. &lt;br&gt;  &lt;br&gt; **Answer** by Paul Paterson: If you are on Windows 98/2000/XP then the procedure is as follows... &lt;br&gt;  &lt;br&gt; 1. Start Leo &lt;br&gt; 2. Click New &lt;br&gt; 3. Click Save as... &lt;br&gt; 4. Save the file as &quot;c:\\windows\\shellnew\\leofile.leo&quot; (or c:\\winnt for 2000/XP) &lt;br&gt; 5. Open regedit &quot;start...run...regedit&quot; &lt;br&gt; 6. Open HKEY_CLASSES_ROOT and find the &quot;.leo&quot; extension type &lt;br&gt; 7. Go New ... Key from the context menu  &lt;br&gt; 8. Call the new key ShellNew  &lt;br&gt; 9. Select the new key, right-click, choose New...String Value from the context menu &lt;br&gt; 10. Call it FileName  &lt;br&gt; 11. Double-click on the string, and modify it to be the filename of the leofile.leo file you created, including the extension &lt;br&gt; 12. Exit the registry editor and restart Windows Explorer (you may need to reboot on Windows 98) &lt;br&gt;  &lt;br&gt; Now you should have a New:Leo File option in Explorer. This creates a duplicate of the file you saved. This can be useful because you could make a template Leo file containing some standard nodes_ that you always have and then save this. &lt;br&gt; " id="581" linkTypes="1" links="256" title="How can I create a template .leo file?" />
<node body="The c.cloneFindAllAtNode and c.cloneFindAllFlattenedAtNode methods start the clone-find-all and clone-find-all-flattened commands at a particular node. For example, here is the body of ``@button cfa-code @args add`` in leoPy.leo:: &lt;br&gt;  &lt;br&gt;     c.cloneFindAllFlattenedAtNode('Code',top_level=True) &lt;br&gt;      &lt;br&gt; The ``@args add`` part of the headline causes Leo to add the ``cfa-code`` command to Leo's history list, so there is no urgent need to use a separate key binding for this command." id="582" linkTypes="1" links="256" title="How can I customize the clone-find-all commands?" />
<node body="One way is to link directly to the media file from a Leo node_ (with @url) and write a script button to wrap all URL-nodes under the current node_ in a single HTML page. Then, you can view your media in two ways: &lt;br&gt;  &lt;br&gt; - Individually. You can directly click on the @url link to display the media in the browser (assuming you have your MIME/filetype associations set up correctly for your browser). &lt;br&gt;  &lt;br&gt; - In a group. You can click on a script button (you have to code this yourself, very simple) which should collect all @url nodes_ under the current node_ and dynamically generate a HTML page displaying either links to or embedded versions of the media (using the HTML trick described above to invoke the browser). This way, you can create collections of @url nodes under a single node_ (like a bookmark folder), and press a single button to view the @url collection as a single entity in the browser (with all browser capabilities like displaying the media). &lt;br&gt;  &lt;br&gt; You could probably generalize this idea of &quot;collect all @url nodes under current node_ and display as HTML in browser&quot; into a general-purpose plugin. However, the plugin would have to be somewhat smart in mapping a link to its corresponding HTML code (e.g. an image link gets mapped to an &lt;img&gt; HTML tag, a link to a Flash file gets mapped to an &lt;embed&gt; tag, etc). &lt;br&gt; " id="583" linkTypes="1" links="256" title="How can I display graphics in Leo?" />
<node body="Clone wars can be most annoying. The solution is simple:: &lt;br&gt;  &lt;br&gt;     **Keep clones only in the outline and in one other external file** &lt;br&gt;  &lt;br&gt; In particular, catchall files like leo/doc/leoProjects.txt or leo/doc/leoToDo.txt should never contain clones. &lt;br&gt; " id="584" linkTypes="1" links="256" title="How can I eliminate clone wars?" />
<node body="The Import Files dialog allows you to select multiple files provided you are running Python 2.3 or above. There is also an importFiles script in LeoPy.leo.  You can use that script as follows:: &lt;br&gt;  &lt;br&gt;     import leo.core.leoImport as leoImport &lt;br&gt;     leoImport.importFiles(aDirectory, &quot;.py&quot;) &lt;br&gt;  &lt;br&gt; This will import all .py files from aDirectory, which should be a full path to a particular directory. You could use &quot;.c&quot; to import all .c files, etc. &lt;br&gt; " id="585" linkTypes="1" links="256" title="How can I import many files at once?" />
<node body="When organizing data into nodes, **every item should clearly belong to exactly one top-level category**. In other words, avoid top-level *aggregate* categories. &lt;br&gt;  &lt;br&gt; For example, the following are poor top-level categories. They are poor because any item in them could be placed in a more explicit category: &lt;br&gt;  &lt;br&gt; - Contrib &lt;br&gt; - Developing Leo &lt;br&gt; - Important &lt;br&gt; - Maybe &lt;br&gt; - Others &lt;br&gt; - Prototype &lt;br&gt; - Recent &lt;br&gt; - Won't do/Can't do &lt;br&gt;  &lt;br&gt; We all have had bad experiences with the dreaded &quot;Others&quot; category. The Aha! is that all aggregate categories are just as bad as &quot;Others&quot;. &lt;br&gt;  &lt;br&gt; **Note**: I have been talking only about top-level categories.  Within a single category aggregate categories may be useful.  However, when possible I prefer to mark items rather than create subcategories. For example, ``*`` now marks all &quot;Important&quot; items in leoToDo.txt and scripts.leo.  This makes it easy to find important items in a particular category.  To find *all* important items one could do a regex search for ``^\*`` in headlines. &lt;br&gt; " id="586" linkTypes="1" links="256" title="How can I organize data so I can find stuff later?" />
<node body="It sometimes happens that the focus gets left in a Leo widget that doesn't support Leo's key bindings. You would think that you would have to use the mouse to click in, say, the body pane so that you can use Leo's key bindings again. &lt;br&gt;  &lt;br&gt; But you don't have to do that.  Instead, use Alt-tab once to change away from Leo, and then use Alt-tab again to change back to Leo.  When you do this, Leo puts focus in the body pane and you are all set. &lt;br&gt; " id="587" linkTypes="1" links="256" title="How can I restore focus without using the mouse" />
<node body=".. From: http://sourceforge.net/forum/message.php?msg_id=3240374 &lt;br&gt;  &lt;br&gt; Using Leo's File-Export-Flatten Outline commands creates a MORE style outline which places all Leo body sections on the left margin. The headlines_ are indented with tabs which Excel will read as a tab delimited format. Once inside Excel there are benefits. &lt;br&gt;  &lt;br&gt; 1. The most obvious benefit inside Excel is that the body sections (Excel first column) can be selected easily and highlighted with a different font color. This makes the MORE format very readable. Save a copy of your sheet as HTML and now you have a web page with the body sections highlighted. &lt;br&gt;  &lt;br&gt; 2. It is possible to hide columns in Excel. Hiding the first column leaves just the headlines showing. &lt;br&gt;  &lt;br&gt; 3. Formulas based on searching for a string can do calculations in Excel. For example if a heading &quot;Current Assets&quot; appears on level 4 then the body formula:: &lt;br&gt;  &lt;br&gt;         =INDEX(A:A,MATCH(&quot;Current Assets&quot;,D:D,0)+1) &lt;br&gt;  &lt;br&gt; will retrieve it. The +1 after match looks down one row below the matched headline. The trick is to place all your headlines in quotes because Excel will see + &quot;Current Assets&quot; from the MORE outline. When Excel tries without the quotes it thinks it is a range name and displays a #N/A error instead of the headline. Also you must place a child node_ below to get the + sign instead of a - sign which would give a MORE headline of -&quot;Current assets&quot; , also is an error. &lt;br&gt;  &lt;br&gt; I think there is some interesting possibility here because of the enforcement of Leo body text being always in the first column. The Leo outline provides additional reference to organizing the problem not typical of spreadsheet models. Beyond scripting in Python, Excel is good at doing interrelated calculations and detecting problems like circular references. In Excel Tools-Options-General is a setting for r1c1 format which then shows numbers instead of letters for column references. Using this would allow entries like this in the leo body:: &lt;br&gt;  &lt;br&gt;     1000 &lt;br&gt;     3500 &lt;br&gt;     =R[-1]C+R[-2]C &lt;br&gt;  &lt;br&gt; In Excel you would see 4500 below those two numbers. This is completely independent of where the block of three cells exists on the sheet. &lt;br&gt; " id="588" linkTypes="1" links="256" title="How can I show Leo files with Excel?" />
<node body="A frequently requested feature is for clones that don't share children. The typical use case is to gather data from one place to be used in another. For instance, we might want to document a function by special-cloning only its node excluding its children. A **gathering script** can provide most of the benefits of detached clone: &lt;br&gt;  &lt;br&gt; 1. The script has complete flexibility to find a desired positions anywhere, including other .leo files.  This moots the need for cross-file clones. &lt;br&gt;  &lt;br&gt; 2. For any gathered position p, the script has complete flexibility to make available p.h, p.b or p.children, depending on the needs of the script. &lt;br&gt;  &lt;br&gt; For example, a documentation script might &quot;scrape&quot; one or more .leo files for data, and then create nodes that reference the scraped data. &lt;br&gt;  &lt;br&gt;  &lt;br&gt; " id="589" linkTypes="1" links="256" title="How can I simulate more flexible clones?" />
<node body="Use the %~dp0 syntax.  Example:: &lt;br&gt;    &lt;br&gt;   %~dp0\Python27\python.exe %~dp0\Leo-editor\launchLeo.py &lt;br&gt;  &lt;br&gt; http://ss64.com/nt/syntax-args.html &lt;br&gt; http://stackoverflow.com/questions/5034076/what-does-dp0-mean-and-how-does-it-work &lt;br&gt;  &lt;br&gt; FYI, this FAQ entry fixes the following bug: https://bugs.launchpad.net/leo-editor/+bug/613153 unable to describe root directory on thumb drive &lt;br&gt; " id="590" linkTypes="1" links="256" title="How can I specify the root directory of a thumb drive?" />
<node body="https://groups.google.com/d/msg/leo-editor/B3_1e9k69oQ/cLKXFq_fXw8J &lt;br&gt;  &lt;br&gt; I've played a bit with my theme since I wanted a dark one in order to save my eyes. Here is a screenshot: https://lh3.googleusercontent.com/-kb-RnBVq8zU/VIlThQ9MGuI/AAAAAAAAAD8/j-AAOKiHvFI/s1600/leo-dark-ubuntu.png &lt;br&gt;  &lt;br&gt; It's pretty straightforward to get it: &lt;br&gt;  &lt;br&gt; - Install this nice theme: http://gnome-look.org/content/show.php/HackStation?content=167255 &lt;br&gt;  &lt;br&gt; - Override Leo's qt style sheet by adding an empty @data qt-gui-plugin-style-sheet to your @settings &lt;br&gt;  &lt;br&gt; - The only settings that are not handled by qt are the log pane text colors, so add them:: &lt;br&gt;  &lt;br&gt;     @color log_text_foreground_color = #93a1a1 &lt;br&gt;     @color log_error_color = #dc322f &lt;br&gt;     @color log_warning_color = #268bd2 &lt;br&gt;  &lt;br&gt; Finally, I've made a pack of transparent icons to be used more generically: &lt;br&gt;  &lt;br&gt;     @string color_theme = transparent" id="591" linkTypes="1" links="256" title="How can I use a dark theme in Leo?" />
<node body=".. _`this posting about BibTeX citations`: http://groups.google.com/group/leo-editor/browse_thread/thread/d36d76174dcd6786/9c2a298049f4f01c &lt;br&gt;  &lt;br&gt; .. _`raw-data`: http://docutils.sourceforge.net/docs/ref/rst/directives.html#raw-data-pass-through &lt;br&gt;  &lt;br&gt; When using LaTeX and BibTeX, I would like to use inside of Leo a kind of LaTeX-inline-markup, that after generation of the RsT file through Sphinx as well as after running of &quot;make latex&quot;, generate a LaTeX file containing the citation call of the form \cite{CITBook001} as described in a file \*.bib. Is there a way to have Leo/Sphinx/RsT generate the inline raw latex syntax? &lt;br&gt;  &lt;br&gt; Use the docutils `raw-data`_ syntax. Examples:: &lt;br&gt;  &lt;br&gt;     .. role:: raw-role(raw) &lt;br&gt;       :format: html latex &lt;br&gt;     .. raw:: latex &lt;br&gt;       \bibliographystyle{acm} &lt;br&gt;       \bibliography{myBibliography} &lt;br&gt;        &lt;br&gt; For more details, see `this posting about BibTeX citations`_. &lt;br&gt; " id="592" linkTypes="1" links="256" title="How can I use BibTeX citations from Leo?" />
<node body="Clones make reorganizing an outline significantly easier and faster.  Simply make top-level clones of the nodes you keep encountering during the reorg. This makes moving a node a snap: just move it from one clone to another. &lt;br&gt; " id="593" linkTypes="1" links="256" title="How can I use clones to reorganize an outline?" />
<node body="When I study a program, I like to import it into Leo. I have several scripts that do this: some create @auto nodes; others create @file nodes. Whatever the method used, the import process has the potential to change many files. Usually, I just change @auto and @file to @@auto or @@file, so that any changes I make while studying the code won't affect the originals. &lt;br&gt;  &lt;br&gt; But this &quot;safety first&quot; approach means that I can't actually use Leo to insert tracing statements (or for any other changes.) Happily, there is a way to import &quot;live&quot; code into Leo safely:: &lt;br&gt;  &lt;br&gt;    Create a git repository for the code before importing it &lt;br&gt;  &lt;br&gt; The Aha is to create the repository *wherever the code is*, including, &lt;br&gt; say, python/Lib/site-packages. &lt;br&gt;  &lt;br&gt; - git diff ensures that import hasn't significantly altered the code, &lt;br&gt;  &lt;br&gt; This is exactly what I need:  I can make changes to important tools *safely* within Leo. &lt;br&gt; " id="594" linkTypes="1" links="256" title="How can I use git to check Leo's importers?" />
<node body="https://groups.google.com/d/msg/leo-editor/LePOMe_ckeg/_UasKCKP6NMJ &lt;br&gt;  &lt;br&gt; Some time ago there were a discussion about Leo in virtualenv. &lt;br&gt;  &lt;br&gt; Now I could test it in Python3, PyQt5 on Kubuntu: &lt;br&gt;  &lt;br&gt; Here are the steps (I worked in a folder with write permission '/leo'): &lt;br&gt;  &lt;br&gt; 1. Install PyQt5 in the system: &lt;br&gt;  &lt;br&gt; sudo aptitude install python3-pyqt5 &lt;br&gt;  &lt;br&gt; 2. Create the virtual environment with the '--system-site-packages' switch and without pip (I've found this the only way, which worked): &lt;br&gt;  &lt;br&gt; pyvenv-3.4 --system-site-packages --without-pip py3-pyqt5 &lt;br&gt;  &lt;br&gt; 3. Install setuptools and pip into the created environment: &lt;br&gt;  &lt;br&gt; wget --no-check-certificate https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py -O ez_setup.py &lt;br&gt;  &lt;br&gt; py3-pyqt5/bin/python ez_setup.py --insecure &lt;br&gt;  &lt;br&gt; wget --no-check-certificate https://pypi.python.org/packages/source/p/pip/pip-6.0.8.tar.gz#md5=2332e6f97e75ded3bddde0ced01dbda3 &lt;br&gt;  &lt;br&gt; tar xzvf pip-6.0.8.tar.gz &lt;br&gt;  &lt;br&gt; cd pip-6.0.8 &lt;br&gt;  &lt;br&gt; ../py3-pyqt5/bin/python setup.py install &lt;br&gt;  &lt;br&gt; cd .. &lt;br&gt;  &lt;br&gt; Now you can install what you want in the created environment, without affecting the system. &lt;br&gt;  &lt;br&gt; py3-pyqt5/bin/pip install Sphinx &lt;br&gt;  &lt;br&gt; 4. From the leo-editor source folder launch Leo with the new interpreter: &lt;br&gt;  &lt;br&gt; In my case: &lt;br&gt;  &lt;br&gt; /leo/py3-pyqt5/bin/python launchLeo.py" id="595" linkTypes="1" links="256" title="How can I use Leo in virtualenv?" />
<node body="The trick is to create a workflow that separates editing from testing. Putting test code in LeoPy.leo would waste a lot of time. To run tests you would have to exit Leo and reload LeoPy.leo. A much quicker way is to put all test code in a test.leo file. So to change and test code, do the following: &lt;br&gt;  &lt;br&gt; 1. Save LeoPy.leo but do **not** exit Leo. &lt;br&gt;  &lt;br&gt; 2. Quit the copy of Leo running test.leo, then reload test.leo. &lt;br&gt;  &lt;br&gt; 3. Run test scripts from test.leo. &lt;br&gt;  &lt;br&gt; That's all. Python will recompile any changed .py files in the new copy of Leo. **Note**: I create a batch file called t.bat that runs test.leo, so to the &quot;edit-reload-test&quot; cycle is just: &lt;br&gt;  &lt;br&gt; 1. Control-S (in LeoPy.leo: saves the .leo file) &lt;br&gt; 2. t (in a console window: runs test.leo, compiling all changed .py files as a side effect) &lt;br&gt; 3. Control-E (in test.leo: runs the test script) &lt;br&gt;  &lt;br&gt; The benefits of the new workflow: &lt;br&gt;  &lt;br&gt; - test.leo loads  _much_ more quickly than LeoPy.leo does. This new approach can increase the speed of the edit-reload-test cycle by more than a factor of 10. Hitting Control-S, t, Control-E takes about 5 seconds. &lt;br&gt;  &lt;br&gt; - LeoPy.leo runs with the *old* code, so it is much easier to fix syntax errors or exceptions in the *new* code: just fix the problem and save LeoPy.leo *without* closing LeoPy.leo, then restart test.leo. You run your tests on the new code, but you edit the new code with the old, stable code. &lt;br&gt;  &lt;br&gt; - test.leo is the perfect place to develop test. I can create and organize those tests and when I am done, ''test.leo'' is a log of my work. &lt;br&gt; " id="596" linkTypes="1" links="256" title="How can I use Leo to develop Leo itself?" />
<node body="Imo, git rivals python as the greatest productivity tool ever devised for programmers. &lt;br&gt;  &lt;br&gt; My workflow on Ubuntu and Windows is essentially identical. Simple aliases (Ubuntu) and .bat files (Windows) support the following console commands:: &lt;br&gt;  &lt;br&gt;     gs  (expands to git status) &lt;br&gt;     gd (git diff)  Uses an external diff program, &lt;br&gt;                    but I'm starting to prefer text diffs. &lt;br&gt;     ga . (git add .) &lt;br&gt;     ga file (git add file) &lt;br&gt;     gc (git commit: configured to open Scite to create a commit message) &lt;br&gt;     gc -m &quot;a one-line commit message&quot; &lt;br&gt;     push (git push) &lt;br&gt;  &lt;br&gt; I use gitk on both platforms to review commits. &lt;br&gt;  &lt;br&gt; And that's about it. I use &quot;git help&quot; and &quot;git help command&quot; as needed. &lt;br&gt; " id="597" linkTypes="1" links="256" title="How can I use Leo with git?" />
<node body="GTD (Getting Things Done) http://www.amazon.com/Getting-Things-Done-Stress-Free-Productivity/dp/0142000280 is, by far, the best productivity book I have ever read. Many aspects of Leo are idea for putting GTD into practice. &lt;br&gt;  &lt;br&gt; Here is a surprisingly useful workflow tip related to GTD. &lt;br&gt;  &lt;br&gt; Ideas often &quot;intrude&quot; when I am busy with something else. When that happens, I create a top-level node of the form:: &lt;br&gt;  &lt;br&gt;     ** description of idea &lt;br&gt;  &lt;br&gt; Now I can continue what I was doing! This is such a simple idea, but it's really really important: it means I never have to put off getting my ideas into Leo. The &quot;**&quot; draws my attention to the new to-do item. Later, when I am not fully immersed in the previous task, I can put the &quot;**&quot; node somewhere else. &lt;br&gt;  &lt;br&gt; It's super important to deal with new ideas *instantly* but *without* greatly interrupting the task at hand. Creating &quot;**&quot; nodes does that. This new workflow has been a big improvement to my GTD practice. &lt;br&gt; " id="598" linkTypes="1" links="256" title="How can I use the GTD workflow in Leo?" />
<node body="By Rich Ries. I often rework C code that's already been &quot;Leo-ized&quot;--the first pass was quick and dirty to get it going. When I do subsequent passes, I wind up with subnodes that are out of order with the sequence found in the main node_. It's not a big deal, but I like 'em ordered. With just one editor pane, clicking on the node_ to move would switch focus to that node_. I'd then need to re-focus on the main node_. A minor nuisance, but it does slow you down. &lt;br&gt;  &lt;br&gt; My solution is to open a second editor with its focus on the main node_. Switch to the other editor, and, referring to the first editor pane, move the nodes as you like. The second editor's pane will change focus to the node_ you're moving, but the first editor will stay focused on the main node_. It's a lot easier to do than to describe! &lt;br&gt; " id="599" linkTypes="1" links="256" title="How can I use two copies of Leo to advantage?" />
<node body="Making screencasts is a lot easier than you probably think. Here are some tips to get you started quickly. &lt;br&gt;  &lt;br&gt;  &lt;br&gt;  &lt;br&gt;  &lt;br&gt;  &lt;br&gt;  &lt;br&gt;  &lt;br&gt; " id="600" linkTypes="3 3 3 3 3 3 3 3" links="1041 1042 1043 1044 1045 1046 1047 1048" title="How to make a screencast" />
<node body="clone-find-all-flattened often includes clones of nodes whose location is unclear.  No problem! Just select the mysterious node and do Alt-N (goto-next-clone). Leo will select the next clone of that node, wrapping the search as necessary.  One or two Alt-N takes me to the &quot;real&quot; node, the node having an ancestor @&lt;file&gt; node. &lt;br&gt;  &lt;br&gt; Ideally, the meaning of all nodes would be clear from their headlines.  I typically use the following conventions. For section definitions, the headline should contain file or class name.  Examples:: &lt;br&gt;  &lt;br&gt;     &lt;&lt; imports &gt;&gt; (leoCommands.py) &lt;br&gt;     &lt;&lt; docstring &gt;&gt; (LeoApp) &lt;br&gt;  &lt;br&gt; " id="601" linkTypes="1" links="256" title="Why is Alt-N (goto-next-clone) important?" />
<node body="All questions are welcome at http://groups.google.com/group/leo-editor &lt;br&gt; " id="602" linkTypes="1" links="257" title="How do I get help?" />
<node body="Please consider *asking for help* at http://groups.google.com/group/leo-editor before filing bug reports. &lt;br&gt;  &lt;br&gt; Please report bugs at http://bugs.launchpad.net/leo-editor &lt;br&gt;  &lt;br&gt; When reporting a bug, please include *all* of the following: &lt;br&gt;  &lt;br&gt; - The version of Leo used. &lt;br&gt; - The version of Python used. &lt;br&gt; - The platform or platforms used: Linux, Windows, MacOS. &lt;br&gt; - A clear description of the problem. &lt;br&gt; - Information sufficient to recreate the problem. &lt;br&gt;  &lt;br&gt; It's polite to make the bug report self contained, so that six weeks later somebody will be able to understand the report as it stands. &lt;br&gt; " id="603" linkTypes="1" links="257" title="How do I report bugs?" />
<node body="In version 4.5, Leo changed to using a sax parser for .leo files. This can cause problems if your .leo file contains invalid characters. Bugs in previous versions of Leo permitted these bad characters to appear. &lt;br&gt;  &lt;br&gt; The sax parser complains that these characters are not valid in .xml files. Remove these invalid characters as follows: &lt;br&gt;  &lt;br&gt; 1. `run Leo in a console`_, and load the .leo file. Near the bottom of the error message you will see a line like:: &lt;br&gt;  &lt;br&gt;     SAXParseException: &lt;unknown&gt;:123:25: not well-formed (invalid token) &lt;br&gt;  &lt;br&gt; This line reports a bad character at character 25 of line 123. &lt;br&gt;  &lt;br&gt; 2. Open the .leo file in an external editor. The Scite editor, http://www.scintilla.org/SciTE.html, is a good choice because it clearly shows non-printing characters. Remove the invalid character, save the .leo file. &lt;br&gt;  &lt;br&gt; Repeat steps 1 and 2 until all invalid characters are gone. &lt;br&gt; " id="604" linkTypes="1" links="257" title="My old .leo files won't load using Leo 4.5 or later. What should I do?" />
<node body="For the most part, docutils_ does a good job of reporting errors. docutils_ prints a message to the console and inserts an unmistakable error message in the generated .html file. **Important**: On Windows it is helpful to `run Leo in a console`_. &lt;br&gt;  &lt;br&gt; However, in some cases, docutils_ crashes instead of properly reporting the problem. There are several workarounds: &lt;br&gt;  &lt;br&gt; 1.  The crashes I have seen arise from the following bug in docutils. **Hyperlinks in image:: markup must be lower case**.  This will work:: &lt;br&gt;  &lt;br&gt;         .. .. |back| image:: arrow_lt.gif &lt;br&gt;             :target: faq_ &lt;br&gt;  &lt;br&gt;     This will **crash**:: &lt;br&gt;  &lt;br&gt;         .. .. |back| image:: arrow_lt.gif &lt;br&gt;             :target: FAQ_ &lt;br&gt;  &lt;br&gt;     So avoid this crash by making sure to use lower case targets in ':target:' markup. &lt;br&gt;  &lt;br&gt; 2.  You can change the docutils_ source slightly so that it prints a traceback when it crashes. (The rst3 plugin should be able to do this, but I haven't figured out how yet.) It's easy enough to do this: &lt;br&gt;  &lt;br&gt; - Find the file core.py in top-level docutils folder. Typically this folder will be in Python's site-packages folder. &lt;br&gt;  &lt;br&gt; - Open core.py in some editor other than Leo. &lt;br&gt;  &lt;br&gt; - Find the method called report_Exceptions. &lt;br&gt;  &lt;br&gt; - Insert the following lines at the very start of this method:: &lt;br&gt;  &lt;br&gt;         print 'EKR: added traceback' &lt;br&gt;         import traceback ; traceback.print_exc() &lt;br&gt;  &lt;br&gt; This will cause a traceback whenever docutils_ crashes. I have found that such tracebacks are generally enough to locate the general area of the problem. **Note**: These tracebacks go to the console window, so you should `run Leo in a console`_. &lt;br&gt;  &lt;br&gt; 3.  As a last resort, you can isolate syntax errors by reducing your input files until they work again, then adding sections until you get a crash. This is easy enough to do (when using the rst3 plugin) by change a headline 'x' to @rst-ignore-tree x. &lt;br&gt; " id="605" linkTypes="1" links="257" title="Error messages from the rst3 plugin aren't helpful. What can I do?" />
<node body="Leo (and other programs) often send more detailed error messages to stderr, the output stream that goes to the console window. In Linux and MacOS environments, python programs normally execute with the console window visible. On Windows, can run Leo with the console window visible by associating .leo files with python.exe *not* pythonw.exe. &lt;br&gt; " id="606" linkTypes="1" links="257" title="How can I run Leo from a console window?" />
<node body="Just `run Leo in a console`_. At the point you want to drop into the debugger, execute this line:: &lt;br&gt;  &lt;br&gt;     g.pdb() &lt;br&gt;  &lt;br&gt; All output from pdb goes to stdout, which is the console window. It would be good to create a subclass of pdb.Pdb that uses Leo's log pane rather than a console window, but I haven't done that. It could be done easily enough in a plugin... &lt;br&gt;  &lt;br&gt; **Important**: I recommend using g.trace instead of pdb.  For example:: &lt;br&gt;  &lt;br&gt;     g.trace(x) &lt;br&gt;  &lt;br&gt; prints the name of the function or method containing the trace, and the value of &lt;br&gt; x. g.callers is often useful in combination with g.trace. g.callers(5) &lt;br&gt; returns the last 5 entries of the call stack. For example:: &lt;br&gt;  &lt;br&gt;     g.trace(x,g.callers(5)) &lt;br&gt;  &lt;br&gt; Used this way, g.trace shows you patterns that will be invisible using pdb. &lt;br&gt; " id="607" linkTypes="1" links="257" title="How can I use Python's pdb debugger with Leo?" />
<node body="This key is normally bound to delete-comments. It is annoying not to have it work. &lt;br&gt;  &lt;br&gt; For Windows 10, do the following (it may be a bit different for Windows 8): &lt;br&gt;  &lt;br&gt; 1. In the control panel, click Language. &lt;br&gt;    This brings up the &quot;Language&quot; panel. &lt;br&gt;  &lt;br&gt; 2. Choose &quot;Advanced Settings&quot; in the left area. &lt;br&gt;    This brings up the &quot;Advanced Settings&quot; panel. &lt;br&gt;  &lt;br&gt; 3. Choose &quot;Change language bar hot keys&quot; in the left area. &lt;br&gt;    This brings up the &quot;Text Services &amp; Input Language&quot; panel. &lt;br&gt;  &lt;br&gt; 4. You will see Shift-Ctrl-0 as the binding for &quot;Between input languages&quot;. &lt;br&gt;     Select that item and click the &quot;Change Key Sequence&quot; button. &lt;br&gt;     This brings up the &quot;Change Key Sequence&quot; panel. &lt;br&gt;  &lt;br&gt; 5. Set both radio buttons to &quot;Not Assigned&quot; and click OK." id="608" linkTypes="1" links="257" title="How do I make Ctrl-Shift-0 work on Windows 8 or 10?" />
<node body="Installing PyQt on MacOS using:: &lt;br&gt;  &lt;br&gt;     brew install qt sip pyqt &lt;br&gt;      &lt;br&gt; may not always work.  In that case, you will see something like this when running Leo:: &lt;br&gt;  &lt;br&gt;     Traceback (most recent call last): &lt;br&gt;     File &quot;launchLeo.py&quot;, line 8, in &lt;br&gt;     leo.core.runLeo.run() &lt;br&gt;     [Snip] &lt;br&gt;     File &quot;/Users/your-name/git/leo-editor/leo/plugins/qt_text.py&quot;, &lt;br&gt;     line 434, in class LeoLineTextWidget(QtWidgets.QFrame): &lt;br&gt;     AttributeError: 'NoneType' object has no attribute 'QFrame' &lt;br&gt;      &lt;br&gt; You can verify that PyQt has not been installed by setting the trace switch to True in leoQt.py. This will trace the import commands related to Qt and tell you exactly what is happening. &lt;br&gt;  &lt;br&gt; One Leo user gives this advice: &lt;br&gt;  &lt;br&gt; For anyone with similar problem the homebrew instruction for adding PyQT to the import path are wrong. Instead edit ~/.bash_profile and add this line:: &lt;br&gt;      &lt;br&gt;     export PATH=&quot;/usr/local/lib/python2.7/site-packages:${PATH}&quot; &lt;br&gt;      &lt;br&gt; After this leo editor will open with using the default python installation provided by MacOS." id="609" linkTypes="1" links="257" title="I am having trouble installing Leo on MacOS. What should I do?" />
<node body="The import commands insert @ignore directives_ in the top-level node_. Leo does this so that you won't accidentally overwrite your files after importing them. Change the filename following @file (or @file) as desired, then remove the @ignore directive_. Saving the outline will then create the external file. &lt;br&gt; " id="610" linkTypes="1" links="257" title="I can't write Imported files.  What's going on?" />
<node body="Missing modules can cause installation problems. If the installer doesn't work (or puts up a dialog containing no text), you may install Leo from the .zip file as described at `How to install Leo on Windows`_. However you are installing Leo, be sure to `run Leo in a console`_. because as a last resort Leo prints error messages to the console. &lt;br&gt; " id="611" linkTypes="1" links="257" title="Nothing (or almost nothing) happens when I start Leo.  What should I do?" />
<node body="This syntax file hack works well enough to work with Leo '@' markup:: &lt;br&gt;  &lt;br&gt;     syn region leoComment start=&quot;^@\\s*&quot; end=&quot;^@c\\s*$&quot; &lt;br&gt;     syn match   pythonDecorator	&quot;@\\S\\S+&quot; display nextgroup=pythonFunction skipwhite &lt;br&gt; " id="612" linkTypes="1" links="257" title="The new Python decorator syntax causes problems.  What can I do?" />
<node body="Leo's setup.py script is intended only to create source distributions. It can't be used to install Leo because Leo is not a Python package. &lt;br&gt; " id="613" linkTypes="1" links="257" title="Running Python setup.py install from the leo directory doesn't work.  Why not?" />
<node body="Question and answer from plumloco. &lt;br&gt;  &lt;br&gt; Add the equivalent of:: &lt;br&gt;  &lt;br&gt;     import sys  &lt;br&gt;     leocore = &quot;path/to/leo/core&quot;  &lt;br&gt;     if leocore not in sys.path: sys.path.append(leocore)  &lt;br&gt;     import leo.core.leoBridge as leoBridge &lt;br&gt;  &lt;br&gt; at the head of each file that uses leoBridge. &lt;br&gt;  &lt;br&gt; The problem is not importing leoBridge itself but (if I use 'from leo.core') the importing of plugins, who get a different leoGlobals from leoBridge, without g.app etc, and so do not work if they rely on dynamic values in g.etc. &lt;br&gt;  &lt;br&gt; &gt; Why can't you simply add leo/core to sys.path in sitecustomize.py? &lt;br&gt;  &lt;br&gt; Putting leo/core on the python path as you suggest would put forty python modules in the global module namespace for all python programs when I want just one. Also, I have a safe working copy of leo and a cvs/testing version. I would wish to test any programs against the testing version while using the working version, but both /core directories can't be exposed at the same time. &lt;br&gt;  &lt;br&gt; &gt; Do you need plugins while running from the leoBridge?  &lt;br&gt;  &lt;br&gt; Afraid so, at least the rst3 plugin. The solution I am using now is to place:: &lt;br&gt;  &lt;br&gt;     sys.modules['leoGlobals'] = leoGlobals   &lt;br&gt;  &lt;br&gt; in leoBridge after import leo.core.leoGlobals as leoGlobals &lt;br&gt;  &lt;br&gt; This allows my scripts to be portable over the several computers/platforms I need to use them on, and makes testing scripts against multiple leo versions easy. It does mean that my scripts are not portable to other leo users but that is not likely to be a problem. &lt;br&gt; " id="614" linkTypes="1" links="257" title="I can't run the LeoBridge module outside of leo/core.  What should I do?" />
<node body="The update algorithm guarantees *only* that writing an updated @clean outline will generate the updated **public** file.  **Ambiguous lines** could be placed either at the end of one node or the beginning of the following nodes. The update algorithm *guesses* that such lines should be placed at the end of the previous node. &lt;br&gt;  &lt;br&gt; Happily, guesses are not serious. Once you move an ambiguous node and save the Leo file, the update algorithm will not have to guess where the line belongs the next time Leo reads the @clean files. &lt;br&gt; " id="615" linkTypes="1" links="257" title="Why didn't Leo update my @clean outline as expected?" />
<node body="@pagewidth 75 &lt;br&gt;  &lt;br&gt; Q. When I run the following script I see a window appear and then immediately disappear:: &lt;br&gt;  &lt;br&gt;     from PyQt4 import QtGui &lt;br&gt;     w = QtGui.QWidget() &lt;br&gt;     w.resize(250, 150) &lt;br&gt;     w.move(300, 300) &lt;br&gt;     w.setWindowTitle('Simple test') &lt;br&gt;     w.show() &lt;br&gt;      &lt;br&gt; What's going on? &lt;br&gt;  &lt;br&gt; A. When the script exits the sole reference to the window, w, ceases to exist, so the window is destroyed (garbage collected). To keep the window open, add the following code as the last line to keep the reference alive:: &lt;br&gt;  &lt;br&gt;     g.app.scriptsDict['my-script_w'] = w &lt;br&gt;  &lt;br&gt; This reference will persist until the next time you run the execute-script. If you want something even more permanent, you can do something like:: &lt;br&gt;  &lt;br&gt;     g.app.my_script_w = w &lt;br&gt; " id="616" linkTypes="1" links="257" title="Why do Qt windows disappear in my scripts?" />
<node body="Set @bool ignore_unbound_non_ascii_keys = False in LeoSettings.leo or myLeoSettings.leo. &lt;br&gt; " id="617" linkTypes="1" links="258" title="I can not enter non-ascii characters.  What can I do?" />
<node body="Internally, Leo represents all strings as unicode. Leo translates from a particular encoding to Unicode_ when reading .leo files or external files. Leo translates from Unicode_ to a particular encoding when writing external files. You may see strange looking characters if your text editor is expecting a different encoding. The encoding used in any external file is shown in the #@+leo sentinel line like this:: &lt;br&gt;  &lt;br&gt;     #@+leo-encoding=iso-8859-1. &lt;br&gt;  &lt;br&gt; **Exception**: the encoding is UTF-8 if no -encoding= field exists. You can also use the @encoding directive_ to set the encoding for individual external files. If no @encoding directive_ is in effect, Leo uses the following settings_ to translate to and from unicode: &lt;br&gt;  &lt;br&gt; default_derived_file_encoding &lt;br&gt;     The encoding used for external files if no @encoding directive_ is in effect. &lt;br&gt;     This setting also controls the encoding of files that Leo writes. &lt;br&gt;     The default is UTF-8 (case not important). &lt;br&gt;  &lt;br&gt; new_leo_file_encoding &lt;br&gt;     The encoding specified in the following line of new .leo files:: &lt;br&gt;  &lt;br&gt;         &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&gt; &lt;br&gt;  &lt;br&gt;     The default is UTF-8 (upper case for compatibility for old versions of Leo). &lt;br&gt; " id="618" linkTypes="1" links="258" title="Some characters in external files look funny. What can I do?" />
<node body="Add the following to the start of your scripts:: &lt;br&gt;  &lt;br&gt;     @first # -*- coding: utf-8 -*- &lt;br&gt;  &lt;br&gt; Without this line, constructs such as:: &lt;br&gt;  &lt;br&gt;     u = u'a-(2 unicode characters here)-z' &lt;br&gt;     u = 'a-(2 unicode characters here)-z' &lt;br&gt;  &lt;br&gt; will not work when executed with Leo's execute script command. Indeed, the Execute Script command creates the script by writing the tree containing the script to a string. This is done using Leo's write logic, and this logic converts the unicode input to a utf-8 encoded string. So *all non-ascii characters* get converted to their equivalent in the utf-8 encoding. Call these encoding &lt;e1&gt; and &lt;e2&gt;. In effect the script becomes:: &lt;br&gt;  &lt;br&gt;     u = u'a-&lt;e1&gt;-&lt;e2&gt;-z' &lt;br&gt;     u = 'a-&lt;e2&gt;-&lt;e&gt;-z' &lt;br&gt;  &lt;br&gt; which is certainly *not* what the script writer intended! Rather than defining strings using actual characters, Instead, one should use the equivalent escape sequences. For example:: &lt;br&gt;  &lt;br&gt;     u = u'a-\\u0233-\\u8ce2-z' &lt;br&gt;     u = 'a-\\u0233-\\u8ce2-z' &lt;br&gt; " id="619" linkTypes="1" links="258" title="I get weird results when defining unicode strings in scripts.  What is going on?" />
<node body="The encoding used in the file being imported doesn't match the encoding in effect for Leo. Use the @encoding directive_ in an ancestor of the node_ selected when doing the Import command_ to specify the encoding of file to be imported. &lt;br&gt; " id="620" linkTypes="1" links="258" title="Some characters are garbled when importing files. What can I do?" />
<node body="First, you must change Python's default encoding to something other than 'ascii'.  To do this, put the following in your sitecustomize.py file in Python's Lib folder:: &lt;br&gt;  &lt;br&gt;     import sys  &lt;br&gt;     sys.setdefaultencoding('utf-8') # 'iso-8859-1' is another choice. &lt;br&gt;  &lt;br&gt; You must restart Python after doing this: sys.setdefaultencoding can not be called after Python starts up. &lt;br&gt;  &lt;br&gt; Leo's g.es_print and g.pr functions attempts to convert incoming arguments to unicode using the default encoding. For example, the following Leo script shows various ways of printing La Peña properly:: &lt;br&gt;  &lt;br&gt;     @first # -*- coding: utf-8 -*- &lt;br&gt;  &lt;br&gt;     import sys &lt;br&gt;     e = sys.getdefaultencoding() &lt;br&gt;     print 'encoding',e &lt;br&gt;     table = ( &lt;br&gt;         'La Peña', &lt;br&gt;         unicode('La Peña','utf-8'), &lt;br&gt;         u'La Peña', &lt;br&gt;         u'La Pe\\xf1a', &lt;br&gt;     ) &lt;br&gt;  &lt;br&gt;     for s in table: &lt;br&gt;         print type(s) &lt;br&gt;         g.es_print('g.es_print',s) &lt;br&gt;         if type(s) != type(u'a'): &lt;br&gt;             s = unicode(s,e) &lt;br&gt;         print 'print     ',s &lt;br&gt;         print 'repr(s)   ',repr(s) &lt;br&gt;  &lt;br&gt; For still more details, see: http://www.diveintopython.org/xml_processing/unicode.html &lt;br&gt; " id="621" linkTypes="1" links="258" title="Python's print statement shows 'byte hash' for unicode characters.  What can I do?" />
<node body=".. _`Mulder/Ream update algorithm`: http://leoeditor.com/appendices.html#the-mulder-ream-update-algorithm &lt;br&gt;  &lt;br&gt; Use @clean trees. Files derived from @clean trees contain no sentinels_. However, Leo can update @clean trees from changes made to the corresponding external file.  The `Mulder/Ream update algorithm`_ makes this magic happen. &lt;br&gt; " id="622" linkTypes="1" links="259" title="How do I inhibit sentinels in external files?" />
<node body="Use @asis trees. Files derived from @asis trees contain no sentinels. Leo creates the external file simply by writing all body text in outline order. Leo can't update the outline unless the external file contains sentinels, so Leo does not update @asis trees automatically when you change the external file in an external editor. &lt;br&gt; " id="623" linkTypes="1" links="259" title="How do I prevent Leo from expanding sections?" />
<node body="**Question**: I'm writing a Windows Script Component, which is an XML file with a CData section containing javascript. I can get the XML as I want it by using @language html, but how can I get the tangling comments inside the CData section to be java-style comments rather than html ones? &lt;br&gt;  &lt;br&gt; **Answer**: In @file trees you use the @delims directive to change comment delimiters. For example:: &lt;br&gt;  &lt;br&gt;     @delims /* */  &lt;br&gt;     Javascript stuff  &lt;br&gt;     @delims &lt;-- --&gt;  &lt;br&gt;     HTML stuff &lt;br&gt;  &lt;br&gt; **Important**: Leo can not revert to previous delimiters automatically; you must change back to previous delimiters using another @delims directive_. &lt;br&gt; " id="624" linkTypes="1" links="259" title="How can I create Javascript comments?" />
<node body="By Zvi Boshernitzan: I was having trouble disabling '&lt;?php' with comments (and couldn't override the comment character for the start of the page). Finally, I found a solution that worked, using php's heredoc string syntax:: &lt;br&gt;  &lt;br&gt;     @first &lt;?php &lt;br&gt;     @first $comment = &lt;&lt;&lt;EOD &lt;br&gt;     EOD; &lt;br&gt;  &lt;br&gt;     // php code goes here. &lt;br&gt;     echo &quot;boogie&quot;; &lt;br&gt;  &lt;br&gt;     $comment2 = &lt;&lt;&lt;EOD &lt;br&gt;     @last EOD; &lt;br&gt;     @last ?&gt; &lt;br&gt;  &lt;br&gt; or:: &lt;br&gt;  &lt;br&gt;     @first &lt;?php &lt;br&gt;     @first /* &lt;br&gt;     */ &lt;br&gt;  &lt;br&gt;     echo &quot;hi&quot;; &lt;br&gt;  &lt;br&gt;     @delims /* */ &lt;br&gt;     @last ?&gt; &lt;br&gt; " id="625" linkTypes="1" links="259" title="How can I disable PHP comments?" />
<node body="Here is a posting which might be helpful: http://sourceforge.net/forum/message.php?msg_id=2300457 The @first directive_ is the key to output usable code in unsupported languages. For example, to use Leo with the Basic language, use the following:: &lt;br&gt;  &lt;br&gt;     @first $IFDEF LEOHEADER &lt;br&gt;     @delims ' &lt;br&gt;     @c &lt;br&gt;     $ENDIF &lt;br&gt;  &lt;br&gt; So this would enable a basic compiler to &quot;jump&quot; over the &quot;true&quot; Leo-header-lines. Like this:: &lt;br&gt;  &lt;br&gt;     $IFDEF LEOHEADER &lt;-conditional compilation directive  &lt;br&gt;     #@+leo-ver=4 &lt;-these lines not compiled &lt;br&gt;     #@+node:@file QParser005.INC &lt;br&gt;     #@@first &lt;br&gt;     #@delims '  &lt;br&gt;     '@@c &lt;br&gt;     $ENDIF &lt;-... Until here! &lt;br&gt;     &lt;rest of derived code file ... &gt; &lt;br&gt;  &lt;br&gt; This changes the comment symbol the apostrophe, making comments parseable by a BASIC (or other language.) &lt;br&gt; " id="626" linkTypes="1" links="259" title="How can I use Leo with unsupported languages?" />
<node body="Use the @first directive_ in @file or @clean trees. The @first directive puts lines at the very start of files derived from @file. For example, the body text of @file spam.py might be:: &lt;br&gt;  &lt;br&gt;     @first #! /usr/bin/env python &lt;br&gt;  &lt;br&gt; The body text of @file foo.pl might be:: &lt;br&gt;  &lt;br&gt;     @first #/usr/bin/perl &lt;br&gt;  &lt;br&gt; Leo recognizes the @first directive_ only at the start of the body text of @file nodes. No text may precede @first directives_. More than one @first directive may exist, like this:: &lt;br&gt;  &lt;br&gt;     @first #! /usr/bin/env python &lt;br&gt;     @first # more comments. &lt;br&gt; " id="627" linkTypes="1" links="259" title="How do I make external files start with a shebang line?" />
<node body="No. Everything in an @file trees must be part of the external file: orphan and @ignore nodes are invalid in @file trees. This restriction should not be troublesome. For example, you can organize your outline like this:: &lt;br&gt;  &lt;br&gt;     + myClass &lt;br&gt;     ..+ ignored stuff &lt;br&gt;     ..+ @file myClass &lt;br&gt;  &lt;br&gt; (As usual, + denotes a headline.) So you simply create a new node_, called myClass, that holds your @file trees and stuff you don't want in the @file trees. &lt;br&gt; " id="628" linkTypes="1" links="259" title="Can @file trees contain material not in the external file?" />
<node body="By Rich Ries. Some older C compilers don't understand the &quot;//&quot; comment symbol, so using @language C won't work. Moreover, the following does not always work either:: &lt;br&gt;  &lt;br&gt;     @comment /* */ &lt;br&gt;  &lt;br&gt; This generates the following sentinel line:: &lt;br&gt;  &lt;br&gt;     /*@@comment /* */*/ &lt;br&gt;  &lt;br&gt; in the output file, and not all C compilers allow nested comments, so the last \*\/ generates an error. The solution is to use:: &lt;br&gt;  &lt;br&gt;     #if 0 &lt;br&gt;     @comment /* */ &lt;br&gt;     #endif &lt;br&gt;  &lt;br&gt; Leo is happy: it recognizes the @comment directive_. The C compiler is happy: the C preprocessor strips out the offending line before the C compiler gets it. &lt;br&gt; " id="629" linkTypes="1" links="259" title="How can I use Leo with older C compilers" />
<node body="@ignore can only be used in the root node of @file trees.  It tells Leo to ignore the tree. &lt;br&gt;  &lt;br&gt; The @ignore directive can not be used elsewhere in @file trees because of the way Leo recreates outlines from external files. This is an absolutely crucial restriction and will never go away. For a few more details, see `Leo 4.0: Eliminating error 'recovery'`_ in `History of Leo`_. &lt;br&gt;  &lt;br&gt; There are several workaround, as shown in LeoPy.leo: &lt;br&gt;  &lt;br&gt; - keep notes in the outline outside of any external file. &lt;br&gt;  &lt;br&gt; - Use @all to gather notes in a external file, as in done in @file leoProjects.txt. &lt;br&gt; " id="630" linkTypes="1" links="259" title="Why can't I use @ignore directives in @file trees?" />
<node body="**Question**: I must follow a coding standard when writing source code. It includes a maximum line length restriction. How can I know the length of a line when it gets written to the external file? &lt;br&gt;  &lt;br&gt; **Answer**: If a node belongs to a external file hierarchy, its body might get indented when it is written to the external file. It happens when an @others directive or a section name appears indented in a higher-level node body. While (**line**, **col**) in status area show the line and column containing the body text's cursor, **fcol** shows the cursor coordinate relative to the external file, not to the current node. The relation **fcol &gt;= col** is always true. &lt;br&gt; " id="631" linkTypes="1" links="259" title="How can I avoid getting long lines in external files?" />
<node body="When using sphinx you must ensure that sphinx's conf.py file is configured so that it will find the intermediate files created by the rst3 command. For example, the conf.py file for Leo's docs contains the following:: &lt;br&gt;  &lt;br&gt;     source_suffix = '.html.txt' &lt;br&gt;      &lt;br&gt; This &quot;matches&quot; the form of the intermediate files.  For example, given:: &lt;br&gt;  &lt;br&gt;     @rst myDocument.html &lt;br&gt;      &lt;br&gt; and the default value for the rst3_write_intermediate_extension setting:: &lt;br&gt;  &lt;br&gt;     @string rst3_write_intermediate_extension = .txt &lt;br&gt;      &lt;br&gt; the name of intermediate file will be:: &lt;br&gt;  &lt;br&gt;     myDocument.html.txt &lt;br&gt;  &lt;br&gt; myDocument.html.txt is the **input** file for sphinx. &lt;br&gt; " id="632" linkTypes="1" links="286" title="Setting up conf.py for sphinx" />
<node body="Sometimes you want to organize text without creating sections: &lt;br&gt;  &lt;br&gt; 1. Create an outline node to organize your text. &lt;br&gt;  &lt;br&gt; 2. Type the following in the headline:: &lt;br&gt;  &lt;br&gt;     @rst-no-head &lt;any text: it is ignored&gt; &lt;br&gt;      &lt;br&gt; The rst3 command adds the body text of this node to the previous section: &lt;br&gt;  &lt;br&gt; - The headline is ignored. &lt;br&gt; - The @rst-no-head node does not change the rST section structure in any way. &lt;br&gt; " id="633" linkTypes="1" links="292" title="\@rst-no-head suppresses sections" />
<node body="It is often useful to put reference material in your @rst tree that will *not* be included in the actual output. To have the rst3 command ignore a single node, type this in the node's headline:: &lt;br&gt;  &lt;br&gt;     @rst-ignore &lt;ignored-text&gt; &lt;br&gt;      &lt;br&gt; Neither the headline nor body text will be part of the output file. &lt;br&gt;      &lt;br&gt; To have the rst3 command ignore a node and all its descendants, type this in the node's headline:: &lt;br&gt;  &lt;br&gt;     @rst-ignore-tree &lt;ignored-text&gt; &lt;br&gt; " id="634" linkTypes="1" links="292" title="\@rst-ignore &amp; @rst-ignore-tree ignore text" />
<node body="The `rST manual &lt;http://docutils.sourceforge.net/docs/user/rst/quickref.html#directives&gt;`_ tells how to insert &quot;raw&quot; markup into the output. For example, Leo's documentation defines the following:: &lt;br&gt;      &lt;br&gt;     .. |---| unicode:: U+02015 .. for quotes &lt;br&gt;        :trim: &lt;br&gt;  &lt;br&gt; Now ``---`` inserts ---, the unicode &quot;quotation dash&quot; used to indicate the author of quotations. Note that rST automatically turns ``--`` into a dash: --. &lt;br&gt;  &lt;br&gt; The rST ``|`` markup breaks text into specific lines, but there are times when it can't be used.  The following inserts a line break into text:: &lt;br&gt;  &lt;br&gt;     .. |br| raw:: html &lt;br&gt;      &lt;br&gt;        &lt;br /&gt; &lt;br&gt; " id="635" linkTypes="1" links="292" title="Inserting raw markup" />
<node body=".. index:: &lt;br&gt;     pair: Markup; Tutorial &lt;br&gt;      &lt;br&gt; Simple text markup tells Leo how to create an external file from an &lt;br&gt; @clean node and its descendants. Let's look at a step-by-step example: &lt;br&gt;  &lt;br&gt; 1. Create a new outline node whose headline is:: &lt;br&gt;  &lt;br&gt;     @clean myfile.py &lt;br&gt;  &lt;br&gt; 2. Type this in the body of the @clean node:: &lt;br&gt;      &lt;br&gt;     @language python &lt;br&gt;     @tabwidth -4 &lt;br&gt;     &lt;&lt; docstring &gt;&gt; &lt;br&gt;     @others &lt;br&gt;     if __name__ == '__main__': &lt;br&gt;         main() &lt;br&gt;  &lt;br&gt; 3. Create a child of the @clean node whose headline is:: &lt;br&gt;     &lt;br&gt;    &lt;&lt; docstring &gt;&gt; &lt;br&gt;  &lt;br&gt; 4. Type this in the child's body text:: &lt;br&gt;  &lt;br&gt;         '''This is the docstring for the myfile module.''' &lt;br&gt;      &lt;br&gt; 5. Create another child of the @clean node whose headline is:: &lt;br&gt;  &lt;br&gt;         main &lt;br&gt;      &lt;br&gt; 6. Type this in the body of the node:: &lt;br&gt;  &lt;br&gt;         def main(): &lt;br&gt;             print('hello from main') &lt;br&gt;          &lt;br&gt; 7. Save the outline as myfile.leo. This creates myfile.py automatically. &lt;br&gt;     &lt;br&gt; 8. Quit Leo. &lt;br&gt;  &lt;br&gt; 9. Open myfile.py in your favorite text editor. You will see:: &lt;br&gt;  &lt;br&gt;         '''This is the docstring for the myfile module.''' &lt;br&gt;         def main(): &lt;br&gt;             print('hello from main') &lt;br&gt;         if __name__ == '__main__': &lt;br&gt;             main() &lt;br&gt;  &lt;br&gt; Usually you will edit myfile.py from Leo, but Leo can update the outline &lt;br&gt; from changes you make in the text editor! &lt;br&gt;  &lt;br&gt; 10. In your text editor, change the line:: &lt;br&gt;  &lt;br&gt;         print('hello from main') &lt;br&gt;          &lt;br&gt; to:: &lt;br&gt;  &lt;br&gt;         print('hello AGAIN from main') &lt;br&gt;          &lt;br&gt; 11. Save myfile.py and quit your text editor. &lt;br&gt;  &lt;br&gt; 12. Open myfile.leo. Leo reports that the 'main' node has been changed. It's body text is now:: &lt;br&gt;      &lt;br&gt;         def main(): &lt;br&gt;             print('hello AGAIN from main') &lt;br&gt;          &lt;br&gt; Automatic updates of @clean nodes is an important feature of Leo. We'll see &lt;br&gt; how this works later. But first, the next section discusses Leo's markup in &lt;br&gt; detail." id="636" linkTypes="1" links="295" title="Example" />
<node body=".. index:: &lt;br&gt;     pair: Section Name; Tutorial &lt;br&gt;     pair: Section Definition Node; Tutorial &lt;br&gt;     pair: Section Reference; Tutorial &lt;br&gt;     pair: Expansion; Tutorial &lt;br&gt;     pair: Markup; Tutorial &lt;br&gt;     pair: @others; Tutorial &lt;br&gt;      &lt;br&gt; This section discusses Leo's markup. This markup tells how to create &lt;br&gt; external files from @clean trees. &lt;br&gt;  &lt;br&gt; **Essential Terms**: &lt;br&gt;  &lt;br&gt; - A **section name** is any text of the form: &lt;&lt; any text &gt;&gt;. &lt;br&gt;   (&gt;&gt; must not appear in &quot;any text&quot;.) &lt;br&gt;  &lt;br&gt; - A **section definition node** is any node whose headline starts with a &lt;br&gt;   section name. &lt;br&gt;  &lt;br&gt; - A **section reference** is a section name that appears in body text. &lt;br&gt;  &lt;br&gt; | Leo creates external files containing @others directives by writing the *expansion* of the @clean node. &lt;br&gt; | The **expansion** of *any* node is the node's body text after making these text **substitutions**: &lt;br&gt;  &lt;br&gt; 1. Leo replaces @others with the *expansion* of all descendant nodes &lt;br&gt;    **except** section definition nodes. That's how @others got its name. &lt;br&gt;  &lt;br&gt; 2. Leo replaces section references by the *expansion* of the body text of &lt;br&gt;    the corresponding section definition node. &lt;br&gt;     &lt;br&gt; Whitespace is significant before @others and section references. Leo adds &lt;br&gt; the leading whitespace appearing before each @others directive or section &lt;br&gt; reference to every line of their expansion. As a result, Leo can generate &lt;br&gt; external files even for Python.  For example, here is a cute trick:: &lt;br&gt;  &lt;br&gt;     if 1: &lt;br&gt;         &lt;&lt; a section &gt;&gt; &lt;br&gt;     if 0: &lt;br&gt;         @others &lt;br&gt;  &lt;br&gt; **Notes**: &lt;br&gt;  &lt;br&gt; - Neither whitespace nor capitalization are important in section names. &lt;br&gt;   The following section names are equivalent:: &lt;br&gt;    &lt;br&gt;       &lt;&lt; a section &gt;&gt; &lt;br&gt;       &lt;&lt;ASection&gt;&gt; &lt;br&gt;  &lt;br&gt; - Any node may contain a *single* @others directive. No node may contain more &lt;br&gt;   than one @others directive. &lt;br&gt;  &lt;br&gt; - Nodes that *aren't* section definition nodes are included in the expansion &lt;br&gt;   of the *nearest* ancestor node containing an @others directive. &lt;br&gt;    &lt;br&gt; .. index:: &lt;br&gt;     pair: Orphan Node; Tutorial &lt;br&gt;  &lt;br&gt; - An **orphan node** is a descendant of an @clean node not included in any &lt;br&gt;   substitution. Leo refuses to write external files containing orphan &lt;br&gt;   nodes. Instead, Leo writes the @clean tree to the .leo file itself, &lt;br&gt;   thereby preserving all data. &lt;br&gt;  &lt;br&gt; **Example 1**: The body of the @clean node for a typical Python module will &lt;br&gt; look something like:: &lt;br&gt;  &lt;br&gt;     '''A docstring.''' &lt;br&gt;     &lt;&lt; imports &gt;&gt; &lt;br&gt;     @others &lt;br&gt;     if __name__ == '__main__': &lt;br&gt;         main() &lt;br&gt;          &lt;br&gt; **Example 2**:  Here is a typical Python class definition in Leo:: &lt;br&gt;  &lt;br&gt;     class MyClass: &lt;br&gt;         '''A docstring.''' &lt;br&gt;         @others &lt;br&gt; " id="637" linkTypes="1" links="295" title="Markup" />
<node body="Leo 5.1 introduced the ability to update @clean trees from changes made to the corresponding external file. This is one of the most important developments in Leo's history. Previously, Leo could perform such updates only if the external file contained **sentinel lines**, comment lines corresponding to Leo markup that indicated outline structure. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Mulder/Ream update algorithm; Tutorial &lt;br&gt;     pair: Update algorithm; Tutorial &lt;br&gt;      &lt;br&gt; The update algorithm is a clever three-way diff/merge of lines computed &lt;br&gt; from the outline and the external files. You don't have to know how it &lt;br&gt; works in order to use Leo. It is `explained here &lt;http://leoeditor.com/appendices.html#the-mulder-ream-update-algorithm&gt;`_. &lt;br&gt;  &lt;br&gt; In most cases, the update algorithm &quot;just works&quot;. However, there is one &lt;br&gt; edge case that you should be aware of. &lt;br&gt;  &lt;br&gt; **Ambiguous lines** are lines that could be placed either at the end of a &lt;br&gt; node or at the beginning of the following node. The update algorithm must &lt;br&gt; **guess** where to place such lines--there simply is not enough data to &lt;br&gt; know for sure. The algorithm always places ambiguous lines at the end of &lt;br&gt; the previous node because it's more common to add lines to the end of &lt;br&gt; nodes. &lt;br&gt;  &lt;br&gt; The update algorithm is **sound** because guesses do not affect the &lt;br&gt; resulting external file. That is, the contents of the external file will be &lt;br&gt; the same whether an ambiguous line is placed at the end of one node or the &lt;br&gt; beginning of the next. &lt;br&gt;  &lt;br&gt; The exact placement of ambiguous lines may not matter as far as the &lt;br&gt; contents of the external files is concerned, but it will certainly matter &lt;br&gt; to you! You will want lines placed in their proper nodes. &lt;br&gt;  &lt;br&gt; Happily, Leo reports which nodes have been updated. You can override &lt;br&gt; guesses manually by moving lines to a new node. Once you save the outline, &lt;br&gt; the lines will no longer become ambiguous. The next time the update &lt;br&gt; algorithm runs, it will no longer have to guess where the lines belong! &lt;br&gt; " id="638" linkTypes="1" links="295" title="Updating @clean trees" />
<node body=".. index:: &lt;br&gt;     pair: gnx; Tutorial &lt;br&gt;     pair: uA; Tutorial &lt;br&gt;  &lt;br&gt; With @clean and @file, Leo can store **persistent data** in nodes. This information consists of the node's **gnx** (Global Node Index) and the node's **uA**, (User Attributes). The gnx gives each node a unique, immutable identity. Gnx's make clones possible. The uA allows scripts and plugins to associate arbitrarily much additional data with each node. &lt;br&gt;  &lt;br&gt; .. To do: links to further discussion of gnx and uA. &lt;br&gt;  &lt;br&gt; By default, Leo's importers preserve neither gnx's nor uA's. This makes imported @auto trees second class citizens. To remedy this, if an outline contains an @persistence node, Leo will save data in the @persistence tree that allows Leo to recover gnx's and uA's when re-reading @auto files later. This allows clone links and uA's to persist. &lt;br&gt;  &lt;br&gt; @persistence is an optional feature. The stored data is akin to bookmarks. The data can &quot;break&quot; (become inaccessible) if the structure (including class/method/function names) changes. However, the data will typically break infrequently. To disable this feature, just delete an existing @persistence node or change @persistence to @@persistence." id="639" linkTypes="1" links="299" title="Using @persistence" />
<node body=".. index:: &lt;br&gt;     pair: \@path; Tutorial &lt;br&gt;  &lt;br&gt; Rather than specifying long paths in @file nodes, you can specify a path in &lt;br&gt; an ancestor @path node. &lt;br&gt;  &lt;br&gt; For example, suppose three nodes have the following headlines:: &lt;br&gt;  &lt;br&gt;     @path a &lt;br&gt;         @path b &lt;br&gt;             @file c/d.py &lt;br&gt;  &lt;br&gt; The @file node creates the file a/b/c/d.py &lt;br&gt;  &lt;br&gt; Within @path and @&lt;file&gt; paths, ``{{exp}}`` gets evaluated with c, g, p, os and sys predefined.  For example:: &lt;br&gt;  &lt;br&gt;     @file {{os.path.abspath(os.curdir)}}/abc.py &lt;br&gt; " id="640" linkTypes="1" links="300" title="Using @path" />
<node body=".. index:: &lt;br&gt;     pair: @first; Tutorial &lt;br&gt;     pair: @last; Tutorial &lt;br&gt;  &lt;br&gt; The @first directive forces lines to appear before the first sentinel of a &lt;br&gt; external file. For example:: &lt;br&gt;  &lt;br&gt;     @first #! /usr/bin/env python &lt;br&gt;     @first # -*- coding: utf-8 -*- &lt;br&gt;  &lt;br&gt; Similarly, @last forces lines to appear after the last sentinel. &lt;br&gt;  &lt;br&gt; The @first and @last directives aren't necessary within @clean trees, but &lt;br&gt; they are allowed within @clean trees. &lt;br&gt; " id="641" linkTypes="1" links="300" title="Using @first and @last" />
<node body="This chapter uses the following outline (with all nodes expanded) as an ongoing example:: &lt;br&gt;  &lt;br&gt;     + A (clone) &lt;br&gt;       + B &lt;br&gt;         - C &lt;br&gt;       - D &lt;br&gt;     - E &lt;br&gt;     + A (clone) &lt;br&gt;       + B &lt;br&gt;         - C &lt;br&gt;       - D &lt;br&gt;     - F &lt;br&gt;      &lt;br&gt; Only the A nodes are clones of each other. &lt;br&gt;      &lt;br&gt; c.all_positions, when applied to the example tree above, yields:: &lt;br&gt;  &lt;br&gt;     A, B, C, D, E, A, B, C, D, F. &lt;br&gt; " id="642" linkTypes="1" links="317" title="An example outline" />
<node body="This script:: &lt;br&gt;  &lt;br&gt;     def print_p_stack(p): &lt;br&gt;         c,result = p.v.context,[] &lt;br&gt;         v,n = p.v,p.childIndex() &lt;br&gt;         for data in p.stack: &lt;br&gt;             v,n = data &lt;br&gt;             result.append('(%s %s)' % (n,v.h)) &lt;br&gt;         return ','.join(result) &lt;br&gt;      &lt;br&gt;     for p in c.all_positions(): &lt;br&gt;         print('(%s %s) p.stack: %s' % ( &lt;br&gt;             p.childIndex(),p.h,print_p_stack(p))) &lt;br&gt;              &lt;br&gt; yields the following when applied to the example outline:: &lt;br&gt;      &lt;br&gt;     (0 A) p.stack: &lt;br&gt;     (0 B) p.stack: (0 A) &lt;br&gt;     (0 C) p.stack: (0 A),(0 B) &lt;br&gt;     (1 D) p.stack: (0 A) &lt;br&gt;     (1 E) p.stack: &lt;br&gt;     (2 A) p.stack: &lt;br&gt;     (0 B) p.stack: (2 A) &lt;br&gt;     (0 C) p.stack: (2 A),(0 B) &lt;br&gt;     (1 D) p.stack: (2 A) &lt;br&gt;     (3 F) p.stack: &lt;br&gt;  &lt;br&gt; Top-level nodes:: &lt;br&gt;  &lt;br&gt;     (0 A) p.stack: &lt;br&gt;     (1 E) p.stack: &lt;br&gt;     (2 A) p.stack: &lt;br&gt;     (3 F) p.stack: &lt;br&gt;  &lt;br&gt; B:: &lt;br&gt;  &lt;br&gt;     (0 B) p.stack: (0 A) &lt;br&gt;     (0 B) p.stack: (2 A) &lt;br&gt;  &lt;br&gt; C:: &lt;br&gt;  &lt;br&gt;     (0 C) p.stack: (0 A),(0 B) &lt;br&gt;     (0 C) p.stack: (2 A),(0 B) &lt;br&gt;  &lt;br&gt; All Leo generators use a single, ever-changing, position object:: &lt;br&gt;  &lt;br&gt;     for p in c.all_positions(): &lt;br&gt;         print('id(p): %s id(p.v): %s (%s %s) p.stack: %s' % ( &lt;br&gt;             id(p),id(p.v),p.childIndex(),p.h,print_p_stack(p))) &lt;br&gt;  &lt;br&gt; The output is something like:: &lt;br&gt;  &lt;br&gt;     id(p): 214733232 id(p.v): 192725360 (0 A) p.stack: &lt;br&gt;     id(p): 214733232 id(p.v): 192725488 (0 B) p.stack: (0 A) &lt;br&gt;     id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (0 A),(0 B) &lt;br&gt;     id(p): 214733232 id(p.v): 192725520 (1 D) p.stack: (0 A) &lt;br&gt;     id(p): 214733232 id(p.v): 192725392 (1 E) p.stack: &lt;br&gt;     id(p): 214733232 id(p.v): 192725360 (2 A) p.stack: &lt;br&gt;     id(p): 214733232 id(p.v): 192725488 (0 B) p.stack: (2 A) &lt;br&gt;     id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (2 A),(0 B) &lt;br&gt;     id(p): 214733232 id(p.v): 192725520 (1 D) p.stack: (2 A) &lt;br&gt;     id(p): 214733232 id(p.v): 192725584 (3 F) p.stack: &lt;br&gt;      &lt;br&gt; A:: &lt;br&gt;  &lt;br&gt;     id(p): 214733232 id(p.v): 192725360 (0 A) p.stack: &lt;br&gt;     id(p): 214733232 id(p.v): 192725360 (2 A) p.stack: &lt;br&gt;      &lt;br&gt; B:: &lt;br&gt;  &lt;br&gt;     id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (0 A),(0 B) &lt;br&gt;     id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (2 A),(0 B) &lt;br&gt;  &lt;br&gt; C:: &lt;br&gt;  &lt;br&gt;     id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (0 A),(0 B) &lt;br&gt;     id(p): 214733232 id(p.v): 192725552 (0 C) p.stack: (2 A),(0 B) &lt;br&gt;  &lt;br&gt; D:: &lt;br&gt;  &lt;br&gt;     id(p): 214733232 id(p.v): 192725520 (1 D) p.stack: (0 A) &lt;br&gt;     id(p): 214733232 id(p.v): 192725520 (1 D) p.stack: (2 A) &lt;br&gt;      &lt;br&gt; Each Leo outline contains a hidden vnode, c.hiddenRootNode:: &lt;br&gt;  &lt;br&gt;     c.hiddenRootNode.children: [A, E, A, F] &lt;br&gt;     A.children: [B] &lt;br&gt;     B.children: [C] &lt;br&gt;     C.children: [] &lt;br&gt;     D.children: [] &lt;br&gt;     E.children: [] &lt;br&gt;     F.children: [] &lt;br&gt;      &lt;br&gt;     c.hiddenRootNode.parents: [] &lt;br&gt;     A.parents: [c.hiddenRootNode,c.hiddenRootNode] &lt;br&gt;     B.parents: [A] &lt;br&gt;     C.parents: [B] &lt;br&gt;     D.parents: [A] &lt;br&gt;     E.parents: [c.hiddenRootNode] &lt;br&gt;     F.parents: [c.hiddenRootNode] &lt;br&gt; " id="643" linkTypes="1" links="317" title="Example position scripts" />
<node body="Leo stores options in **@settings trees**, outlines whose headline is @settings. When opening a .leo file, Leo looks for @settings trees not only in the outline being opened but also in various leoSettings.leo files. This scheme allows for the following kinds of settings: &lt;br&gt;  &lt;br&gt; - Per-installation or per-machine settings. &lt;br&gt; - Per-user settings. &lt;br&gt; - Per-folder settings. &lt;br&gt; - Per-file settings. &lt;br&gt;  &lt;br&gt; There are four kinds of settings files: &lt;br&gt;  &lt;br&gt; 1. **Default settings files**, named **leoSettings.leo**. Although they can be used in other ways, they typically contain default settings. &lt;br&gt;  &lt;br&gt; 2. **Personal settings files**, named **myLeoSettings.leo**. They provide a way of ensuring that your customized settings are not altered when updating Leo from git or while installing a new version of Leo. The myLeoSettings.leo acts much like Python's site-customize.py file. myLeoSettings.leo will never be part of any Leo distribution, and it will never exist in Leo's cvs repository. This solution is *much* better than trying to update leoSettings.leo with scripts. &lt;br&gt;  &lt;br&gt; 3. **Machine settings files**, named **LeoSettings.leo** (note the capital 'L'), and appearing in a unique directory. &lt;br&gt;  &lt;br&gt;  &lt;br&gt; The following sections describe the kinds of nodes in @settings trees. &lt;br&gt; " id="644" linkTypes="3 3 3 3 3 3 3" links="1049 1050 1051 1052 1053 1054 1055" title="Specifying settings" />
<node body="Leo now allows you to specify input modes. You enter mode x with the enter-x-mode command. The purpose of a mode is to create different bindings for keys within a mode. Often plain keys are useful in input modes. &lt;br&gt;  &lt;br&gt; You can specify modes with @mode nodes in leoSettings.leo. @mode nodes work just like @shortcuts nodes, but in addition they have the side effect of creating the enter-&lt;mode name&gt;-mode command. &lt;br&gt;  &lt;br&gt; Notes: &lt;br&gt;  &lt;br&gt; - You can exit any mode using the keyboard-quit (Control-g) command. This is the **only** binding that is automatically created in each mode. All other bindings must be specified in the @mode node. In particular, the bindings specified in @shortcuts nodes are **not** in effect in mode (again, except for the keyboard-quit binding). &lt;br&gt;  &lt;br&gt; - Leo supports something akin to tab completion within modes: if you type a key that isn't bound in a mode a 'Mode' tab will appear in the log pane. This tab shows all the keys that you can type and the commands to which they are bound. The mode-help command does the same thing. &lt;br&gt;  &lt;br&gt; - @shortcuts nodes specify the bindings for what might be called the 'top-level' mode. These are the bindings in effect when no internal state is present, for example, just after executing the keyboard-quit command. &lt;br&gt;  &lt;br&gt; - The top_level_unbound_key_action setting determines what happens to unbound keys in the top-level mode. Leo ignores unbound keys in all other modes. The possibilities are 'insert', 'replace' and 'ignore'. &lt;br&gt;  &lt;br&gt; - The set-insert-mode, set-overwrite-mode and set-ignore-mode commands alter what happens to unbound keys in the top-level mode. &lt;br&gt;    &lt;br&gt; - If the @mode headline contains ::, everything following the :: is the mode prompt. For example:: &lt;br&gt;      &lt;br&gt;     @mode abc :: xyz &lt;br&gt;      &lt;br&gt; Creates the enter-abc-mode command, but the prompt for the command is xyz. &lt;br&gt;  &lt;br&gt; With all these options it should be possible to emulate the keyboard behavior of any other editor. &lt;br&gt; " id="645" linkTypes="1" links="318" title="Input modes" />
<node body=".. index:: uA &lt;br&gt;  &lt;br&gt; Leo's .leo file format is extensible. The basis for extending .leo files are the v.unknownAttributes ivars of vnodes, also know as **user attributes**, uA's for short. Leo translates between uA's and xml attributes in the corresponding &lt;v&gt; elements in .leo files. Plugins may also use v.tempAttributes ivars to hold temporary information that will *not* be written to the .leo file. These two ivars are called **attribute ivars**. &lt;br&gt;  &lt;br&gt; Attribute ivars must be Python dictionaries, whose keys are names of plugins and whose values are *other* dictionaries, called **inner dictionaries**, for exclusive use of each plugin. &lt;br&gt;  &lt;br&gt; The v.u Python property allows plugins to get and set v.unknownAttributes easily:: &lt;br&gt;  &lt;br&gt;     d = v.u # gets uA (the outer dict) for v &lt;br&gt;     v.u = d # sets uA (the outer dict) for v &lt;br&gt;  &lt;br&gt; For example:: &lt;br&gt;  &lt;br&gt;     plugin_name = 'xyzzy' &lt;br&gt;     d = v.u # Get the outer dict. &lt;br&gt;     inner_d = d.get(plugin_name,{}) # Get the inner dict. &lt;br&gt;     inner_d ['duration']= 5 &lt;br&gt;     inner_d ['notes'] &quot;This is a note.&quot; &lt;br&gt;     d [plugin_name] = inner_d &lt;br&gt;     v.u = d &lt;br&gt;  &lt;br&gt; No corresponding Python properties exist for v.tempAttributes, so the corresponding example would be:: &lt;br&gt;  &lt;br&gt;     plugin_name = 'xyzzy' &lt;br&gt;     # Get the outer dict. &lt;br&gt;     if hasattr(p.v,'tempAttributes'): d = p.v.tempAttributes &lt;br&gt;     else: d = {} &lt;br&gt;     inner_d = d.get(plugin_name,{}) # Get the inner dict. &lt;br&gt;     inner_d ['duration'] = 5 &lt;br&gt;     inner_d ['notes'] = &quot;This is a note.&quot; &lt;br&gt;     d [plugin_name] = inner_d &lt;br&gt;     p.v.tempAttributes = d &lt;br&gt;  &lt;br&gt; **Important**: All members of inner dictionaries should be picklable: Leo uses Python's Pickle module to encode all values in these dictionaries. Leo will discard any attributes that can not be pickled. This should not be a major problem to plugins. For example, instead of putting a tnode into these dictionaries, a plugin could put the tnode's gnx (a string) in the dictionary. &lt;br&gt;  &lt;br&gt; **Note**: Leo does *not* pickle members of inner dictionaries whose name (key) starts with str\_. The values of such members should be a Python string. This convention allows strings to appear in .leo files in a more readable format. &lt;br&gt;  &lt;br&gt; Here is how Leo associates uA's with &lt;v&gt; elements in .leo files: &lt;br&gt;  &lt;br&gt; - **Native xml attributes** are the attributes of &lt;v&gt; elements that are known (treated specially) by Leo's read/write code. The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList, marks, expanded and descendentTnodeUnknownAttributes. All other attributes of &lt;v&gt; and &lt;t&gt; elements are **foreign xml attributes**. &lt;br&gt;  &lt;br&gt; - When reading a .leo file, Leo will create v.unknownAttributes ivars for any vnode whose corresponding &lt;v&gt; or &lt;t&gt; element contains a foreign xml attribute. &lt;br&gt;  &lt;br&gt; - When writing a file, Leo will write foreign xml attributes in &lt;v&gt; elements if the corresponding vnode contains an unknownAttributes ivar. &lt;br&gt;  &lt;br&gt; - Leo performs the usual xml escapes on these strings when reading or writing the unknownAttributes ivars. &lt;br&gt; " id="646" linkTypes="1" links="318" title="Adding extensible attributes to nodes and .leo files" />
<node body=".. _gettext: http://docs.python.org/lib/module-gettext.html &lt;br&gt;  &lt;br&gt; It is easy to translate Leo's menu strings: simply create an @menus tree in leoSettings.leo or myLeoSettings.leo that contains the translated menu names. &lt;br&gt;  &lt;br&gt; **New in Leo 4.4.8**: Leo now contains support for translating messages sent to Leo's log: &lt;br&gt;  &lt;br&gt; - Rather than using an '_' function to denote strings to be translated, Leo's g.es and g.es_print functions translate &quot;odd&quot; (first, third, fifth) arguments, leaving &quot;even&quot; arguments untranslated. Keyword arguments, color, newline, etc. are never translated. &lt;br&gt;  &lt;br&gt; - All calls to g.es and g.es_print in Leo's core follow this convention. &lt;br&gt;  &lt;br&gt; - g.translateString does the actual translation using Python's `gettext`_ module. &lt;br&gt;  &lt;br&gt; - You can use the script in the node &quot;@button print g.es stats&quot; in scripts.leo to create catalogs of all scripts that need to be translated. Such catalogs are used by Python's gettext module. (This script was also used to check that the proper arguments to g.es and g.es_print were translated.) &lt;br&gt; " id="647" linkTypes="1" links="318" title="Translating Leo's menus and messages" />
<node body="This section describes the process of creating an importer for a new language. There are a set of &quot;importers&quot; in leoImport.py, all based on the baseScannerClass class. You can define your own importer by creating a subclass. This shouldn't be too difficult: baseScannerClass is supposed to do almost all the work. With luck, your subclass might be very simple, as with class cScanner. &lt;br&gt;  &lt;br&gt; **Important** As I write this, I realize that I remember very little about the code, but I do remember its general organization and the process of creating a new importer. The following should be all you need to write any importer. &lt;br&gt;  &lt;br&gt; This base class has three main parts: &lt;br&gt;  &lt;br&gt; 1. The &quot;parser&quot; that recognizes where nodes begin and end. &lt;br&gt;  &lt;br&gt; 2. The &quot;code generator&quot; the actually creates the imported nodes. &lt;br&gt;  &lt;br&gt; 3. Checking code that ensures that the imported code is equivalent to the original code. &lt;br&gt;  &lt;br&gt; You should never have to change the code generators or the checking code. Confine your attention to the parser. &lt;br&gt;  &lt;br&gt; The parser thinks it is looking for classes, and within classes, method definitions.  Your job is to tell the parser how to do this. Let's look at part of the ctor for baseScannerClass for clues:: &lt;br&gt;  &lt;br&gt;    # May be overridden in subclasses. &lt;br&gt;    self.anonymousClasses = [] # For Delphi Pascal interfaces. &lt;br&gt;    self.blockCommentDelim1 = None &lt;br&gt;    self.blockCommentDelim2 = None &lt;br&gt;    self.blockCommentDelim1_2 = None &lt;br&gt;    self.blockCommentDelim2_2 = None &lt;br&gt;    self.blockDelim1 = '{' &lt;br&gt;    self.blockDelim2 = '}' &lt;br&gt;    self.blockDelim2Cruft = [] # Stuff that can follow .blockDelim2. &lt;br&gt;    self.classTags = ['class',] # tags that start a tag. &lt;br&gt;    self.functionTags = [] &lt;br&gt;    self.hasClasses = True &lt;br&gt;    self.hasFunctions = True &lt;br&gt;    self.lineCommentDelim = None &lt;br&gt;    self.lineCommentDelim2 = None &lt;br&gt;    self.outerBlockDelim1 = None &lt;br&gt;    self.outerBlockDelim2 = None &lt;br&gt;    self.outerBlockEndsDecls = True &lt;br&gt;    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature. &lt;br&gt;    self.sigFailTokens = [] &lt;br&gt;        # A list of strings that abort a signature when seen in a tail. &lt;br&gt;        # For example, ';' and '=' in C. &lt;br&gt;    self.strict = False # True if leading whitespace is very significant. &lt;br&gt;  &lt;br&gt; Yes, this looks like gibberish. I do *not* remember what all these things do in detail, although obviously the names mean something. What I *do* remember is that these ivars control the operation of the startsFunction and startsClass methods and their helpers (especially startsHelper) and the methods that call them, scan and scanHelper. Most of these methods have a trace var that will enable tracing during importing. &lt;br&gt;  &lt;br&gt; So the strategy is simple: study startsHelper in detail, set the ivars above to make startsHelper do what you want, and trace until things work as you want. &lt;br&gt;  &lt;br&gt; There is one more detail. Sometimes the ivars above are not sufficient to get the job done. In that case, subclasses will override various methods of the parser, but *not* the code generator. If indentation is important, you will want to look at the Python importer. Notice that it overrides skipCodeBlock, called by startsHelper. &lt;br&gt;  &lt;br&gt; That's about it. It would be pointless to give you more details, because those details would lead you *away* from the process you need to follow. Having said that, feel free to ask further questions. I'll be glad to answer them. &lt;br&gt; " id="648" linkTypes="1" links="318" title="Writing new importers" />
<node body="This section discusses options--what they are, how to set them and how to set their defaults. &lt;br&gt; " id="649" linkTypes="3 3 3 3 3 3" links="1056 1057 1058 1059 1060 1061" title="Options" />
<node body="" id="650" linkTypes="3 3 3" links="1062 1063 1064" title="Other topics" />
<node body=".. _ListManagerDocs.html: http://leoeditor.com/ListManagerDocs.html &lt;br&gt; .. _wxListManager.leo:    http://leoeditor.com/wxListManager.leo &lt;br&gt;  &lt;br&gt; The file `ListManagerDocs.html`_ is an impressive example of the kind of output that can be generated relatively easily using the rst3 command. &lt;br&gt;  &lt;br&gt; The source for ListManagerDocs.html is `wxListManager.leo`_. **Important**: wxListManager.leo was written for the old rst2 plugin; it could be greatly simplified if adapted for the rst3 command. &lt;br&gt;  &lt;br&gt; This documentation was created using the rst3 command. The source code for this documentation is in LeoDocs.leo. The source code for the rst3 command is in leoRst.py in leoPy.leo. &lt;br&gt; " id="651" linkTypes="1" links="319" title="Further study" />
<node body="Leo 5.1 substantially simplifies the code in leoRst.py. The only rules: &lt;br&gt;  &lt;br&gt; - All top-level commands must call rst.initSettings, which calls rst.preprocessTree. &lt;br&gt; - Code that writes body text must call rst.init_write. &lt;br&gt;  &lt;br&gt; ``rst.d0`` &lt;br&gt;     This dictionary contains the defaults for each option. Keys are the option name, *not* including the ``rst3_`` prefix. Settings in @settings trees update its entries. &lt;br&gt;      &lt;br&gt; ``rst.dd`` &lt;br&gt;     A dictionary of dictionaries. Keys are vnodes. Values are a dictionary of settings set in that *particular* vnode. &lt;br&gt;  &lt;br&gt; ``rst.getOption(p,name)`` &lt;br&gt;     Searches the ``rst.dd`` and ``rst.d0`` dicts, starting at ``p``, looking for an entry for ``name``. This greatly simplifies the code that creates ``rst.dd``. Surprisingly, this search makes the code about 50% faster. &lt;br&gt; " id="652" linkTypes="1" links="319" title="Theory of operation" />
<node body="The section covers complex options arising from two equivalent problems: &lt;br&gt;  &lt;br&gt; - How to generate documentation from computer source code in a Leo outline. &lt;br&gt; - How to embed documentation in computer source code in a Leo outline. &lt;br&gt;  &lt;br&gt; *Please stop reading now if these problems don't interest you!* &lt;br&gt; " id="653" linkTypes="3 3 3 3" links="1065 1066 1067 1068" title="Advanced topics" />
<node body="Josef Dalcolmo wrote the initial rst plugin. Timo Honkasalo, Bernhard Mulder, Paul Paterson, Kent Tenney and Steve Zatz made contributions to the rst and rst2 plugins. &lt;br&gt; " id="654" linkTypes="1" links="319" title="Acknowledgements" />
<node body=".. _`Specifying settings`: customizing.html#specifying-settings &lt;br&gt;  &lt;br&gt; You enable or disable plugins using @enabled-plugins nodes in leoSettings files (leoSettings.leo, myLeoSettings.leo or the .leo file being loaded). See `Specifying settings`_ for full details of settings files. &lt;br&gt;  &lt;br&gt; The body text of the @enabled-plugins node contains a list of enabled plugins. Notes: &lt;br&gt;  &lt;br&gt; - Leo attempts to load all plugins every time an @enabled-plugins node is seen. If the plugin has already been loaded, Leo silently ignores the request to re-enable the plugin. Leo never attempts to disable a plugin while processing enabled plugin strings. Thus, plugins enabled in an @enabled-plugins node in leoSettings.leo *will* be enabled regardless of the contents of any other @enabled-plugins node. &lt;br&gt;  &lt;br&gt; - g.app.gui.getEnabledPlugins contains the last processed @enabled-plugins node. &lt;br&gt; " id="655" linkTypes="1" links="320" title="Enabling plugins" />
<node body="``active_path.py`` &lt;br&gt;     Synchronizes @path nodes with folders. &lt;br&gt; ``add_directives.py`` &lt;br&gt;     Allows users to define new @directives. &lt;br&gt; ``at_folder.py`` &lt;br&gt;     Synchronizes @folder nodes with folders. &lt;br&gt; ``at_produce.py`` &lt;br&gt;     Executes commands in nodes whose body text starts with @produce. &lt;br&gt; ``at_view.py`` &lt;br&gt;     Adds support for @clip, @view and @strip nodes. &lt;br&gt; ``attrib_edit.py`` &lt;br&gt;     Edits user attributes in a Qt frame. &lt;br&gt; ``backlink.py`` &lt;br&gt;     Allows arbitrary links between nodes. &lt;br&gt; ``bibtex.py`` &lt;br&gt;     Manages BibTeX files with Leo. &lt;br&gt; ``bigdash.py`` &lt;br&gt;     Creates a global search window. &lt;br&gt; ``bzr_qcommands.py`` &lt;br&gt;     Adds a context menu to each node containing all the commands in the bzr Qt &lt;br&gt;     interface. Bzr is invoked based on the path of the current node. &lt;br&gt; ``chapter_hoist.py`` &lt;br&gt;     Creates hoist buttons. &lt;br&gt; ``colorize_headlines.py`` &lt;br&gt;     Manipulates appearance of individual tree widget items. &lt;br&gt; ``contextmenu.py`` &lt;br&gt;     Defines various useful actions for context menus (Qt only). &lt;br&gt; ``datenodes.py`` &lt;br&gt;     Allows users to insert headlines containing dates. &lt;br&gt; ``debugger_pudb.py`` &lt;br&gt;     Makes g.pdb() enter the Pudb debugger instead of pdb. &lt;br&gt; ``detect_urls.py`` &lt;br&gt;     Colorizes URLs everywhere in a node's body on node selection or saving. &lt;br&gt;     Double clicking on any URL launches it in the default browser. &lt;br&gt; ``dtest.py`` &lt;br&gt;     Sends code to the doctest module and reports the result. &lt;br&gt; ``dump_globals.py`` &lt;br&gt;     Dumps Python globals at startup. &lt;br&gt; ``EditAttributes.py`` &lt;br&gt;     Lets the user associate text with a specific node. &lt;br&gt; ``empty_leo_file.py`` &lt;br&gt;     Allows Leo to open any empty file as a minimal .leo file. &lt;br&gt; ``enable_gc.py`` &lt;br&gt;     Enables debugging and tracing for Python's garbage collector. &lt;br&gt; ``expfolder.py`` &lt;br&gt;     Adds @expfolder nodes that represent folders in the file system. &lt;br&gt; ``FileActions.py`` &lt;br&gt;     Defines actions taken when double-clicking on @&lt;file&gt; nodes and &lt;br&gt;     supports @file-ref nodes. &lt;br&gt; ``geotag.py`` &lt;br&gt;     Tags nodes with latitude and longitude. &lt;br&gt; ``graphcanvas.py`` &lt;br&gt;     Adds a graph layout for nodes in a tab. &lt;br&gt;     Requires Qt and the backlink.py plugin. &lt;br&gt; ``import_cisco_config.py`` &lt;br&gt;     Allows the user to import Cisco configuration files. &lt;br&gt; ``initinclass.py`` &lt;br&gt;     Modifies the Python @auto importer so that the importer &lt;br&gt;     puts the __init__ method (ctor) into the body of the class node. &lt;br&gt; ``interact.py`` &lt;br&gt;     Adds buttons so Leo can interact with command line environments. &lt;br&gt; ``ipython.py`` &lt;br&gt;     Creates a two-way communication (bridge) between Leo &lt;br&gt;     scripts and IPython running in the console from which Leo was launched. &lt;br&gt; ``leo_interface.py`` &lt;br&gt;     Allows the user to browse XML documents in Leo. &lt;br&gt; ``leo_pdf.py`` &lt;br&gt;     This NOT a Leo plugin: this is a docutils writer for .pdf files. &lt;br&gt; ``leo_to_html.py`` &lt;br&gt;     Converts a leo outline to an html web page.**. &lt;br&gt; ``leo_to_rtf.py`` &lt;br&gt;     Outputs a Leo outline as a numbered list to an RTF file. The RTF file can be &lt;br&gt;     loaded into Microsoft Word and formatted as a proper outline. &lt;br&gt; ``leocursor.py`` &lt;br&gt;     Creates a LeoCursor object that can walk around a Leo outline and decode &lt;br&gt;     attributes from nodes. &lt;br&gt; ``leomylyn.py`` &lt;br&gt;     Provides a &quot;Mylyn&quot; like experience for Leo. &lt;br&gt; ``leoremote.py`` &lt;br&gt;     Remote control for Leo. &lt;br&gt; ``leoscreen.py`` &lt;br&gt;     Allows interaction with shell apps via screen. &lt;br&gt; ``lineNumbers.py`` &lt;br&gt;     Adds #line directives in perl and perlpod programs.    &lt;br&gt; ``livecode.py`` &lt;br&gt;     Creates a live code-evaluation pane. &lt;br&gt; ``macros.py`` &lt;br&gt;     Creates new nodes containing parameterized section references. &lt;br&gt; ``maximizeNewWindows.py`` &lt;br&gt;     Maximizes all new windows. &lt;br&gt; ``mime.py`` &lt;br&gt;     Opens files with their default platform program. &lt;br&gt; ``mod_autosave.py`` &lt;br&gt;     Autosaves the Leo outline every so often. &lt;br&gt; ``mod_framesize.py`` &lt;br&gt;     Sets a hard coded frame size. &lt;br&gt; ``mod_http.py`` &lt;br&gt;     A minimal http plugin for Leo, based on AsyncHttpServer.py. &lt;br&gt; ``mod_read_dir_outline.py`` &lt;br&gt;     Allows Leo to read a complete directory tree into a Leo outline. Converts &lt;br&gt;     directories into headlines and puts the list of file names into bodies. &lt;br&gt; ``mod_scripting.py`` &lt;br&gt;     Creates script buttons and @button, @command, @plugin and @script nodes. &lt;br&gt; ``mod_timestamp.py`` &lt;br&gt;     Timestamps all save operations to show when they occur. &lt;br&gt; ``multifile.py`` &lt;br&gt;     Allows Leo to write a file to multiple locations. &lt;br&gt; ``nav_qt.py`` &lt;br&gt;     Adds &quot;Back&quot; and &quot;Forward&quot; buttons (Qt only). &lt;br&gt; ``niceNosent.py`` &lt;br&gt;     Ensures that all descendants of @file-nosent nodes end &lt;br&gt;     with exactly one newline, replaces all tabs with spaces, and &lt;br&gt;     adds a newline before class and functions in the derived file. &lt;br&gt; ``nodeActions.py`` &lt;br&gt;     Allows the definition of double-click actions.    &lt;br&gt; ``nodeTags.py`` &lt;br&gt;     Provides node tagging capabilities to Leo. &lt;br&gt; ``open_shell.py`` &lt;br&gt;     Creates an 'Extensions' menu containing two commands: &lt;br&gt;     Open Console Window and Open Explorer. &lt;br&gt; ``outline_export.py`` &lt;br&gt;     Modifies the way exported outlines are written. &lt;br&gt; ``paste_as_headlines.py`` &lt;br&gt;     Creates new headlines from clipboard text. &lt;br&gt; ``plugins_menu.py`` &lt;br&gt;     Creates a Plugins menu and adds all actives plugins to it. &lt;br&gt; ``pretty_print.py`` &lt;br&gt;     Customizes pretty printing.    &lt;br&gt; ``printing.py`` &lt;br&gt;     Supports printing for the Qt gui. &lt;br&gt; ``projectwizard.py`` &lt;br&gt;     Creates a wizard that creates @auto nodes. &lt;br&gt; ``quickMove.py`` &lt;br&gt;     Creates buttons to move nodes quickly to other nodes. &lt;br&gt; ``quicksearch.py`` &lt;br&gt;     Adds a fast-to-use search widget, like the &quot;Find in files&quot; feature of many editors. &lt;br&gt; ``quit_leo.py`` &lt;br&gt;     Shows how to force Leo to quit. &lt;br&gt; ``read_only_nodes.py`` &lt;br&gt;     Creates and updates @read-only nodes. &lt;br&gt; ``redirect_to_log.py`` &lt;br&gt;     Sends all output to the log pane. &lt;br&gt; ``run_nodes.py`` &lt;br&gt;     Runs a program and interface Leos through its input/output/error streams.    &lt;br&gt; ``screen_capture.py`` &lt;br&gt;     Supports taking screen shots. See http://leo-editor.github.io/screen_capture.html &lt;br&gt; ``screenshots.py`` &lt;br&gt;     Creates stand-alone slideshows containing screenshots. &lt;br&gt; ``script_io_to_body.py`` &lt;br&gt;     Sends output from the Execute Script command to the end of the body pane. &lt;br&gt; ``scripts_menu.py`` &lt;br&gt;     Creates a Scripts menu for LeoPy.leo. &lt;br&gt; ``scrolledmessage.py`` &lt;br&gt;     Provides a Scrolled Message Dialog service for Qt. &lt;br&gt; ``setHomeDirectory.py`` &lt;br&gt;     Sets g.app.homeDir to a hard-coded path. &lt;br&gt; ``slideshow.py`` &lt;br&gt;     Support slideshows in Leo outlines. &lt;br&gt; ``spydershell.py`` &lt;br&gt;     Launches the spyder environment with access to Leo instance. &lt;br&gt;     See http://packages.python.org/spyder/. &lt;br&gt; ``startfile.py`` &lt;br&gt;     Launches (starts) a file given by a headline when double-clicking the icon. &lt;br&gt; ``stickynotes.py`` &lt;br&gt;     Adds simple &quot;sticky notes&quot; feature (popout editors) for Qt gui. &lt;br&gt; ``timestamp.py`` &lt;br&gt;     Manages attributes containing node creation/modification/viewed times. &lt;br&gt; ``todo.py`` &lt;br&gt;     Provides to-do list and simple task management for leo (Qt only). &lt;br&gt; ``tomboy_import.py`` &lt;br&gt;     Allows imports of notes created in Tomboy / gnote. &lt;br&gt; ``trace_gc_plugin.py`` &lt;br&gt;     Traces changes to Leo's objects at idle time. &lt;br&gt; ``trace_keys.py`` &lt;br&gt;     Traces keystrokes in the outline and body panes. &lt;br&gt; ``trace_tags.py`` &lt;br&gt;     Traces most common hooks, but not key, drag or idle hooks. &lt;br&gt; ``valuespace.py`` &lt;br&gt;     Supports outline-based calculations similar to spreadsheets. &lt;br&gt; ``viewrendered.py`` &lt;br&gt;     Creates a window for *live* rendering of rst, html, etc. &lt;br&gt;     This plugin uses docutils, http://docutils.sourceforge.net/, &lt;br&gt;     to do the rendering, so installing docutils is recommended. &lt;br&gt;     Supports @graphics-script, @image, @html, @movie and @svg nodes. &lt;br&gt; ``viewrendered2.py`` &lt;br&gt;     An alternate/enhanced version of viewrendered.py. &lt;br&gt; ``vim.py`` &lt;br&gt;     Enables two-way communication with VIM. &lt;br&gt; ``word_count.py`` &lt;br&gt;     Counts characters, words, lines, and paragraphs in the body pane. &lt;br&gt; ``word_export.py`` &lt;br&gt;     Adds the Plugins\:Word Export\:Export menu item to format and export &lt;br&gt;     the selected outline to a Word document, starting Word if necessary. &lt;br&gt; ``xemacs.py`` &lt;br&gt;     Allows you to edit nodes in emacs/xemacs. &lt;br&gt; ``xsltWithNodes.py`` &lt;br&gt;     Adds the Outline:XSLT menu containing XSLT-related commands. &lt;br&gt; ``zenity_file_dialogs.py`` &lt;br&gt;     Replaces Leo's file dialogs on Linux with external &lt;br&gt;     calls to the zenity gtk dialog package. &lt;br&gt; " id="656" linkTypes="1" links="320" title="Summary" />
<node body="" id="657" linkTypes="3 3 3 3 3 3 3 3 3" links="1069 1070 1071 1072 1073 1074 1075 1076 1077" title="Gui-independent plugins" />
<node body="" id="658" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099" title="Qt only plugins" />
<node body="The following is only a summary.  ``print-bindings`` prints a complete list of the bindings in effect. &lt;br&gt;  &lt;br&gt; .. contents:: &lt;br&gt;     :local: &lt;br&gt;     :depth: 2 &lt;br&gt;  &lt;br&gt; " id="659" linkTypes="3 3 3" links="1100 1101 1102" title="Key Reference" />
<node body="The **clone find** commands, cfa and cff,  move clones of all nodes matching the search pattern under a single **organizer node**, created as the last top-level node. **Flattened** searches put all nodes as direct children of the organizer node:: &lt;br&gt;  &lt;br&gt;     cfa     clone-find-all &lt;br&gt;     cff     clone-find-all-flattened &lt;br&gt;      &lt;br&gt; The **clone-marked** commands move clones of all marked nodes under an organizer node. Especially useful for gathering nodes by hand:: &lt;br&gt;  &lt;br&gt;     cfam    clone-find-marked  &lt;br&gt;     cffm    clone-find-flattened-marked &lt;br&gt; " id="660" linkTypes="1" links="321" title="Clone-find commands" />
<node body=".. contents:: &lt;br&gt;     :local: &lt;br&gt;     :depth: 2 &lt;br&gt;      &lt;br&gt; ``check-derived-file`` &lt;br&gt;     Makes sure an external file written by Leo can be read properly.  &lt;br&gt; ``check-leo-file`` &lt;br&gt;     Performs a full check of the consistency of a .leo file.  As of Leo 5.1, Leo performs checks of gnx's and outline structure before writes and after reads, pastes and undo/redo. &lt;br&gt; ``check-outline`` &lt;br&gt;     Checks the outline for consistency. Leo automatically checks the syntax of Python external files when Leo writes the external file. &lt;br&gt; ``clear-all-caches`` &lt;br&gt;     Clear all file caches in g.app.leoHomeDir/db &lt;br&gt; ``clear-cache`` &lt;br&gt;     Clear the outline's file cache. &lt;br&gt; ``escape`` &lt;br&gt;     Enter watch escape mode. &lt;br&gt; ``pdb`` &lt;br&gt;     Drops into debugger, in the middle of the command-handling logic. Get the commander by stepping out into k.masterKeyHandler or k.masterCommandHandler. Using c, one can then get all other info. &lt;br&gt; ``print-buttons`` &lt;br&gt;     Print all @button and @command commands, their bindings and their source. &lt;br&gt; ``pylint`` &lt;br&gt;     Runs pylint on the Python source files in the selected tree. You can check a file by selecting any (possibly cloned) node of the file.  This command is also available from the popup menus created by the contextmenu plugin. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     # Dumping Leo's internal data. &lt;br&gt;     dump-all-objects &lt;br&gt;     dump-new-objects &lt;br&gt;     dump-outline &lt;br&gt;     verbose-dump-objects &lt;br&gt;  &lt;br&gt;     # Python's garbage collector. &lt;br&gt;     gc-collect-garbage &lt;br&gt;     gc-dump-all-objects &lt;br&gt;     gc-dump-new-objects &lt;br&gt;     gc-dump-objects-verbose &lt;br&gt;     gc-print-summary &lt;br&gt;     gc-trace-disable &lt;br&gt;     gc-trace-enable &lt;br&gt;  &lt;br&gt;     # Idle time. &lt;br&gt;     disable-idle-time-events &lt;br&gt;     enable-idle-time-events &lt;br&gt;     toggle-idle-time-events &lt;br&gt;  &lt;br&gt;     # Print &amp; show. &lt;br&gt;     print-bindings &lt;br&gt;     print-cmd-docstrings &lt;br&gt;     print-commands &lt;br&gt;     print-focus &lt;br&gt;     print-plugin-handlers &lt;br&gt;     print-plugins-info &lt;br&gt;     print-settings &lt;br&gt;     print-style-sheet &lt;br&gt;     show-calltips &lt;br&gt;     show-calltips-force &lt;br&gt;     show-colors &lt;br&gt;     show-find-options &lt;br&gt; " id="661" linkTypes="1" links="321" title="Debug commands" />
<node body=".. contents:: &lt;br&gt;     :local: &lt;br&gt;     :depth: 2" id="662" linkTypes="3 3 3 3 3 3 3 3 3" links="1103 1104 1105 1106 1107 1108 1109 1110 1111" title="Edit commands" />
<node body=".. contents:: &lt;br&gt;     :local: &lt;br&gt;     :depth: 2 &lt;br&gt; " id="663" linkTypes="3 3 3 3 3 3 3 3 3" links="1112 1113 1114 1115 1116 1117 1118 1119 1120" title="Emacs-like commands" />
<node body=".. contents:: &lt;br&gt;     :local: &lt;br&gt;     :depth: 2" id="664" linkTypes="3 3 3 3 3 3 3" links="1121 1122 1123 1124 1125 1126 1127" title="File commands" />
<node body="``about-leo`` &lt;br&gt;     Puts up a dialog box showing the version of Leo. &lt;br&gt; ``help`` &lt;br&gt;     Shows an introduction to Leo's help system. &lt;br&gt; ``help-for-command (F11)`` &lt;br&gt;     Prompts for a Leo command name in the minibuffer (tab completion is allowed) and shows the docstring for the command. &lt;br&gt; ``help-for-python (F12)`` &lt;br&gt;     Prompts for a Python module or function and shows its docstring. &lt;br&gt; ``help-for-&lt;topic&gt;`` &lt;br&gt;     Opens a discussion of a topic:: &lt;br&gt;      &lt;br&gt;         help-for-abbreviations &lt;br&gt;         help-for-autocompletion &lt;br&gt;         help-for-bindings &lt;br&gt;         help-for-creating-external-files     &lt;br&gt;         help-for-debugging-commands &lt;br&gt;         help-for-drag-and-drop &lt;br&gt;         help-for-dynamic-abbreviations &lt;br&gt;         help-for-find-commands &lt;br&gt;         help-for-minibuffer &lt;br&gt;         help-for-regular-expressions &lt;br&gt;         help-for-scripting &lt;br&gt;  &lt;br&gt; ``open-online-home`` &lt;br&gt;     Opens Leo's home page at http://leoeditor.com. &lt;br&gt; ``open-online-toc`` &lt;br&gt;     Opens Leo's table of contents at http://leoeditor.com/leo_toc.html. &lt;br&gt; ``open-online-tutorials`` &lt;br&gt;     Opens Leo's tutorials page at http://leoeditor.com/tutorial.html. &lt;br&gt; ``open-online-videos`` &lt;br&gt;     Opens Leo's video page at http://leoeditor.com/screencasts.html. &lt;br&gt; ``open-quickstart-leo`` &lt;br&gt;     Opens Leo's quickstart guide in a new tab or window. &lt;br&gt; ``open-users-guide`` &lt;br&gt;     Opens Leo's Users Guide at http://leoeditor.com/usersguide.html. &lt;br&gt;  &lt;br&gt;  &lt;br&gt; " id="665" linkTypes="1" links="321" title="Help commands" />
<node body="``c-to-python`` &lt;br&gt;     Converts c or c++ text to python text. The conversion is not perfect, but it eliminates a lot of tedious text manipulation.  This command is a rewrapping of the first Python script I ever wrote. &lt;br&gt;  &lt;br&gt; ``typescript-to-py`` &lt;br&gt;     Converts typescript text to python text. The conversion is not perfect, but it eliminates a lot of tedious text manipulation. &lt;br&gt; " id="666" linkTypes="1" links="321" title="Language conversion commands" />
<node body="``eval-expression`` &lt;br&gt;     Evaluate an expression entered in the minibuffer. &lt;br&gt; ``full-command (Alt-X)`` &lt;br&gt;     Execute a command by name. Tab completion is supported. &lt;br&gt; ``keyboard-quit`` &lt;br&gt;     Exits the minibuffer, putting focus in the body pane. &lt;br&gt; ``repeat-complex-command`` &lt;br&gt;     Execute the last command entered from the minibuffer. &lt;br&gt;  &lt;br&gt; " id="667" linkTypes="1" links="321" title="Minibuffer commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     at-file-to-at-auto &lt;br&gt;     clean-persistence &lt;br&gt;     cls &lt;br&gt;     join-leo-irc &lt;br&gt;     open-python-window   &lt;br&gt;     script-button &lt;br&gt;      &lt;br&gt;     # Fonts. &lt;br&gt;     set-font &lt;br&gt;     show-fonts &lt;br&gt;      &lt;br&gt;     # Icons. &lt;br&gt;     insert-icon &lt;br&gt;     delete-first-icon &lt;br&gt;     delete-last-icon &lt;br&gt;     delete-node-icons &lt;br&gt;      &lt;br&gt;     # Layout. &lt;br&gt;     free-layout-context-menu &lt;br&gt;     free-layout-load &lt;br&gt;     free-layout-load-alternate &lt;br&gt;     free-layout-load-detached-body &lt;br&gt;     free-layout-load-no-log &lt;br&gt;     free-layout-load-standard &lt;br&gt;     free-layout-restore &lt;br&gt;     free-layout-zoom &lt;br&gt;      &lt;br&gt;     # Modes. &lt;br&gt;     enter-quick-command-mode &lt;br&gt;     exit-named-mode &lt;br&gt;      &lt;br&gt;     # uA's. &lt;br&gt;     clear-all-uas &lt;br&gt;     clear-node-uas &lt;br&gt;     print-all-uas &lt;br&gt;     print-node-uas &lt;br&gt;     set-ua &lt;br&gt; " id="668" linkTypes="1" links="321" title="Miscellaneous commands" />
<node body=".. contents:: &lt;br&gt;     :local: &lt;br&gt;     :depth: 2" id="669" linkTypes="3 3 3" links="1128 1129 1130" title="Mouseless Leo commands" />
<node body=".. contents:: &lt;br&gt;     :local: &lt;br&gt;     :depth: 2" id="670" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3" links="1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142" title="Outline commands" />
<node body="``act-on-node`` &lt;br&gt;     Executes node-specific action, typically defined in a plugins as follows:: &lt;br&gt;  &lt;br&gt;         import leo.core.leoPlugins &lt;br&gt;  &lt;br&gt;         def act_print_upcase(c,p,event): &lt;br&gt;             if not p.h.startswith('@up'): &lt;br&gt;                 raise leo.core.leoPlugins.TryNext &lt;br&gt;             p.h = p.h.upper() &lt;br&gt;  &lt;br&gt;         g.act_on_node.add(act_print_upcase) &lt;br&gt;  &lt;br&gt;     This will upcase the headline when it starts with @up. &lt;br&gt;  &lt;br&gt; Plugins create the following commands:: &lt;br&gt;      &lt;br&gt;     # bookmarks.py &lt;br&gt;     bookmarks-bookmark &lt;br&gt;     bookmarks-bookmark-child &lt;br&gt;     bookmarks-level-decrease &lt;br&gt;     bookmarks-level-increase &lt;br&gt;     bookmarks-mark-as-target &lt;br&gt;     bookmarks-open-bookmark &lt;br&gt;     bookmarks-open-node &lt;br&gt;     bookmarks-show &lt;br&gt;     bookmarks-switch &lt;br&gt;     bookmarks-use-other-outline &lt;br&gt;      &lt;br&gt;     # printing.py &lt;br&gt;     preview &lt;br&gt;     preview-node &lt;br&gt;     preview-tree &lt;br&gt;     print-expanded-node &lt;br&gt;     print-expanded-node-body &lt;br&gt;     print-marked-node-bodies &lt;br&gt;     print-marked-nodes &lt;br&gt;     print-preview-expanded-node &lt;br&gt;     print-preview-expanded-node-body &lt;br&gt;     print-preview-marked-node-bodies &lt;br&gt;     print-preview-marked-nodes &lt;br&gt;     print-preview-selected-node &lt;br&gt;     print-preview-selected-node-body &lt;br&gt;     print-preview-selected-node-body-html &lt;br&gt;     print-selected-node &lt;br&gt;     print-selected-node-body &lt;br&gt;     print-selected-node-body-html &lt;br&gt;      &lt;br&gt;     # quicksearch.py &lt;br&gt;     find-quick &lt;br&gt;     find-quick-changed &lt;br&gt;     find-quick-selected &lt;br&gt;     find-quick-test-failures &lt;br&gt;     find-quick-timeline &lt;br&gt;     focus-to-nav &lt;br&gt;     go-anywhere &lt;br&gt;     history &lt;br&gt;     marked-list &lt;br&gt;      &lt;br&gt;     # richtext.py &lt;br&gt;     cke-text-close &lt;br&gt;     cke-text-open &lt;br&gt;     cke-text-switch &lt;br&gt;     cke-text-toggle-autosave &lt;br&gt;     richtext-close-editor &lt;br&gt;     richtext-open-editor &lt;br&gt;     richtext-switch-editor &lt;br&gt;     richtext-toggle-autosave &lt;br&gt;  &lt;br&gt;     # viewrendered.py &lt;br&gt;     vr-contract &lt;br&gt;     vr-expand &lt;br&gt;     vr-hide &lt;br&gt;     vr-lock &lt;br&gt;     vr-pause-play-movie &lt;br&gt;     vr-show &lt;br&gt;     vr-toggle (Alt-0) &lt;br&gt;     vr-unlock &lt;br&gt;     vr-update" id="671" linkTypes="1" links="321" title="Plugins commands" />
<node body=".. contents:: &lt;br&gt;     :local: &lt;br&gt;     :depth: 2" id="672" linkTypes="3 3 3 3 3 3" links="1143 1144 1145 1146 1147 1148" title="Search &amp; spell commands" />
<node body="``open-local-settings`` &lt;br&gt;     Select the @settings node in the present file, if any. &lt;br&gt; ``open-myLeoSettings-leo`` &lt;br&gt;     Open myLeoSettings.leo in a new window. &lt;br&gt; ``style-reload`` &lt;br&gt;     Reloads all visual setting, but not themes. &lt;br&gt;      &lt;br&gt;     **Example**: Change the ``@string font-size`` setting, then do ``style-reload`` and see what happens. &lt;br&gt; ``style-set-selected`` &lt;br&gt;     Set the global stylesheet to c.p.b. &lt;br&gt;      &lt;br&gt; The following commands enable, disable or toggle various settings:: &lt;br&gt;  &lt;br&gt;     clear-extend-mode &lt;br&gt;     disable-autocompleter &lt;br&gt;     disable-calltips &lt;br&gt;     enable-autocompleter &lt;br&gt;     enable-calltips &lt;br&gt;     set-colors &lt;br&gt;     set-command-state &lt;br&gt;     set-extend-mode &lt;br&gt;     set-insert-state &lt;br&gt;     set-overwrite-state &lt;br&gt;     set-replace-string &lt;br&gt;     set-search-string &lt;br&gt;     set-silent-mode &lt;br&gt;     toggle-abbrev-mode &lt;br&gt;     toggle-autocompleter &lt;br&gt;     toggle-calltips &lt;br&gt;     toggle-case-region &lt;br&gt;     toggle-extend-mode &lt;br&gt;     toggle-find-collapses-nodes &lt;br&gt;     toggle-input-state &lt;br&gt;     toggle-invisibles &lt;br&gt;     toggle-sparse-move &lt;br&gt;     toggle-split-direction &lt;br&gt; " id="673" linkTypes="1" links="321" title="Settings commands" />
<node body="``beautify-node`` &lt;br&gt;     Beautifies the Python code in the selected node. &lt;br&gt; ``beautify-tree`` &lt;br&gt;     Beautifies all the Python code in the selected tree. &lt;br&gt; ``beautify-c`` &lt;br&gt;     Reformats all C code in the selected tree. &lt;br&gt;      &lt;br&gt; These commands skip any nodes for which @language python (or c) is not in effect. &lt;br&gt;  &lt;br&gt; The **Python beautifier** (beautify-tree and beautify-node) is *safe*.  It can never alter the meaning of a program because it compare the parse trees of the original and beautified code. The code remains unchanged if there is a mismatch. Such **beautifier errors** produce debugging dumps. Please report any such errors to Leo's developers. &lt;br&gt;  &lt;br&gt; The Python beautifier works only on syntactically correct code. It issues a warning and does nothing for syntactically incorrect code. &lt;br&gt;  &lt;br&gt; The Python beautifier converts **Leonine syntax** (directives, section references and @doc parts) to comments, possibly with a trailing ``pass`` statement.  Usually this produces syntactically correct text.  As discussed below, the trailing ``pass`` can create SyntaxError's. &lt;br&gt;  &lt;br&gt; The following sections describe how the beautify-tree and beautify-node commands work in more detail." id="674" linkTypes="3 3 3 3 3 3 3 3" links="1149 1150 1151 1152 1153 1154 1155 1156" title="Code beautification commands" />
<node body="``run-all-unit-tests-externally`` &lt;br&gt;     Run all unit tests in a separate process. &lt;br&gt; ``run-all-unit-tests-locally`` &lt;br&gt;     Run all unit tests in this outline. &lt;br&gt; ``run-marked-unit-tests-externally`` &lt;br&gt;     Run all marked unit tests in a separate process. &lt;br&gt; ``run-marked-unit-tests-locally`` &lt;br&gt;     Run all marked unit tests in this outline. &lt;br&gt; ``run-selected-unit-tests-externally`` &lt;br&gt;     Run all unit tests in the selected tree in a separate process. &lt;br&gt; ``run-selected-unit-tests-locally`` &lt;br&gt;     Run all unit tests in the selected tree in this outline. &lt;br&gt; " id="675" linkTypes="1" links="321" title="Unit testing commands" />
<node body=".. contents:: &lt;br&gt;     :local: &lt;br&gt;     :depth: 2 &lt;br&gt;  &lt;br&gt; ``cascade-windows`` &lt;br&gt;     Cascades all Leo windows. &lt;br&gt; ``equal-sized-panes`` &lt;br&gt;     Adjusts the sizes of the outline and body panes so that they are the same height. &lt;br&gt; ``minimize-all`` &lt;br&gt;     Minimizes (hides) all Leo windows. &lt;br&gt; ``show-colors`` &lt;br&gt;     Opens a tab in the log pane showing various color pickers. &lt;br&gt;     (Not implemented in Qt) &lt;br&gt; ``show-fonts`` &lt;br&gt;     Open a tab in the log pane showing a font picker. &lt;br&gt; ``suspend`` &lt;br&gt;     Minimizes the present Leo window. &lt;br&gt; ``toggle-split-direction`` &lt;br&gt;     Switches between vertical and horizontal orientations of the Leo window. &lt;br&gt;      &lt;br&gt;     In the vertical orientation, the body pane appears below the pane containing the outline and log panes. In the horizontal orientation, the body pane appears to the left the pane containing the outline and log panes. By default, the ratio of pane outline pane to the body pane is 0.5 in the vertical orientation and 0.3 in the horizontal orientation. These two ratios may be changed using settings. &lt;br&gt;  &lt;br&gt; ``zoom-in`` &lt;br&gt;     Increases text size by 1 pt. &lt;br&gt; ``zoom-out``. &lt;br&gt;     Decrease text size by 1 pt. &lt;br&gt; " id="676" linkTypes="1" links="321" title="Window-related commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     :! &lt;br&gt;     :%s &lt;br&gt;     :e &lt;br&gt;     :e! &lt;br&gt;     :gT &lt;br&gt;     :gt &lt;br&gt;     :print-dot &lt;br&gt;     :q &lt;br&gt;     :q! &lt;br&gt;     :qa &lt;br&gt;     :r &lt;br&gt;     :s &lt;br&gt;     :tabnew &lt;br&gt;     :toggle-vim-mode &lt;br&gt;     :toggle-vim-trace &lt;br&gt;     :toggle-vim-trainer-mode &lt;br&gt;     :w &lt;br&gt;     :wq &lt;br&gt;     :xa &lt;br&gt; " id="677" linkTypes="1" links="321" title="Vim mode commands" />
<node body=".. From directives reference &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @&lt;file&gt;; Reference &lt;br&gt;  &lt;br&gt; This section discusses the @&lt;file&gt; directives. These directives create or import external files. &lt;br&gt;  &lt;br&gt; \@&lt;file&gt; nodes create external files:: &lt;br&gt;  &lt;br&gt;     @asis &lt;filename&gt;        write only, no sentinels, exact line endings &lt;br&gt;     @auto &lt;filename&gt;        recommended &lt;br&gt;     @clean &lt;filename&gt;       recommended &lt;br&gt;     @edit &lt;filename&gt;        @edit node contains entire file &lt;br&gt;     @file &lt;filename&gt;        recommended &lt;br&gt;     @nosent &lt;filename&gt;      write only, no sentinels &lt;br&gt;  &lt;br&gt; **Note**: @file, @clean and @auto are the recommended ways of creating external files. @asis and @nosent are for special occasions. &lt;br&gt;  &lt;br&gt; **Note**: All these directive must appear in headlines. &lt;br&gt;  &lt;br&gt; The following table compares the various ways of creating external files. Later sections provide more details:: &lt;br&gt;  &lt;br&gt;                              Sections &amp;   File data in &lt;br&gt;     @&lt;file&gt; kind  Sentinels?  @others?    .leo file?    Notes              &lt;br&gt;     ------------  ---------- -----------  ------------  ----- &lt;br&gt;     @asis            no         no           yes &lt;br&gt;     @auto            no         yes          no         1, 2 &lt;br&gt;     @auto-xx         no         yes          no         1, 2 &lt;br&gt;     @clean           no         yes          yes      &lt;br&gt;     @edit            no         no           no     &lt;br&gt;     @file            yes        yes          no &lt;br&gt;     @nosent          no         yes          yes &lt;br&gt;      &lt;br&gt; **Note 1**: @auto nodes read files using language-specific importers. &lt;br&gt; By default, the file's extension determines the importer:: &lt;br&gt;  &lt;br&gt;     Extensions                  Importer &lt;br&gt;     ----------                  -------- &lt;br&gt;     .c, .cc, .c++, .cpp,.cxx    C &lt;br&gt;     .cs', .c#'                  C Sharp &lt;br&gt;     .el                         Elisp &lt;br&gt;     .h, .h++                    C &lt;br&gt;     .html, .htm                 HTML &lt;br&gt;     .ini                        Config file &lt;br&gt;     .ipynb                      Jupyter notebook &lt;br&gt;     .java                       Java &lt;br&gt;     .js                         JavaScript &lt;br&gt;     .md                         Markdown &lt;br&gt;     .org                        Org Mode &lt;br&gt;     .otl                        Vim outline &lt;br&gt;     .pas                        Pascal &lt;br&gt;     .php                        PHP &lt;br&gt;     .py, .pyi, .pyw             Python &lt;br&gt;     .rest, .rst                 reStructuredText &lt;br&gt;     .ts                         TypeScript &lt;br&gt;     .xml                        XML &lt;br&gt;      &lt;br&gt; **Note 2**: You can also specify importers *explicitly* as follows:: &lt;br&gt;  &lt;br&gt;     @auto-xxx           Importer &lt;br&gt;     ---------           -------- &lt;br&gt;     @auto-ctext         ctext &lt;br&gt;     @auto-markdown      markdown &lt;br&gt;     @auto-md            markdown &lt;br&gt;     @auto-org           org-mode &lt;br&gt;     @auto-org-mode      org-mode &lt;br&gt;     @auto-otl           vimoutline &lt;br&gt;     @auto-vim-outline   vimoutline       &lt;br&gt;     @auto-rst           reStructuredText &lt;br&gt;      &lt;br&gt; **Important**: The importers/exporters for markdown, org-mode, reStructuredText and vimoutline files automatically generate section heading of the appropriate level. Body text of the top-level @auto node is ignored. &lt;br&gt; " id="678" linkTypes="3 3 3 3 3 3 3 3" links="1157 1158 1159 1160 1161 1162 1163 1164" title="Part 1: \@&lt;file&gt; directives" />
<node body="These control how Leo places text when writing external files. They are two of the most important directives in Leo. &lt;br&gt;  &lt;br&gt; .. glossary:: &lt;br&gt;     :sorted: &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @all; Reference &lt;br&gt;  &lt;br&gt; \@all &lt;br&gt;  &lt;br&gt;     Copies *all* descendant nodes to the external file. Use @all to place &lt;br&gt;     unrelated data in an external file. &lt;br&gt;  &lt;br&gt;     The @all directive is valid only in the body of @file trees. &lt;br&gt;  &lt;br&gt;     Within the range of an @all directive, Leo ignores the @others directive &lt;br&gt;     and section references, so Leo will not complain about orphan nodes. &lt;br&gt;      &lt;br&gt;     The @all directivive is designed for &quot;catch-all&quot; files, like &lt;br&gt;     todo.txt or notes.txt or whatever. Such files are assumed to &lt;br&gt;     contain a random collection of nodes, so there is no language in &lt;br&gt;     effect and no real comment delimiters. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @others; Reference &lt;br&gt;  &lt;br&gt; \@others &lt;br&gt;  &lt;br&gt;     Writes the body text of all unnamed descendant into the external file, in &lt;br&gt;     outline order. &lt;br&gt;  &lt;br&gt;     Whitespace appearing before @others directive adds to the indentation of &lt;br&gt;     all nodes added by the @others directive. &lt;br&gt;  &lt;br&gt;     A single node may contain only one @others directive, but descendant nodes &lt;br&gt;     may have other @others directives. &lt;br&gt; " id="679" linkTypes="1" links="323" title="Part 2: \@all and \@others" />
<node body="The @color, @killcolor, @nocolor and @nocolor-node directives control how &lt;br&gt; Leo colors text in the body pane. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Ambiguous node; Reference &lt;br&gt;  &lt;br&gt; These directives typically affect the node in which they appear and all descendant nodes. Exception: an **ambiguous node**, a node containing both @color and @nocolor directives, has no effect on how Leo colors text in descendant nodes. &lt;br&gt;  &lt;br&gt; .. glossary:: &lt;br&gt;     :sorted: &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @color; Reference &lt;br&gt;  &lt;br&gt; \@color &lt;br&gt;  &lt;br&gt;     Enables syntax coloring until the next @nocolor directive. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @killcolor; Reference &lt;br&gt;  &lt;br&gt; \@killcolor &lt;br&gt;  &lt;br&gt;     Disables syntax coloring in a node, overriding all @color, @nocolor or &lt;br&gt;     @nocolor-node directives in the same node. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @nocolor; Reference &lt;br&gt;  &lt;br&gt; \@nocolor &lt;br&gt;  &lt;br&gt;     Disables syntax coloring until the next @nocolor directive. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @nocolor-node; Reference &lt;br&gt;  &lt;br&gt; \@nocolor-node &lt;br&gt;  &lt;br&gt;     Disables coloring for only the node containing it. The @nocolor-node &lt;br&gt;     directive overrides the @color and @nocolor directives within the same &lt;br&gt;     node. &lt;br&gt; " id="680" linkTypes="1" links="323" title="Part 3: Syntax coloring directives" />
<node body="These directives alter how Leo represents data in external files. They are **dangerous**--mistakes in using these sentinels can make it impossible for Leo to read the resulting external file. Use them with care! &lt;br&gt;  &lt;br&gt; Nevertheless, these sentinels can be useful in special situations. &lt;br&gt;  &lt;br&gt; .. glossary:: &lt;br&gt;     :sorted: &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @comment; Reference &lt;br&gt;  &lt;br&gt; \@comment &lt;1, 2 or three comment delims&gt; &lt;br&gt;  &lt;br&gt;     Sets the comment delimiters in @file and @shadow files. &lt;br&gt;     **Important**: Use @comment for unusual situations only. In most cases, you &lt;br&gt;     should use the @language directive to set comment delimiters. &lt;br&gt;  &lt;br&gt;     The @comment directive may be followed by one, two or three delimiters, &lt;br&gt;     separated by whitespace. If one delimiter is given, it sets the delimiter &lt;br&gt;     used by single-line comments. If two delimiters are given, they set the &lt;br&gt;     block comment delimiter. If three delimiters are given, the first sets the &lt;br&gt;     single-line-comment delimiter, and the others set the block-comment &lt;br&gt;     delimiters. &lt;br&gt;  &lt;br&gt;     Within these delimiters, underscores represent a significant space, and &lt;br&gt;     double underscores represent a newline. Examples:: &lt;br&gt;  &lt;br&gt;         @comment REM_ &lt;br&gt;         @comment __=pod__ __=cut__ &lt;br&gt;  &lt;br&gt;     The second line sets PerlPod comment delimiters. &lt;br&gt;  &lt;br&gt;     **Warning**: the @comment and @delims directives **must not** appear in &lt;br&gt;     the same node. Doing so may create a file that Leo can not read. &lt;br&gt;  &lt;br&gt;     **Note**: @language and @comment may appear in the same node, provided &lt;br&gt;     that @comment appears *after* the @language directive: @comment overrides &lt;br&gt;     @language. &lt;br&gt;  &lt;br&gt;     The @comment directive must precede the first section name or @c &lt;br&gt;     directive. &lt;br&gt;      &lt;br&gt;     There are situations where using @delims or @comment is not avoidable or impractical to &lt;br&gt;     add new language definition, and including it causes the resulting file to be invalid. &lt;br&gt;     In place of delimiter definition, use @0x + delimiter encoded in hexadecimal. &lt;br&gt;     The hexadecimal part must be acceptable input to binascii.unhexlify(), otherwise whole  &lt;br&gt;     directive will be ignored. Use binascii.hexlify('my-delimiter') to generate it. &lt;br&gt;     Decoded delimiters are not checked for validity (such as, UTF-8) and whether they  &lt;br&gt;     do not clash with Leo format (like newline or NUL characters)! &lt;br&gt;      &lt;br&gt;     Example:: &lt;br&gt;      &lt;br&gt;         @comment @0x3c212d2d2120 @0x202d2d3e &lt;br&gt;      &lt;br&gt;     for GenshiXML is the same definition as  &lt;br&gt;          &lt;br&gt;         @comment &lt;!--!_ _--&gt; &lt;br&gt;      &lt;br&gt;     to create comments that will be removed from the output by Genshi. But the latter would  &lt;br&gt;     cause XML parsing error on the @comment line. &lt;br&gt;      &lt;br&gt; .. index:: &lt;br&gt;     pair: @delims; Reference &lt;br&gt;  &lt;br&gt; \@delims &lt;1 or 2 comment delims&gt; &lt;br&gt;  &lt;br&gt;     Sets comment delimiters in external files containing sentinel lines. &lt;br&gt;  &lt;br&gt;     The @delims directive requires one or two delimiters, separated by &lt;br&gt;     whitespace. If one delimiter is present it sets the single-line-comment &lt;br&gt;     delimiter. If two delimiters are present they set block comment delimiters. &lt;br&gt;  &lt;br&gt;     This directive is often used to place Javascript text inside XML or HTML &lt;br&gt;     files. Like this:: &lt;br&gt;  &lt;br&gt;         @delims /* */ &lt;br&gt;         Javascript stuff &lt;br&gt;         @delims &lt;-- --&gt; &lt;br&gt;         HTML stuff &lt;br&gt;  &lt;br&gt;     **Warning**: you **must** change back to previous delimiters using another &lt;br&gt;     @delims directive. Failure to change back to the previous delimiters will &lt;br&gt;     thoroughly corrupt the external file as far as compilers, HTML renderers, &lt;br&gt;     etc. are concerned. Leo does not do this automatically at the end of a node. &lt;br&gt;  &lt;br&gt;     **Warning**: the @comment and @delims directives **must not** appear in &lt;br&gt;     the same node. Doing so may create a file that Leo can not read. &lt;br&gt;  &lt;br&gt;     **Note**: The @delims directive can not be used to change the comment &lt;br&gt;     strings at the start of the external file, that is, the comment strings for &lt;br&gt;     the @+leo sentinel and the initial @+body and @+node sentinels. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @raw; Reference &lt;br&gt;     pair: @end_raw; Reference &lt;br&gt;  &lt;br&gt; \@raw and \@end_raw &lt;br&gt;  &lt;br&gt;     \@raw starts a section of &quot;raw&quot; text that ends *only* with the @end_raw directive &lt;br&gt;     or the end of the body text containing the @raw directive. Within this &lt;br&gt;     range, Leo ignores all section references and directives, and Leo generates &lt;br&gt;     no additional leading whitespace. &lt;br&gt; " id="681" linkTypes="1" links="323" title="Part 4: Dangerous directives" />
<node body=".. _`Using Chapters`: outlines.html#using-chapters &lt;br&gt;  &lt;br&gt; This section is a reference guide for all other Leo directives, organized alphabetically. &lt;br&gt;  &lt;br&gt; Unless otherwise noted, all directives listed are valid only in body text, and they must start at the leftmost column of the node. &lt;br&gt;  &lt;br&gt; .. glossary:: &lt;br&gt;      :sorted: &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @; Reference &lt;br&gt; .. index:: &lt;br&gt;     pair: @doc; Reference &lt;br&gt; .. index:: &lt;br&gt;     pair: Doc part; Reference &lt;br&gt;  &lt;br&gt; \@ and \@doc &lt;br&gt;  &lt;br&gt;     These directives start a doc part. @doc is a synonym for @. Doc parts &lt;br&gt;     continue until an @c directive or the end of the body text. For example:: &lt;br&gt;  &lt;br&gt;         @ This is a comment in a doc part. &lt;br&gt;         Doc parts can span multiple lines. &lt;br&gt;         The next line ends the doc part &lt;br&gt;         @c &lt;br&gt;  &lt;br&gt;     When writing external files, Leo writes doc parts as comments. &lt;br&gt;  &lt;br&gt;     Leo does not recognize @ or @doc in @asis trees or when the @all or &lt;br&gt;     @delims directives are in effect. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @c; Reference &lt;br&gt; .. index:: &lt;br&gt;     pair: @code; Reference &lt;br&gt;  &lt;br&gt; \@c and @code &lt;br&gt;  &lt;br&gt;     Ends any doc part and starts a code part. &lt;br&gt;  &lt;br&gt;     \@code is a deprecated synonym for @c. &lt;br&gt;  &lt;br&gt;     Leo does not recognize this directive in @asis trees or when the &lt;br&gt;     @all or @raw directives are in effect. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @chapter; Reference &lt;br&gt;  &lt;br&gt; \@chapter &lt;br&gt;  &lt;br&gt;     An @chapter tree represents a chapter. For full details, see &lt;br&gt;     `Using Chapters`_. &lt;br&gt;  &lt;br&gt;     These directives must appear in the node's headline. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @encoding; Reference &lt;br&gt;  &lt;br&gt; \@encoding &lt;encoding&gt; &lt;br&gt;  &lt;br&gt;     Specifies the Unicode encoding for an external file. For example:: &lt;br&gt;  &lt;br&gt;         @encoding iso-8859-1 &lt;br&gt;  &lt;br&gt;     When reading external files, the encoding given must match the encoding &lt;br&gt;     actually used in the external file or &quot;byte hash&quot; will result. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @first; Reference &lt;br&gt;  &lt;br&gt; \@first &lt;text&gt; &lt;br&gt;  &lt;br&gt;     Places lines at the very start of an external file, before any Leo &lt;br&gt;     sentinels. @first lines must be the very first lines in an @&lt;file&gt; node. &lt;br&gt;     More then one @first lines may appear. &lt;br&gt;  &lt;br&gt;     This creates two first lines, a shebang line and a Python encoding line:: &lt;br&gt;  &lt;br&gt;         @first #! /usr/bin/env python &lt;br&gt;         @first # -*- coding: utf-8 -*- &lt;br&gt;  &lt;br&gt;     Here is a perl example:: &lt;br&gt;  &lt;br&gt;         @first #!/bin/sh -- # perl, to stop looping &lt;br&gt;         @first eval 'exec /usr/bin/perl -w -S $0 ${1+&quot;$@&quot;}' &lt;br&gt;         @first     if 0; &lt;br&gt;  &lt;br&gt; \@ignore &lt;br&gt;  &lt;br&gt;     Tells Leo to ignore the subtree in which it appears. &lt;br&gt;  &lt;br&gt;     In the body text of most top-level @&lt;file&gt; nodes, the @ignore directive &lt;br&gt;     causes Leo not to write the tree. However, Leo ignores @ignore directives &lt;br&gt;     in @asis trees. &lt;br&gt;  &lt;br&gt;     Plugins and other parts of Leo sometimes @ignore for their own purposes. For &lt;br&gt;     example, Leo's unit testing commands will ignore trees containing @ignore. &lt;br&gt;     In such cases, the @ignore directive may appear in the headline or body &lt;br&gt;     text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @language; Reference &lt;br&gt;      &lt;br&gt; ..  # A script to generate the list of languages &lt;br&gt; ..  import glob &lt;br&gt; ..  dir_ = g.os_path_finalize_join(g.app.loadDir, '..', 'modes') &lt;br&gt; ..  aList = sorted(glob.glob('%s/*.py' % dir_)) &lt;br&gt; ..  s = ', '.join([g.shortFileName(z)[: -3] for z in aList]) &lt;br&gt; ..  g.es(s) &lt;br&gt;  &lt;br&gt; \@language &lt;language name&gt; &lt;br&gt;  &lt;br&gt;     Specifies the language in effect, including comment delimiters. &lt;br&gt;     If no @language directive is in effect, Leo uses the defaults specified &lt;br&gt;     by the @string target-language setting. &lt;br&gt;  &lt;br&gt;     A node may contain multiple @language directives. &lt;br&gt;  &lt;br&gt;     The valid language names include the following: actionscript, ada95, ahk, antlr, apacheconf, apdl, applescript, asp, aspect_j, assembly_macro32, assembly_mcs51, assembly_parrot, assembly_r2000, assembly_x86, awk, b, batch, bbj, bcel, bibtex, c, chill, clojure, cobol, coldfusion, cplusplus, csharp, css, cython, d, dart, doxygen, eiffel, embperl, erlang, factor, forth, fortran, fortran90, foxpro, gettext, groovy, haskell, haxe, html, i4gl, icon, idl, inform, ini, inno_setup, interlist, io, java, javascript, jhtml, jmk, jsp, kivy, latex, lilypond, lisp, lotos, lua, mail, makefile, maple, matlab, md, ml, modula3, moin, mqsc, netrexx, nqc, nsi, nsis2, objective_c, objectrexx, occam, omnimark, pascal, patch, perl, php, phpsection, pike, pl1, plain, plsql, pop11, postscript, povray, powerdynamo, prolog, pseudoplain, psp, ptl, pvwave, pyrex, python, r, rebol, redcode, rest, rhtml, rib, rpmspec, rtf, ruby, rview, sas, scala, scheme, sdl_pr, sgml, shell, shellscript, shtml, smalltalk, smi_mib, splus, sqr, squidconf, ssharp, swig, tcl, tex, texinfo, text, tpl, tsql, uscript, vbscript, velocity, verilog, vhdl, xml, xsl, yaml, zpt. &lt;br&gt;  &lt;br&gt;     **Note**: Shell files have comments that start with #. &lt;br&gt;  &lt;br&gt;     Case is ignored in the language names. For example, the following are &lt;br&gt;     equivalent:: &lt;br&gt;  &lt;br&gt;         @language html &lt;br&gt;         @language HTML &lt;br&gt;  &lt;br&gt;     The @language directive also controls syntax coloring. For language x, the &lt;br&gt;     file leo/modes/x.py describes how to colorize the language. To see the &lt;br&gt;     languages presently supported, look in the leo/modes directory. There are &lt;br&gt;     over 100 such languages. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @last; Reference &lt;br&gt;  &lt;br&gt; \@last &lt;text&gt; &lt;br&gt;  &lt;br&gt;     Places lines at the very end of external files. &lt;br&gt;  &lt;br&gt;     This directive must occur at the very end of top-level @&lt;file&gt; nodes. More &lt;br&gt;     than one @last directive may exist. For example:: &lt;br&gt;  &lt;br&gt;         @first &lt;?php &lt;br&gt;         ... &lt;br&gt;         @last ?&gt; &lt;br&gt;  &lt;br&gt;     Leo does not recognize @last directive in @asis trees. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @lineending; Reference &lt;br&gt;  &lt;br&gt; \@lineending cr/lf/nl/crlf &lt;br&gt;  &lt;br&gt;     Sets the line endings for external files. &lt;br&gt;     This directive overrides the @string output_newline setting. &lt;br&gt;  &lt;br&gt;     The valid forms of the @lineending directive are: &lt;br&gt;  &lt;br&gt;     ========================   ====================================================== &lt;br&gt;     \@lineending nl            The default, Linux. &lt;br&gt;     ------------------------   ------------------------------------------------------ &lt;br&gt;     \@lineending cr            Mac &lt;br&gt;     ------------------------   ------------------------------------------------------ &lt;br&gt;     \@lineending crlf          Windows &lt;br&gt;     ------------------------   ------------------------------------------------------ &lt;br&gt;     \@lineending lf            Same as 'nl', not recommended &lt;br&gt;     ------------------------   ------------------------------------------------------ &lt;br&gt;     \@lineending platform      Same as platform value for output_newline setting. &lt;br&gt;     ========================   ====================================================== &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @nowrap; Reference &lt;br&gt;  &lt;br&gt; \@nowrap &lt;br&gt;  &lt;br&gt;     Disables line wrapping the Leo's body pane. &lt;br&gt;  &lt;br&gt;     Only the first @wrap or @nowrap directive in a node has any effect. &lt;br&gt;  &lt;br&gt;     @nowrap may appear in either headlines or body text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @pagewidth; Reference &lt;br&gt;  &lt;br&gt; \@pagewidth &lt;n&gt; &lt;br&gt;  &lt;br&gt;    Sets the page width used to break doc parts into lines. &lt;br&gt;    &lt;n&gt; should be a positive integer.  For example:: &lt;br&gt;  &lt;br&gt;       @pagewidth 100 &lt;br&gt;  &lt;br&gt;   The @pagewidth directive overrides the @int page_width setting. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @path; Reference &lt;br&gt; .. index:: &lt;br&gt;     pair: Absolute path; Reference &lt;br&gt; .. index:: &lt;br&gt;     pair: Path prefix; Reference &lt;br&gt;  &lt;br&gt; \@path &lt;path&gt; &lt;br&gt;  &lt;br&gt;    Sets the **path prefix** for relative filenames for all @&lt;file&gt; tree. &lt;br&gt;  &lt;br&gt;    This directive may appear in headlines or body text, and may &lt;br&gt;    appear in top-level @&lt;file&gt; nodes. &lt;br&gt;  &lt;br&gt;    The path is an **absolute path** if it begins with c:\\ or /, &lt;br&gt;    otherwise the path is a **relative** paths. &lt;br&gt;  &lt;br&gt;    Multiple @path directives may contribute to the path prefix. &lt;br&gt;    Absolute paths overrides any ancestor @path directives. &lt;br&gt;    Relative paths add to the path prefix. &lt;br&gt;  &lt;br&gt;    If no @path directives are in effect, the default path prefix is &lt;br&gt;    the directory containing the .leo file. &lt;br&gt;  &lt;br&gt;    Within @path and @&lt;file&gt; paths, {{exp}} gets evaluated with the following &lt;br&gt;    symbols known: c, g, p, os and sys.  For example:: &lt;br&gt;  &lt;br&gt;        @file {{os.path.abspath(os.curdir)}}/abc.py &lt;br&gt;  &lt;br&gt;    refers to the file abc.py in (absolute path of) the current directory. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @tabwidth; Reference &lt;br&gt; .. index:: &lt;br&gt;     pair: Negative tab width; Reference &lt;br&gt;  &lt;br&gt; \@tabwidth &lt;n&gt; &lt;br&gt;  &lt;br&gt;   Sets the width of tabs. &lt;br&gt;   Negative tab widths cause Leo to convert tabs to spaces. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @wrap; Reference &lt;br&gt;  &lt;br&gt; \@wrap &lt;br&gt;  &lt;br&gt;     Enables line wrapping in Leo's body pane. &lt;br&gt;  &lt;br&gt;     Only the first @wrap or @nowrap directive in a node has any effect. &lt;br&gt;  &lt;br&gt;     @wrap may appear in either headlines or body text. &lt;br&gt; " id="682" linkTypes="1" links="323" title="Part 5: All other directives" />
<node body="Leo can automatically import and export Emacs org-mode (.org) files. Nodes like:: &lt;br&gt;  &lt;br&gt;     @auto-org-mode &lt;path to .org file&gt; &lt;br&gt;  &lt;br&gt; or equivalently:: &lt;br&gt;  &lt;br&gt;     @auto-org &lt;path to .org file&gt; &lt;br&gt;      &lt;br&gt; import the org-mode file as a Leo outline.  &lt;br&gt;  &lt;br&gt; These nodes work like other @auto nodes: when Leo loads an outline, Leo reads the .org file into the @auto-org-mode tree. When Leo writes an outline, Leo writes any @auto-org-mode tree back to the org-mode file. &lt;br&gt;  &lt;br&gt; After creating an @auto-org-mode node by hand, be sure to use Leo's refresh-from-disk command to populate the node. Do this *before* saving the .leo file. If you try to save an empty @auto-org-mode node Leo will warn you that you are about to overwrite the file. &lt;br&gt;  &lt;br&gt; The ``refresh-from-disk`` command creates an @auto-org-mode node whose **children** represent the contents of the external .org file. Leo does *not* write the @auto-org-mode node itself. This allows you to put Leo directives in the node. &lt;br&gt; " id="683" linkTypes="1" links="324" title="Using org-mode (.org) files in Leo" />
<node body=".. _`pymacs`:   http://pymacs.progiciels-bpi.ca/index.html &lt;br&gt; .. _`elisp`:    http://en.wikipedia.org/wiki/Emacs_Lisp &lt;br&gt; .. _`Emacs`:    http://www.xemacs.org/ &lt;br&gt;  &lt;br&gt; Leo's leoPymacs module is a simple 'server' for the `pymacs`_ package. Using pymacs and leoPymacs, `elisp`_ scripts in `Emacs`_ can open .leo files and execute *Python* scripts as if they were executed inside Leo. In particular, such scripts can use Leo's predefined c, g and p variables. Thus, *Python* scripts running in Emacs can: &lt;br&gt;  &lt;br&gt; - Open any .leo file.  &lt;br&gt; - Access any part of the outline.  &lt;br&gt; - Change any part of the outline, including external files,  &lt;br&gt; - Save .leo files. &lt;br&gt; - Execute *any* Leo script. &lt;br&gt;  &lt;br&gt; In short, you can now do from Emacs anything that you can do with Leo scripting inside Leo. &lt;br&gt;  &lt;br&gt; Here are step-by-step instructions for executing Python scripts in Emacs: &lt;br&gt;  &lt;br&gt; **Step 1. Install pymacs**  &lt;br&gt;  &lt;br&gt;    The pymacs installation instructions should be clear enough. &lt;br&gt;    A clarification is needed about two-way communication between Python and lisp scripts: &lt;br&gt;    in truth, Python scripts can call the Pymacs.lisp function *only* if the Python script &lt;br&gt;    was invoked from emacs. &lt;br&gt;    Otherwise, calling Pymacs.lisp will hang the process making the call. &lt;br&gt;    For example, executing the following script as an ordinary Leo script will hang Leo:: &lt;br&gt;  &lt;br&gt;         from Pymacs import lisp &lt;br&gt;         print lisp(&quot;&quot;&quot;2+2&quot;&quot;&quot;) # Hangs &lt;br&gt;  &lt;br&gt; **Step 2. Load the leoPymacs module from Emacs, creating a hidden Leo application** &lt;br&gt;  &lt;br&gt;   From inside Emacs, you load Leo's leoPymacs module as follows:: &lt;br&gt;  &lt;br&gt;     (pymacs-load &quot;leoPymacs&quot; &quot;leo-&quot;) &lt;br&gt;  &lt;br&gt;   The call to pymacs-load is similar to 'import leoPymacs as leo-' in &lt;br&gt;   Python. The side effect of pymacs-load is to define the elisp &lt;br&gt;   function leo-x for every top-level function x in leoPymacs.py, &lt;br&gt;   namely leo-dump, leo-get-app, leo-get-g, leo-get-script-result, &lt;br&gt;   leo-init, leo-open and leo-run-script. The first call to any of &lt;br&gt;   these functions creates a **hidden Leo application** in which .leo &lt;br&gt;   files may be loaded, modified and saved, and in which Leo scripts &lt;br&gt;   may be executed. This hidden Leo application uses Leo's nullGui &lt;br&gt;   class as its gui, so Leo commands and Leo scripts that require a &lt;br&gt;   fully functional gui will not work as expected in the hidden Leo &lt;br&gt;   application. Steps 3 and 4 tell how to use this hidden Leo &lt;br&gt;   application. &lt;br&gt;  &lt;br&gt;   pymacs-load works like a Python reload, so you can redefine &lt;br&gt;   leoPymacs.py while Emacs is running. However, calling pymacs-load &lt;br&gt;   destroys the old hidden Leo application and creates a new one, so &lt;br&gt;   typically you would want to call pymacs-load only once per Emacs &lt;br&gt;   session. Like this:: &lt;br&gt;  &lt;br&gt;         (setq reload nil) ; change nil to t to force a reload. &lt;br&gt;  &lt;br&gt;         (if (or reload (not (boundp 'leoPymacs))) &lt;br&gt;             (setq leoPymacs (pymacs-load &quot;leoPymacs&quot; &quot;leo-&quot;)) &lt;br&gt;             (message &quot;leoPymacs already loaded&quot;) &lt;br&gt;         ) &lt;br&gt;  &lt;br&gt; **Step 3. From Emacs, open .leo files** &lt;br&gt;  &lt;br&gt;    Once we have loaded the leoPymacs module &lt;br&gt;    we can open a .leo file as follows:: &lt;br&gt;  &lt;br&gt;     (setq c (leo-open fileName)) &lt;br&gt;  &lt;br&gt;    This binds the elisp c variable to the Leo commander created by opening fileName. &lt;br&gt;    fileName should be the full path to a .leo file. &lt;br&gt;    In the next step we will use this c variable to execute *Leo* scripts in the &lt;br&gt;    context of an open Leo outline. &lt;br&gt;  &lt;br&gt;    Sometimes we want to execute a Leo script before opening any Leo commanders. &lt;br&gt;    For example, we might want to compute the fileName passed to leo-open. &lt;br&gt;    leo-run-script allows the c argument to be nil, &lt;br&gt;    in which case leo-run-script creates a dummy commander in which to run the script. &lt;br&gt;    For example, the following script calls g.os_path_join and g.os_path_abspath:: &lt;br&gt;  &lt;br&gt;         (setq script &quot;g.app.scriptResult = &lt;br&gt;             g.os_path_abspath(g.os_path_join( &lt;br&gt;                 g.app.loadDir,'..','test','ut.leo'))&quot; &lt;br&gt;         ) &lt;br&gt;  &lt;br&gt;         (setq fileName (leo-run-script nil script)) &lt;br&gt;  &lt;br&gt;    leo-run-script returns the value of g.app.scriptResult &lt;br&gt;    As shown above, Python scripts may set g.app.scriptResult to indicate their result. &lt;br&gt;    elisp scripts can also get g.app.scriptResult using leo-script-result. &lt;br&gt;    Note that the Python script may span multiple lines. &lt;br&gt;  &lt;br&gt; **Step 4. From Emacs, execute Leo (Python) scripts** &lt;br&gt;  &lt;br&gt;    From emacs we can execute a Python script **as if** it were executed in an &lt;br&gt;    open Leo outline. &lt;br&gt;    Suppose aLeoScript is an **elisp** string containing a Leo (Python) script. &lt;br&gt;    We can execute that script in the hidden Leo application as follows:: &lt;br&gt;  &lt;br&gt;         (leo-run-script c aLeoScript) &lt;br&gt;  &lt;br&gt;    For example:: &lt;br&gt;  &lt;br&gt;         (setq c (leo-open fileName) &lt;br&gt;         (csetq script &quot;print 'c',c,'h',c.p.h&quot;) &lt;br&gt;         (leo-run-script c script) &lt;br&gt;  &lt;br&gt; Putting this all together, we get:: &lt;br&gt;  &lt;br&gt;         ; Step 1: load leoPymacs if it has not already been loaded. &lt;br&gt;         (setq reload nil) &lt;br&gt;         (if (or reload (not (boundp 'leoPymacs))) &lt;br&gt;             (setq leoPymacs (pymacs-load &quot;leoPymacs&quot; &quot;leo-&quot;)) &lt;br&gt;             (message &quot;leoPymacs already loaded&quot;) &lt;br&gt;         ) &lt;br&gt;  &lt;br&gt;         ; Step 2: compute the path to leo/test/ut.leo using a Leo script. &lt;br&gt;         (setq script &lt;br&gt;             &quot;g.app.scriptResult = g.os_path_abspath( &lt;br&gt;                 g.os_path_join(g.app.loadDir,'..','test','ut.leo'))&quot; &lt;br&gt;         ) &lt;br&gt;         (setq fileName (leo-run-script nil script)) &lt;br&gt;  &lt;br&gt;         ; Step 3: execute a script in ut.leo. &lt;br&gt;         (setq c (leo-open fileName)) &lt;br&gt;         (setq script &quot;print 'c',c.shortFileName() ,'current:',c.p.h&quot;) &lt;br&gt;         (leo-run-script c script) &lt;br&gt; " id="684" linkTypes="1" links="324" title="Controlling Leo from Emacs using Pymacs" />
<node body="The leoPymacs module is intended to be called from Emacs using pymacs.  It contains the following top-level functions: &lt;br&gt;  &lt;br&gt; - get_app() &lt;br&gt;  &lt;br&gt;   Returns the hidden app created by the leoPymacs.init function. &lt;br&gt;  &lt;br&gt; - dump(anyPythonObject) &lt;br&gt;  &lt;br&gt;   Returns str(repr(anyPythonObject)). &lt;br&gt;  &lt;br&gt; - get_g() &lt;br&gt;  &lt;br&gt;   Returns the leoGlobals module of the hidden app created by the leoPymacs.init function. &lt;br&gt;  &lt;br&gt; - get_script_result() &lt;br&gt;  &lt;br&gt;   Returns g.app.scriptResult, where g.app is the hidden app. &lt;br&gt;  &lt;br&gt; - init() &lt;br&gt;   Calls leo.run(pymacs=True) to create a hidden Leo application. &lt;br&gt;   Later calls to open can open hidden Leo outlines that can be accessed via runScript. &lt;br&gt;  &lt;br&gt; - open(fileName) &lt;br&gt;  &lt;br&gt;   Opens the .leo file given by fileName. fileName must be the full &lt;br&gt;   path to a .leo file. Returns the commander of the open Leo outline, &lt;br&gt;   or None if the outline could not be opened. &lt;br&gt;  &lt;br&gt; - run_script(c,script,p=None) &lt;br&gt;  &lt;br&gt;   Executes a script in the context of a commander c returned by the leoPymacs.open. &lt;br&gt;   c may be None, in which case a dummy commander is created in which to run the script. &lt;br&gt;   In the executed script, p is set to c.p if no p argument is specified. &lt;br&gt;   Returns g.app.scriptResult, where g.app is the hidden app. &lt;br&gt; " id="685" linkTypes="1" links="324" title="Functions in leoPymacs.py" />
<node body="Leo's mini-buffer is a text area at the bottom of the body pane. You use Leo's minibuffer like the Emacs mini-buffer to invoke commands by their so-called *long name*. The following commands affect the minibuffer: &lt;br&gt;  &lt;br&gt; - **full-command**: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a full command name, then hit &lt;Return&gt; to execute the command. Tab completion works, but not yet for file names. &lt;br&gt;  &lt;br&gt; - **quick-command-mode**: (default shortcut: Alt-x) Like Emacs Control-C. This mode is defined in leoSettings.leo. It is useful for commonly-used commands. &lt;br&gt;  &lt;br&gt; - **universal-argument**: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat count for later command. Ctrl-u 999 a adds 999 a's. &lt;br&gt;  &lt;br&gt; - **keyboard-quit**: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts the focus in the body pane. &lt;br&gt;  &lt;br&gt; For example, to print a list of all commands type Alt-X print-commands &lt;Return&gt;. &lt;br&gt; " id="686" linkTypes="1" links="324" title="The minibuffer" />
<node body="In general, vim-mode in Leo works much as in the real vim. There are three modes, insert, normal and visual. &lt;br&gt;  &lt;br&gt;  &lt;br&gt;      &lt;br&gt; " id="687" linkTypes="3 3 3 3 3" links="1165 1166 1167 1168 1169" title="Using Leo's native vim mode" />
<node body="Leo can automatically import and export vimoutline (.otl) files. Nodes like:: &lt;br&gt;  &lt;br&gt;     @auto-otl &lt;path to .otl file&gt; &lt;br&gt;  &lt;br&gt; or equivalently:: &lt;br&gt;  &lt;br&gt;     @auto-vimoutline &lt;path to .otl file&gt; &lt;br&gt;      &lt;br&gt; import the .otl as a Leo outline. &lt;br&gt;  &lt;br&gt; These nodes work like other @auto nodes: when Leo loads an outline, Leo reads the .otl file into the @auto-otl tree. When Leo writes an outline, Leo writes any @auto-otl tree back to the .otl file. &lt;br&gt;  &lt;br&gt; After creating an @auto-otl node by hand, be sure to use Leo's refresh-from-disk command to populate the node. Do this *before* saving the .leo file. If you try to save an empty @auto-otl node Leo will warn you that you are about to overwrite the file. &lt;br&gt;  &lt;br&gt; The refresh-from-disk command creates an @auto-otl node whose **children** represent the contents of the external .otl file. Leo does *not* write the @auto-otl node itself. This allows you to put Leo directives in the node. &lt;br&gt; " id="688" linkTypes="1" links="325" title="Using vimoutline (.otl) files in Leo" />
<node body="" id="689" linkTypes="3 3 3 3 3 3" links="1170 1171 1172 1173 1174 1175" title="Using stand-alone vim bindings" />
<node body="Leo's ``--ipython`` command-line option enables two-way communication (**ILeo**, the **IPython bridge**) between Leo and IPython: you can run Leo scripts from IPython, and IPython scripts from Leo. &lt;br&gt;  &lt;br&gt; The level of integration is much deeper than conventional integration in IDEs. Most notably, you are able to store and manipulate *data* in Leo nodes, in addition to mere program code--essentially making ILeo a hierarchical spreadsheet, albeit with non-grid view of the data. The possibilities of this are endless, and the approach can be applied in wide range of problem domains with very little actual coding. &lt;br&gt; " id="690" linkTypes="1" links="326" title="Overview" />
<node body=".. _`run Leo in a console window`: installing.html#running-leo-from-a-console-window &lt;br&gt;  &lt;br&gt; To run Leo's IPython bridge: &lt;br&gt;  &lt;br&gt; 1. Install IPython 4.0 and above and Jupyter. &lt;br&gt;  &lt;br&gt; 2. `run Leo in a console window`_ with the ``--ipython`` command-line option enabled. This option starts an instance of the IPython shell in the console. Leo and IPython run simultaneously and independently. Their separate event loops do not interfere with each other. The ipython-new command launches new terminals connected to the same IPython kernel. &lt;br&gt; " id="691" linkTypes="1" links="326" title="Starting ILeo" />
<node body="*You can run any Leo script from IPython*. The IPython bridge injects an object called _leo into IPython's namespace. IPython scripts may access Leo's c and g objects as follows:: &lt;br&gt;  &lt;br&gt;     c,g = _leo.c, _leo.g &lt;br&gt;  &lt;br&gt; This allows IPython scripts to do *anything* that a Leo script can do. Scripts run from IPython *immediately* change Leo, *exactly* as if the script were run from Leo. &lt;br&gt;  &lt;br&gt; **Important**: the _leo object is an instance of LeoNameSpace class, defined in leo.core.leoIPython.py. This class allows IPython scripts to access multiple Leo outlines at once. See the actual code for details. &lt;br&gt;  &lt;br&gt; **Note**: _leo.c is a property which can return None in some situations. Here is its definition: &lt;br&gt;  &lt;br&gt; .. code-block:: python &lt;br&gt;  &lt;br&gt;     def __get_c(self): &lt;br&gt;         '''Return the designated commander, or the only open commander.''' &lt;br&gt;         self.update() &lt;br&gt;         if self.commander and self.commander in self.commanders_list: &lt;br&gt;             return self.commander &lt;br&gt;         elif len(self.commanders_list) == 1: &lt;br&gt;             return self.commanders_list[0] &lt;br&gt;         else: &lt;br&gt;             return None &lt;br&gt;      &lt;br&gt;     def __set_c(self,c): &lt;br&gt;         '''Designate the commander to be returned by the getter.''' &lt;br&gt;         self.update() &lt;br&gt;         if c in self.commanders_list: &lt;br&gt;             self.commander = c &lt;br&gt;         else: &lt;br&gt;             g.trace(g.callers()) &lt;br&gt;             raise ValueError(c) &lt;br&gt;      &lt;br&gt;     c = property( &lt;br&gt;         __get_c, __set_c, &lt;br&gt;         doc = &quot;LeoNameSpace c property&quot;) &lt;br&gt; " id="692" linkTypes="1" links="326" title="Running Leo scripts from IPython" />
<node body="*You can run any IPython script from Leo*. Leo's ipython-exec command executes the body text of the presently selected Leo node in the address space of the IPython shell. Such scripts *immediately* affect the IPython interpreter. &lt;br&gt;  &lt;br&gt; The IPython bridge sets several global variables *within Leo*, allowing Leo scripts *complete* access to all of IPython's code and data: &lt;br&gt;  &lt;br&gt; - g.app.ipk is a *singleton* instance of the InternalIPKernel class, &lt;br&gt;   defined in leoIPython.py. &lt;br&gt; - g.app.ipk.namespace is IPython's namespace. &lt;br&gt; - g.app.ipk.kernelApp is an IPython IPKernelApp object. &lt;br&gt; - g.app.ipk.kernelApp.shell is an IPython InteractiveShell object. &lt;br&gt;   Depending on your installation, this may be a ZMQInteractiveShell. &lt;br&gt; " id="693" linkTypes="1" links="326" title="Running IPython scripts from Leo" />
<node body=".. _`IPython Notebook`: http://projects.scipy.org/ipython/ipython/wiki/NoteBook &lt;br&gt;  &lt;br&gt; The IPython bridge turns Leo into another kind of `IPython Notebook`_. IPython users typically use %edit to produce non-trivial functions/classes instead of entering them directly on the interactive prompt. But this is a bit clumsy. With Leo, *every Leo node works like an IPython %edit file*: &lt;br&gt;  &lt;br&gt; - You can execute any Leo node in IPython with ipython-exec. &lt;br&gt; - Saving your Leo outline saves all your IPython scripts. &lt;br&gt; - You can use Leo as always to organize all your IPython scripts. &lt;br&gt; " id="694" linkTypes="1" links="326" title="ILeo as an IPython notebook" />
<node body="Leo's valuespace.py plugin uses the ipython namespace when the ``--ipython`` command line switch is in effect. &lt;br&gt;  &lt;br&gt; This plugin provides a &quot;workbook&quot; like way to get data from Leo document to the namespace, and do calculations based on that data. Having this data be accessible to the ipython instance makes it convenient to interact and poke around with the same data. &lt;br&gt; " id="695" linkTypes="1" links="326" title="ILeo and the valuespace plugin" />
<node body="This idea got started when I (Ville M. Vainio) saw this post by Edward Ream on IPython developer mailing list: http://lists.ipython.scipy.org/pipermail/ipython-dev/2008-January/003551.html &lt;br&gt;  &lt;br&gt; I was using FreeMind as mind mapping software, and so I had an immediate use case for Leo (which, incidentally, is superior to FreeMind as mind mapper). The wheels started rolling, I got obsessed with the power of this concept (everything clicked together), and Edwards excitement paralleled mine. Everything was mind-bogglingly easy/trivial, something that is typical of all promising technologies. &lt;br&gt;  &lt;br&gt; The goal of close cooperation between Leo and IPython went from vague dream to completed reality over the span of about 10 days. The IPython bridge has continued to evolve since then. &lt;br&gt; " id="696" linkTypes="1" links="326" title="Acknowledgements and history" />
<node body="Host programs use the leoBridge module as follows:: &lt;br&gt;  &lt;br&gt;     import leo.core.leoBridge as leoBridge &lt;br&gt;      &lt;br&gt;     controller = leoBridge.controller(gui='nullGui', &lt;br&gt;         loadPlugins=True,  # True: attempt to load plugins. &lt;br&gt;         readSettings=True, # True: read standard settings files. &lt;br&gt;         silent=False,      # True: don't print signon messages. &lt;br&gt;         verbose=False)     # True: print informational messages. &lt;br&gt;  &lt;br&gt;     g = controller.globals() &lt;br&gt;     c = controller.openLeoFile(path) &lt;br&gt;  &lt;br&gt; Let us look at these statements in detail. The first two statements import the leoBridge module and create a **bridge controller**. In effect, these statements embed an invisible copy of Leo into the host program. This embedded copy of Leo uses a null gui, which simulates all aspects of Leo's normal gui code without creating any screen objects. &lt;br&gt;  &lt;br&gt; The statement:: &lt;br&gt;  &lt;br&gt;     g = controller.globals() &lt;br&gt;  &lt;br&gt; provides access to Leo's leoGlobals module, and properly inits globals such as g.app, g.app.gui, etc. *Host programs should not import leoGlobals directly*, because doing so would not init the g.app object properly. &lt;br&gt;  &lt;br&gt; The statement:: &lt;br&gt;  &lt;br&gt;     c = controller.openLeoFile(path) &lt;br&gt;  &lt;br&gt; invisibly opens the .leo file given by the path argument. This call returns a completely standard Leo commander, properly inited. This is the big payoff from the leoBridge module: the host program gets instant access to c.config.getBool, etc. Do you see how sweet this is? &lt;br&gt;  &lt;br&gt; For example, the following script runs leo/test/leoBridgeTest.py outside of Leo. leoBridgeTest.py uses the leoBridge module to run all unit tests in leo/test/unitTest.leo:: &lt;br&gt;  &lt;br&gt;     import os,sys &lt;br&gt;  &lt;br&gt;     path = g.os_path_abspath( &lt;br&gt;         g.os_path_join( &lt;br&gt;             g.app.loadDir,'..','test','leoBridgeTest.py')) &lt;br&gt;  &lt;br&gt;     os.system('%s %s' % (sys.executable,path)) &lt;br&gt;  &lt;br&gt; The file leo/test/test.leo contains the source code for leoBridgeTest.py. Here it is, stripped of its sentinel lines:: &lt;br&gt;  &lt;br&gt;     '''A program to run unit tests with the leoBridge module.''' &lt;br&gt;  &lt;br&gt;     import leo.core.leoBridge as leoBridge &lt;br&gt;     import leo.core.leoTest as leoTest &lt;br&gt;  &lt;br&gt;     def main (): &lt;br&gt;         tag = 'leoTestBridge' &lt;br&gt;  &lt;br&gt;         # Setting verbose=True prints messages that would be sent to the log pane. &lt;br&gt;         bridge = leoBridge.controller(gui='nullGui',verbose=False) &lt;br&gt;         if bridge.isOpen(): &lt;br&gt;             g = bridge.globals() &lt;br&gt;             path = g.os_path_abspath(g.os_path_join( &lt;br&gt;                 g.app.loadDir,'..','test','unitTest.leo')) &lt;br&gt;             c = bridge.openLeoFile(path) &lt;br&gt;             g.es('%s %s' % (tag,c.shortFileName())) &lt;br&gt;             runUnitTests(c,g) &lt;br&gt;  &lt;br&gt;         print tag,'done' &lt;br&gt;  &lt;br&gt;     def runUnitTests (c,g): &lt;br&gt;         nodeName = 'All unit tests' # The tests to run. &lt;br&gt;         try: &lt;br&gt;             u = leoTest.testUtils(c) &lt;br&gt;             p = u.findNodeAnywhere(nodeName) &lt;br&gt;             if p: &lt;br&gt;                 g.es('running unit tests in %s...' % nodeName) &lt;br&gt;                 c.selectPosition(p) &lt;br&gt;                 c.debugCommands.runUnitTests() &lt;br&gt;                 g.es('unit tests complete') &lt;br&gt;             else: &lt;br&gt;                 g.es('node not found:' % nodeName) &lt;br&gt;         except Exception: &lt;br&gt;             g.es('unexpected exception') &lt;br&gt;             g.es_exception() &lt;br&gt;             raise &lt;br&gt;  &lt;br&gt;     if __name__ == '__main__': &lt;br&gt;         main() &lt;br&gt; " id="697" linkTypes="1" links="327" title="The basics" />
<node body="Here is a python program that will run unitTest.leo using the leoBridge module. Change the path as required:: &lt;br&gt;      &lt;br&gt;     import leo.core.leoBridge as leoBridge &lt;br&gt;     import leo.core.leoTest as leoTest &lt;br&gt;     path = &lt;path to unitTest.leo&gt;/unitTest.leo' &lt;br&gt;      &lt;br&gt;     def main (): &lt;br&gt;         tag = 'leoTestBridge' &lt;br&gt;      &lt;br&gt;         # Setting verbose=True prints messages that would be sent to the log pane. &lt;br&gt;         bridge = leoBridge.controller( &lt;br&gt;             gui='nullGui', &lt;br&gt;             loadPlugins=False, &lt;br&gt;             readSettings=False, &lt;br&gt;             silent=True, &lt;br&gt;             verbose=False)  &lt;br&gt;         if bridge.isOpen(): &lt;br&gt;             g = bridge.globals() &lt;br&gt;             c = bridge.openLeoFile(path) &lt;br&gt;             runUnitTests(c,g) &lt;br&gt;         print('done: %s' % tag) &lt;br&gt;      &lt;br&gt;     def runUnitTests (c,g): &lt;br&gt;         nodeName = 'Active unit tests' # The tests to run. &lt;br&gt;         try: &lt;br&gt;             u = leoTest.TestManager(c) &lt;br&gt;             p = u.findNodeAnywhere(nodeName) &lt;br&gt;             if p: &lt;br&gt;                 print('running unit tests in %s...' % nodeName) &lt;br&gt;                 c.selectPosition(p) &lt;br&gt;                 c.debugCommands.runSelectedUnitTestsLocally() &lt;br&gt;                 print('unit tests complete') &lt;br&gt;             else: &lt;br&gt;                 print('===== node not found: %s' % nodeName) &lt;br&gt;         except Exception: &lt;br&gt;             print('unexpected exception') &lt;br&gt;             g.es_print_exception() &lt;br&gt;             raise &lt;br&gt;      &lt;br&gt;     if __name__ == '__main__': &lt;br&gt;         main()" id="698" linkTypes="1" links="327" title="Example: running unit tests from leoBridge" />
<node body="This following is adapted from Terry Brown's entry in Leo's wiki. &lt;br&gt;  &lt;br&gt; You can not just run leoBridge from Leo, because the leoBridge module is designed to run a separate copy of Leo. However, it is possible to run leoBridge from a separate process. That turned out to be more, um, interesting than anticipated, so I'm recording the results here. &lt;br&gt;  &lt;br&gt; The idea is that script A running in Leo (i.e. in a regular GUI Leo session) calls script B through subprocess.Popen(), script B uses LeoBridge to do something (parse unloaded Leo files), and returns the result to script A. Passing the result back via the clipboard seemed like a possibility, but XWindows clipboard madness being what it is, that didn't seem to work. &lt;br&gt;  &lt;br&gt; First trick, calling script B from script A:: &lt;br&gt;  &lt;br&gt;     import subprocess &lt;br&gt;     p = subprocess.Popen(('python', &lt;br&gt;         path_to_script_B, &lt;br&gt;         parameter_for_script_B,), &lt;br&gt;         stdout=subprocess.PIPE, &lt;br&gt;         env={'PYTHONPATH': g.app.loadDir,'USER': g.app.leoID}, &lt;br&gt;     ) &lt;br&gt;     p.wait() &lt;br&gt;  &lt;br&gt; Setting PYTHONPATH in the environment seemed like the easiest way to let script B find leoBridge.py (which it needs to import).  But by setting the env parameter you limit script B's environment to be **only** PYTHONPATH, which causes leoBridge to fail because, in unix at least, it depends on USER in the environment.  So you need to pass that through, too. &lt;br&gt;  &lt;br&gt; Now, because passing stuff back on the clipboard seems unreliable, at least in XWindows, script B passes results back to script A via stdout (print), but there's some Leo initialization chatter you want to avoid.  So put a sentinel, 'START_CLIPBOARD', in the output, and collect it like this:: &lt;br&gt;  &lt;br&gt;     response = p.stdout.readlines() &lt;br&gt;     while response and 'START_CLIPBOARD' not in response[0]: &lt;br&gt;         del response[0] &lt;br&gt;     del response[0]  # delete the sentinel as well &lt;br&gt;     response = ''.join(response) &lt;br&gt;  &lt;br&gt; This is the basic mechanism.  What I *actually* wanted to do was have script B generate a branch of nodes and pass that back to script A for insertion in the tree script A is running in.  That's relatively easy if you use:: &lt;br&gt;  &lt;br&gt;     c.setCurrentPosition(pos_of_branch_to_return) &lt;br&gt;     c.copyOutline() &lt;br&gt;     print '&lt;!-- START_CLIPBOARD --&gt;' &lt;br&gt;     print g.app.gui.getTextFromClipboard() &lt;br&gt;     print '&lt;!-- END_CLIPBOARD --&gt;' &lt;br&gt;  &lt;br&gt; at the end of script B. Back in script A, after you've rebuilt &lt;br&gt; `response` as shown above, do:: &lt;br&gt;  &lt;br&gt;     g.app.gui.replaceClipboardWith(response) &lt;br&gt;     c.pasteOutline() &lt;br&gt; " id="699" linkTypes="1" links="327" title="Running leoBridge from within Leo" />
<node body=".. _`Installing ZODB`: http://www.zope.org/Wikis/ZODB/guide/node3.html#SECTION000310000000000000000 &lt;br&gt;  &lt;br&gt; To enable zodb scripting within Leo, you must set use_zodb = True in the root node of leoNodes.py. You must also install ZODB itself.  See `Installing ZODB`_ for details. &lt;br&gt;  &lt;br&gt; When ZODB is installed and use_zodb is True, Leo's vnode class becomes a subclass of ZODB.Persistence.Persistent. This is all that is needed to save/retrieve vnodes or tnodes to/from the ZODB. &lt;br&gt;  &lt;br&gt; **Important notes**: &lt;br&gt;  &lt;br&gt; - Scripts **should not** store or retrieve positions using the ZODB! Doing so makes sense neither from Leo's point of view nor from ZODB's point of view. &lt;br&gt;  &lt;br&gt; - The examples below show how to store or retrieve Leo data by accessing the so-called root of a ZODB connection. However, these are only examples. Scripts are free to do with Leo's vnodes *anything* that can be done with ZODB.Persistence.Persistent objects. &lt;br&gt; " id="700" linkTypes="1" links="328" title="Configuring Leo to use zodb" />
<node body="Scripts should call g.init_zodb to open a ZODB.Storage file. g.init_zodb returns an instance of ZODB.DB.  For example:: &lt;br&gt;  &lt;br&gt;     db = g.init_zodb (zodbStorageFileName) &lt;br&gt;  &lt;br&gt; You can call g.init_zodb as many times as you like. Only the first call for any path actually does anything: subsequent calls for a previously opened path simply return the same value as the first call. &lt;br&gt; " id="701" linkTypes="1" links="328" title="Initing zodb" />
<node body="The following script writes v, a tree of vnodes, to zodb:: &lt;br&gt;  &lt;br&gt;     db = g.init_zodb (zodbStorageFileName) &lt;br&gt;     connection = db.open() &lt;br&gt;     try: &lt;br&gt;         root = connection.root() &lt;br&gt;         root[aKey] = v # See next section for how to define aKey. &lt;br&gt;     finally: &lt;br&gt;         get_transaction().commit() &lt;br&gt;         connection.close() &lt;br&gt;  &lt;br&gt; Notes: &lt;br&gt;  &lt;br&gt; - v must be a vnode. &lt;br&gt;   Scripts should *not* attempt to store Leo positions in the zodb. &lt;br&gt;   v can be the root of an entire outline or a subtree. &lt;br&gt;   For example, either of the following would be reasonable:: &lt;br&gt;  &lt;br&gt;     root[aKey] = c.rootPosition().v &lt;br&gt;     root[aKey] = c.p.v &lt;br&gt;  &lt;br&gt; - To write a single vnode without writing any of its children you can use v.detach. &lt;br&gt;   For example:: &lt;br&gt;  &lt;br&gt;     root[aKey] = v.detach() &lt;br&gt;  &lt;br&gt; - **Important**: It is simplest if only one zodb connection is open at any one time, &lt;br&gt;   so scripts would typically close the zodb connection immediately after processing the data. &lt;br&gt;   The correct way to do this is in a finally statement, as shown above. &lt;br&gt;  &lt;br&gt; - The script above does not define aKey. &lt;br&gt;   The following section discusses how to define reasonable zodb keys. &lt;br&gt; " id="702" linkTypes="1" links="328" title="Writing data to zodb" />
<node body="The keys used to store and retrieve data in connection.root() can be any string that uniquely identifies the data. The following are only suggestions; you are free to use any string you like. &lt;br&gt;  &lt;br&gt; 1. When saving a file, you would probably use a key that is similar to a real file path. &lt;br&gt;    For example:: &lt;br&gt;  &lt;br&gt;         aKey = c.fileName() &lt;br&gt;  &lt;br&gt; 2. When saving a single vnode or tree of vnodes, say v, &lt;br&gt;    a good choice would be to use v's gnx, namely:: &lt;br&gt;  &lt;br&gt;         aKey = g.app.nodeIndices.toString(v.fileIndex) &lt;br&gt;  &lt;br&gt;    Note that v.detach() does not automatically copy v.fileIndex to the detached node, &lt;br&gt;    so when writing a detached node you would typically do the following:: &lt;br&gt;  &lt;br&gt;        v2 = v.detach() &lt;br&gt;        v2.fileIndex = v.fileIndex &lt;br&gt;        aKey = g.app.nodeIndices.toString(v2.fileIndex) &lt;br&gt; " id="703" linkTypes="1" links="328" title="Defining zodb keys" />
<node body="The following script reads a tree of vnodes from zodb and sets p as the root position of the tree:: &lt;br&gt;  &lt;br&gt;     try: &lt;br&gt;         connection = db.open() &lt;br&gt;         root = connection.root() &lt;br&gt;         v = root.get(aKey) &lt;br&gt;         p = leoNodes.position(v) &lt;br&gt;     finally: &lt;br&gt;         get_transaction().commit() &lt;br&gt;         connection.close() &lt;br&gt; " id="704" linkTypes="1" links="328" title="Reading data from zodb" />
<node body="The scripts shown above close the zodb connection after processing the data. This is by far the simplest strategy. I recommend it for typical scripts. &lt;br&gt;  &lt;br&gt; **Important**: you must **leave the connection open** if your script modifies persistent data in any way. (Actually, this statement is not really true, but you must define zodb transaction managers if you intend to use multiple connections simultaneously. This complication is beyond the scope of this documentation.) For example, it would be possible to create a new Leo outline from the data just read, but the script must leave the connection open. I do not recommend this tactic, but for the adventurous here is some sample code:: &lt;br&gt;  &lt;br&gt;     connection = self.db.open() &lt;br&gt;     root = connection.root() &lt;br&gt;     v = root.get(fileName) &lt;br&gt;     if v: &lt;br&gt;         c2 = c.new() &lt;br&gt;         c2.openDirectory = c.openDirectory # A hack. &lt;br&gt;         c2.mFileName = fileName # Another hack. &lt;br&gt;         c2.beginUpdate() &lt;br&gt;         try: &lt;br&gt;             c2.setRootVnode(v) &lt;br&gt;             c2Root = c2.rootPosition() &lt;br&gt;             c2.atFileCommands.readAll(c2Root) &lt;br&gt;             g.es_print('zodb read: %s' % (fileName)) &lt;br&gt;         finally: &lt;br&gt;             c2.endUpdate() &lt;br&gt;         # Do *not* close the connection while the new Leo window is open! &lt;br&gt;     else: &lt;br&gt;         g.es_print('zodb read: not found: %s' % (fileName)) &lt;br&gt;  &lt;br&gt;  &lt;br&gt; This will work **provided** that no other zodb connection is ever opened while this connection is opened. Unless special zodb precautions are taken (like defining zodb transaction managers) calling get_transaction().commit() will affect **all** open connections. You have been warned. &lt;br&gt; " id="705" linkTypes="1" links="328" title="About connections" />
<node body="" id="706" linkTypes="3 3" links="1176 1177" title="Convenience routines" />
<node body=".. _`Customizing Leo`: customizing.html &lt;br&gt;  &lt;br&gt; This section discusses only those settings that affect syntax coloring. See `Customizing Leo`_ for a general discussion of Leo's settings. &lt;br&gt;  &lt;br&gt; Both the old colorizer (in Leo's core) and the new colorizer (the threading_colorizer and qtGui plugins) now support @color and @font settings for colorizing options. The settings for the old colorizer are:: &lt;br&gt;  &lt;br&gt;     comment_font, cweb_section_name_font, directive_font, &lt;br&gt;     doc_part_font, keyword_font, leo_keyword_font, section_name_font, &lt;br&gt;     section_name_brackets_font, string_font, undefined_section_name_font, &lt;br&gt;     latexBackground_font, and latex_background_font. &lt;br&gt;  &lt;br&gt; The settings for the new colorizer are all of the above (except keyword_font) plus the following:: &lt;br&gt;  &lt;br&gt;     comment1_font, comment2_font, comment3_font, comment4_font, function_font, &lt;br&gt;     keyword1_font, keyword2_font, keyword3_font, keyword4_font, label_font, &lt;br&gt;     literal1_font, literal2_font, literal3_font, literal4_font, markup_font, &lt;br&gt;     null_font, and operator_font. &lt;br&gt;      &lt;br&gt; To specify a color, say for comment1, for *all* languages, create an @color node:: &lt;br&gt;  &lt;br&gt;     @color comment1_color = blue &lt;br&gt;      &lt;br&gt; To specify a color for a **particular** language, say Python, prepend the setting name &lt;br&gt; with the language name.  For example:: &lt;br&gt;  &lt;br&gt;     @color python_comment1_color = pink &lt;br&gt;  &lt;br&gt; To specify a font, say for keyword_font, to be used as the default font for **all** languages, put the following in the body text of an @font node in leoSettings.leo:: &lt;br&gt;  &lt;br&gt;     # keyword_font_family = None &lt;br&gt;     keyword_font_size = 16 &lt;br&gt;     keyword_font_slant = roman &lt;br&gt;         # roman, italic &lt;br&gt;     keyword_font_weight = bold &lt;br&gt;         # normal, bold &lt;br&gt;  &lt;br&gt; Comments are allowed and undefined settings are set to reasonable defaults. At present, comments can not follow a setting: comments must start a line. &lt;br&gt;  &lt;br&gt; You can specify per-language settings by preceding the settings names by a prefix x. Such settings affect only colorizing for language x (i.e., all the modes in modes/x.py when using the new colorizer). For example, to specify a font for php (only), put the following in the body text of an @font node in leoSettings.leo:: &lt;br&gt;  &lt;br&gt;     # php_keyword_font_family = None &lt;br&gt;     php_keyword_font_size = 16 &lt;br&gt;     php_keyword_font_slant = roman &lt;br&gt;         # roman, italic &lt;br&gt;     php_keyword_font_weight = bold &lt;br&gt;         # normal, bold &lt;br&gt; " id="707" linkTypes="1" links="329" title="Syntax coloring settings" />
<node body=".. _jEdit: http://www.jedit.org/ &lt;br&gt; .. _`jEdit's documentation`: http://www.jedit.org/42docs/users-guide/writing-modes-part.html &lt;br&gt;  &lt;br&gt; The `jEdit`_ editor drives its syntax colorer using xml **language description files.** Rather than using the xml language description files directly, Leo uses Python **colorer control files**, created automatically from the xml files by a script called jEdit2Py.  All these files reside in the leo/modes directory. &lt;br&gt;  &lt;br&gt; These Python files contain all the information in the jEdit's xml files, so we can (loosely) speak of modes, rulesets, rules, properties and attributes in the Python colorer control files. Later sections of this documentation will make this loose correspondence exact. &lt;br&gt;  &lt;br&gt; `jEdit's documentation`_ contain a complete description of these xml files. Each xml file describes one **colorizing mode**. A mode consists of one or more **rulesets**, and each ruleset consists of a list of **colorizing rules**. In addition, modes, rulesets and rules may have associated **properties** and **attributes**. Various rules may specify that the colorizer uses another ruleset (either in the same mode or another mode). &lt;br&gt;  &lt;br&gt; **Important**: jEdit's xml language description files contain no explicit &lt;RULE&gt; elements Rules are simply sub-elements of an enclosing &lt;RULES&gt; element. The element indicates the kind of rule that is specified, for example, &lt;SPAN&gt;, &lt;SEQ&gt;, etc. By the term **rule element** we shall mean any sub-element of the &lt;RULES&gt; element. &lt;br&gt;  &lt;br&gt; **Important**: throughout this documentation, **x.py** will refer to the Python colorer for language x, and **x.xml** will refer to the corresponding xml language-description file. &lt;br&gt;  &lt;br&gt; Using Python colorer control files has the following advantages: &lt;br&gt;  &lt;br&gt; - Running jEdit2Py need only be done when x.xml changes, and the speed of the xml parser in jEdit2Py does not affect the speed of Leo's colorizer in any way. Moreover, the jEdit2Py script can contain debugging traces and checks. &lt;br&gt;  &lt;br&gt; - Colorer control files are valid .py files, so all of Python's import optimizations work as usual. In particular, all the data in colorer control files is immediately accessible to Leo's colorer. &lt;br&gt;  &lt;br&gt; - Colorer control files are easier for humans to understand and modify than the equivalent xml file. Furthermore, it is easy to insert debugging information into Python colorer control files. &lt;br&gt;  &lt;br&gt; - It is easy to modify the Python colorer control files 'by hand' without changing the corresponding xml file. In particular, it would be easy to define entirely new kinds of pattern-matching rules in Python merely by creating functions in a colorer control file. &lt;br&gt; " id="708" linkTypes="1" links="329" title="Files" />
<node body="When Leo's syntax colorer sees the '@language x' directive, it will import x.py from Leo's modes folder. The colorer can then access any module-level object obj in x.py as x.obj. &lt;br&gt;  &lt;br&gt; Colorizer control files contain **rules functions** corresponding to rule elements in x.xml. The colorizer can call these functions as if they were members of the colorizer class by passing 'self' as the first argument of these functions. I call these rules *functions* to distinguish them from the corresponding **rules methods** which are actual methods of the colorizer class. Rules *functions* merely call corresponding rules *methods*. Indeed, rules functions are simply a way of binding values to keyword arguments of rules methods. These keywords arguments correspond to the xml attributes of rule elements in x.xml. &lt;br&gt;  &lt;br&gt; The colorizer calls rules functions until one matches, at which point a range of text gets colored and the process repeats. The inner loop of the colorizer is this code:: &lt;br&gt;  &lt;br&gt;     for f in self.rulesDict.get(s[i],[]): &lt;br&gt;         n = f(self,s,i) &lt;br&gt;         if n &gt; 0: &lt;br&gt;             i += n ; break &lt;br&gt;         else: i += 1 &lt;br&gt;  &lt;br&gt; - rulesDict is a dictionary whose keys are rulesets and whose values are ruleset dictionaries. &lt;br&gt;   Ruleset dictionaries have keys that are single characters and whose values are &lt;br&gt;   the list of rules that can start with that character.  &lt;br&gt;  &lt;br&gt; - s is the full text to be colorized. &lt;br&gt;  &lt;br&gt; - i is the position within s is to be colorized. &lt;br&gt;  &lt;br&gt; Rules methods (and functions) return n &gt; 0 if they match, and n == 0 if they fail. &lt;br&gt; " id="709" linkTypes="1" links="329" title="The colorizer's inner loop" />
<node body="The following sections describe the top-level data in x.py. &lt;br&gt; " id="710" linkTypes="3 3 3 3 3 3" links="1178 1179 1180 1181 1182 1183" title="Format of colorizer control files" />
<node body="This section describes each rules method in Leo's new colorizer. Rules methods are called by rules functions in colorizer control file; they correspond directly to rules elements in jEdit's language description files. In fact, this documentation is a 'refactoring' of `jEdit's documentation`_. &lt;br&gt;  &lt;br&gt; All rule methods attempt to match a pattern at a particular spot in a string. These methods all return True if the match succeeds. &lt;br&gt; " id="711" linkTypes="3 3 3 3 3 3 3 3 3 3 3" links="1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194" title="Rule methods" />
<node body="A plugin is a Python file in Leo's plugins folder. &lt;br&gt;  &lt;br&gt; Every plugin should have a top-level init function that returns True if the plugin has been initialized properly. The init function typically: &lt;br&gt;  &lt;br&gt; 1. Registers an onCreate event handler, called when Leo creates a new window. &lt;br&gt; 2. Calls g.plugin_signon(__name__) &lt;br&gt;  &lt;br&gt; For example:: &lt;br&gt;  &lt;br&gt;     def init(): &lt;br&gt;         if &lt;&lt; all imports successful &gt;&gt;: &lt;br&gt;             g.registerHandler('after-create-leo-frame',onCreate) &lt;br&gt;             g.plugin_signon(__name__) &lt;br&gt;             return True &lt;br&gt;         else: &lt;br&gt;             return False &lt;br&gt;     &lt;br&gt; Plugins do *not* have automatic access to c, g and p. &lt;br&gt;  &lt;br&gt; Plugins define g by importing it:: &lt;br&gt;  &lt;br&gt;     import leo.core.leoGlobals as g &lt;br&gt;      &lt;br&gt; Plugins gain access to c using event handlers:: &lt;br&gt;  &lt;br&gt;     controllers = {} &lt;br&gt;      &lt;br&gt;     def init(): &lt;br&gt;         g.registerHandler('after-create-leo-frame',onCreate) &lt;br&gt;         return True &lt;br&gt;          &lt;br&gt;     def onCreate (tag, keys): &lt;br&gt;         global controllers &lt;br&gt;         c = keys.get('c') &lt;br&gt;         if c: &lt;br&gt;             hash = c.hash() &lt;br&gt;             if hash not in controllers.keys(): &lt;br&gt;                 controllers(hash) = PluginController(c) &lt;br&gt;              &lt;br&gt;     def eventHander(tag,keys): &lt;br&gt;         global controllers &lt;br&gt;         c = keys.get('c') &lt;br&gt;         if c: &lt;br&gt;             controller = controllers.get(c.hash()) &lt;br&gt;             controller.handleEvent() &lt;br&gt;              &lt;br&gt; Some plugins inject ivars into the Commands class rather than using a global controllers dict:: &lt;br&gt;  &lt;br&gt;     def onCreate (tag, keys): &lt;br&gt;         c = keys.get('c') &lt;br&gt;         if c: &lt;br&gt;             c.my_plugin_controller = ControllerClass(c) &lt;br&gt;              &lt;br&gt;     def eventHander(tag,keys): &lt;br&gt;         c = keys.get('c') &lt;br&gt;         if c: &lt;br&gt;             c.my_plugin_controller.handleEvent() &lt;br&gt;  &lt;br&gt; Once c is determined, the presently selected position is simply c.p. &lt;br&gt; " id="712" linkTypes="1" links="330" title="Writing Plugins" />
<node body="Naively using plugins can expose you and your .leo files to malicious attacks. The fundamental principles are:: &lt;br&gt;  &lt;br&gt;     Scripts and plugins must never blindly execute code from untrusted sources. &lt;br&gt;  &lt;br&gt; and:: &lt;br&gt;  &lt;br&gt;     .leo files obtained from other people may potentially contain hostile code. &lt;br&gt;  &lt;br&gt; Stephen Schaefer summarizes the danger this way:: &lt;br&gt;  &lt;br&gt;     I foresee a future in which the majority of leo projects come from &lt;br&gt;     marginally trusted sources...a world of leo documents sent hither &lt;br&gt;     and yon - resumes, project proposals, textbooks, magazines, &lt;br&gt;     contracts - and as a race of Pandora's, we cannot resist wanting &lt;br&gt;     to see &quot;What's in the box?&quot; And are we going to fire up a text &lt;br&gt;     editor to make a detailed examination of the ASCII XML? Never! &lt;br&gt;     We're going to double click on the cute leo file icon, and leo &lt;br&gt;     will fire up in all its raging glory. Just like Word (and its &lt;br&gt;     macros) or Excel (and its macros). &lt;br&gt;  &lt;br&gt; In other words:: &lt;br&gt;  &lt;br&gt;     When we share &quot;our&quot; .leo files we can NOT assume that we know what &lt;br&gt;     is in our &quot;own&quot; documents! &lt;br&gt;  &lt;br&gt; Not all environments are untrustworthy. Code in a commercial cvs repository is probably trustworthy: employees might be terminated for posting malicious code. Still, the potential for abuse exists anywhere. &lt;br&gt;  &lt;br&gt; In Python it is very easy to write a script that will blindly execute other scripts:: &lt;br&gt;  &lt;br&gt;     # Warning: extremely dangerous code &lt;br&gt;  &lt;br&gt;     # Execute the body text of all nodes that start with `@script`. &lt;br&gt;     def onLoadFile(): &lt;br&gt;         for p in c.all_positions(): &lt;br&gt;             h = p.h.lower() &lt;br&gt;             if g.match_word(h,0,&quot;@script&quot;): &lt;br&gt;                 s = p.b &lt;br&gt;                 if s and len(s) &gt; 0: &lt;br&gt;                     try: # SECURITY BREACH: s may be malicious! &lt;br&gt;                         exec(s + '\n') &lt;br&gt;                     except: &lt;br&gt;                         es_exception() &lt;br&gt;  &lt;br&gt; Executing this kind of code is typically an intolerable security risk. **Important**: rexec provides *no protection whatever*. Leo is a repository of source code, so any text operation is potentially malicious. For example, consider the following script, which is valid in rexec mode:: &lt;br&gt;  &lt;br&gt;     badNode = c.p &lt;br&gt;     for p in c.all_positions(): &lt;br&gt;         &lt;&lt; change `rexec` to `exec` in p's body &gt;&gt; &lt;br&gt;     &lt;&lt; delete badNode &gt;&gt; &lt;br&gt;     &lt;&lt; clear the undo stack &gt;&gt; &lt;br&gt;  &lt;br&gt; This script will introduce a security hole the .leo file without doing anything prohibited by rexec, and without leaving any traces of the perpetrating script behind. The damage will become permanent *outside* this script when the user saves the .leo file. &lt;br&gt; " id="713" linkTypes="1" links="330" title="Important security warnings" />
<node body="Documenting new plugins is important for users to be able understand and use the features they add. To that effect, there are a few documentation steps that should not be overlooked. &lt;br&gt;  &lt;br&gt; - Document the plugin thoroughly in the plugin's docstring. This allows the documentation to be accessed from the Plugins menu. &lt;br&gt;    &lt;br&gt; - Document any new commands with a proper docstring. This allows the minibuffer command `help-for-command` to provide help for the command. &lt;br&gt;    &lt;br&gt; - In `leo/doc/sphinx-docs/sphinxDocs.leo`, to the node `@file leo.plugins.rst`, add the following snippet (preferably in alphabetical order), with the name of the plugin modified to the name of your plugin (here `ipython`). This allows the API docs to be automatically updated:: &lt;br&gt;  &lt;br&gt;     :mod:`ipython` Module &lt;br&gt;     --------------------- &lt;br&gt;      &lt;br&gt;     .. automodule:: leo.plugins.ipython &lt;br&gt;         :members: &lt;br&gt;         :undoc-members: &lt;br&gt;         :show-inheritance: &lt;br&gt; " id="714" linkTypes="1" links="330" title="Documenting plugins" />
<node body="For any commander c: &lt;br&gt;  &lt;br&gt; +------------------------------+--------------------------------------------+ &lt;br&gt; | **Property**                 | **Value**                                  | &lt;br&gt; +------------------------------+--------------------------------------------+ &lt;br&gt; | c.p                          | the presently selected position            | &lt;br&gt; +------------------------------+--------------------------------------------+ &lt;br&gt; | **Ivar**                     | **Value**                                  | &lt;br&gt; +------------------------------+--------------------------------------------+ &lt;br&gt; | c.frame                      | the leoFrame representing the main window. | &lt;br&gt; +------------------------------+--------------------------------------------+ &lt;br&gt; | c.frame.body                 | the leoBody representing the body pane.    | &lt;br&gt; +------------------------------+--------------------------------------------+ &lt;br&gt; | c.frame.body.wrapper         | a leoQTextEditWidget.                      | &lt;br&gt; +------------------------------+--------------------------------------------+ &lt;br&gt; | c.frame.body.wrapper.widget  | a LeoQTextBrowser (a QTextBrowser)         | &lt;br&gt; +------------------------------+--------------------------------------------+ &lt;br&gt; | c.frame.tree                 | a leoQtTree, representing the tree pane    | &lt;br&gt; +------------------------------+--------------------------------------------+ &lt;br&gt; | c.frame.tree.treeWidget      | a LeoQTreeWidget (a QTreeWidget)           | &lt;br&gt; +------------------------------+--------------------------------------------+ &lt;br&gt; | c.user_dict                  | a Python dictionary for use by scripts and | &lt;br&gt; |                              | plugins. Does not persist when Leo exists. | &lt;br&gt; +------------------------------+--------------------------------------------+" id="715" linkTypes="1" links="330" title="c ivars &amp; properties" />
<node body="Plugins and other scripts can register event handlers (also known as hooks):: &lt;br&gt;  &lt;br&gt;     leoPlugins.registerHandler(&quot;after-create-leo-frame&quot;,onCreate) &lt;br&gt;     leoPlugins.registerHandler(&quot;idle&quot;, on_idle)  &lt;br&gt;     leoPlugins.registerHandler((&quot;start2&quot;,&quot;open2&quot;,&quot;command2&quot;), create_open_with_menu)  &lt;br&gt;  &lt;br&gt; As shown above, a plugin may register one or more event handlers with a single call to leoPlugins.registerHandler. Once a hook is registered, Leo will call the registered function' at the named **hook time**. For example:: &lt;br&gt;  &lt;br&gt;     leoPlugins.registerHandler(&quot;idle&quot;, on_idle) &lt;br&gt;  &lt;br&gt; causes Leo to call on_idle at &quot;idle&quot; time. &lt;br&gt;  &lt;br&gt; Event handlers must have the following signature:: &lt;br&gt;  &lt;br&gt;     def myHook (tag, keywords): &lt;br&gt;         whatever &lt;br&gt;  &lt;br&gt; - tag is the name of the hook (a string). &lt;br&gt; - keywords is a Python dictionary containing additional information. The following section describes the contents of the keywords dictionary in detail. &lt;br&gt;  &lt;br&gt; **Important**: hooks should get the proper commander this way:: &lt;br&gt;  &lt;br&gt;     c = keywords.get('c') &lt;br&gt; " id="716" linkTypes="3" links="1195" title="Handling events" />
<node body="If a plugin has a function at the outer (module) level called unitTest, Leo's unit tests will call that function. &lt;br&gt;  &lt;br&gt; So it would be good if writers of plugins would create such a unitTest function. To indicate a failure the unitTest can just throw an exception. Leo's plugins test suite takes care of the rest. &lt;br&gt; " id="717" linkTypes="1" links="330" title="Support for unit testing" />
<node body="**@test nodes** are nodes whose headlines start with @test. The unit test commands convert the body text of @test nodes into a unit test automatically. That is, Leo's unit test commands automatically create a unittest.TestCase instances which run the body text of the @test node. For example, let us consider one of Leo's actual unit tests. The headline is:: &lt;br&gt;  &lt;br&gt;     @test consistency of back/next links &lt;br&gt;  &lt;br&gt; The body text is:: &lt;br&gt;  &lt;br&gt;     if g.unitTesting: &lt;br&gt;         c,p = g.getTestVars() # Optional: prevents pychecker warnings. &lt;br&gt;         for p in c.all_positions(): &lt;br&gt;             back = p.back() &lt;br&gt;             next = p.next() &lt;br&gt;             if back: assert(back.getNext() == p) &lt;br&gt;             if next: assert(next.getBack() == p) &lt;br&gt;  &lt;br&gt; When either of Leo's unit test commands finds this @test node the command will &lt;br&gt; run a unit test equivalent to the following:: &lt;br&gt;  &lt;br&gt;     import leo.core.leoGlobals as g &lt;br&gt;  &lt;br&gt;     class aTestCase (unittest.TestCase): &lt;br&gt;         def shortDescription(): &lt;br&gt;             return '@test consistency of back/next links' &lt;br&gt;         def runTest(): &lt;br&gt;             c,p = g.getTestVars() &lt;br&gt;             for p in c.all_positions(): &lt;br&gt;                 back = p.back() &lt;br&gt;                 next = p.next() &lt;br&gt;                 if back: assert(back.getNext() == p) &lt;br&gt;                 if next: assert(next.getBack() == p) &lt;br&gt;  &lt;br&gt; As you can see, using @test nodes saves a lot of typing: &lt;br&gt;  &lt;br&gt; - You don't have to define a subclass of unittest.TestCase. &lt;br&gt; - Within your unit test, the c, g and p variables are predefined, just like in Leo scripts. &lt;br&gt; - The entire headline of the @test node becomes the short description of the unit test. &lt;br&gt;  &lt;br&gt; **Important note**: notice that the first line of the body text is a **guard line**:: &lt;br&gt;  &lt;br&gt;     if g.unitTesting: &lt;br&gt;  &lt;br&gt; This guard line is needed because this particular @test node is contained in the file leoNodes.py. @test nodes that appear outside of Python source files do not need guard lines. The guard line prevents the unit testing code from being executed when Python imports the leoNodes module; the g.unitTesting variable is True only while running unit tests. &lt;br&gt;  &lt;br&gt; **New in Leo 4.6**: When Leo runs unit tests, Leo predefines the 'self' variable to be the instance of the test itself, that is an instance of unittest.TestCase. This allows you to use methods such as self.assertTrue in @test and @suite nodes. &lt;br&gt;  &lt;br&gt; **Note**: Leo predefines the c, g, and p variables in @test and @suite nodes, just like in other scripts.  Thus, the line:: &lt;br&gt;  &lt;br&gt;     c,p = g.getTestVars() &lt;br&gt;  &lt;br&gt; is not needed. However, it prevents pychecker warnings that c and p are undefined. &lt;br&gt; " id="718" linkTypes="1" links="331" title="Using @test nodes" />
<node body="**@suite nodes** are nodes whose headlines start with @suite. @suite nodes allow you to create and run custom subclasses of unittest.TestCase. &lt;br&gt;  &lt;br&gt; Leo's test commands assume that the body of an suite node is a script that creates a suite of tests and places that suite in g.app.scriptDict['suite']. Something like this:: &lt;br&gt;  &lt;br&gt;     if g.unitTesting: &lt;br&gt;         __pychecker__ = '--no-reimport' # Prevents pychecker complaint. &lt;br&gt;         import unittest &lt;br&gt;         c,p = g.getTestVars() # Optional. &lt;br&gt;         suite = unittest.makeSuite(unittest.TestCase) &lt;br&gt;         &lt;&lt; add one or more tests (instances of unittest.TestCase) to suite &gt;&gt; &lt;br&gt;         g.app.scriptDict['suite'] = suite &lt;br&gt;  &lt;br&gt; **Note**: as in @test nodes, the guard line, 'if unitTesting:', is needed only if the &lt;br&gt; @suite node appears in a Python source file. &lt;br&gt;  &lt;br&gt; Leo's test commands first execute the script and then run suite in g.app.scriptDict.get('suite') using the standard unittest text runner. &lt;br&gt;  &lt;br&gt; You can organize the script in an @suite nodes just as usual using @others, section references, etc. For example:: &lt;br&gt;  &lt;br&gt;     if g.unitTesting: &lt;br&gt;         __pychecker__ = '--no-reimport' &lt;br&gt;         import unittest &lt;br&gt;         c,p = g.getTestVars() # Optional. &lt;br&gt;         # children define test1,test2..., subclasses of unittest.TestCase. &lt;br&gt;         @others  &lt;br&gt;         suite = unittest.makeSuite(unittest.TestCase) &lt;br&gt;         for test in (test1,test2,test3,test4): &lt;br&gt;             suite.addTest(test) &lt;br&gt;         g.app.scriptDict['suite'] = suite &lt;br&gt; " id="719" linkTypes="1" links="331" title="Using @suite nodes" />
<node body="When running unit tests externally, Leo copies any @mark-for-unit-tests nodes to dynamicUnitTest.leo.  Of course, this is in addition to all @test nodes and @suite nodes that are to be executed. You can use @mark-for-unit-test nodes to include any &quot;supporting data&quot; you want, including, say, &quot;@common test code&quot; to be imported as follows:: &lt;br&gt;  &lt;br&gt;     exec(g.findTestScript(c,'@common test code')) &lt;br&gt;  &lt;br&gt; **Note**: putting @settings trees as descendants of an @mark-for-unit-test node will copy the @setting tree, but will *not* actually set the corresponding settings. &lt;br&gt; " id="720" linkTypes="1" links="331" title="Using @mark-for-unit-tests" />
<node body="The run-all-unit-tests-locally and run-unit-tests-locally commands run unit tests in the process that is running Leo. These commands *can* change the outline containing the unit tests. &lt;br&gt;  &lt;br&gt; The run-all-unit-tests and run-unit-tests commands run all tests in a separate process, so unit tests can never have any side effects. These commands never changes the outline from which the tests were run. These commands do the following: &lt;br&gt;  &lt;br&gt; 1. Copy all @test, @suite, @unit-tests and @mark-for-unit-test nodes (including their descendants) to the file test/dynamicUnitTest.leo. &lt;br&gt;  &lt;br&gt; 2. Run test/leoDynamicTest.py in a separate process. &lt;br&gt;  &lt;br&gt;    - leoDynamicTest.py opens dynamicUnitTest.leo with the leoBridge module. &lt;br&gt;      Thus, all unit tests get run with the nullGui in effect. &lt;br&gt;  &lt;br&gt;    - After opening dynamicUnitTest.leo, leoDynamicTest.py runs all unit tests &lt;br&gt;      by executing the leoTest.doTests function. &lt;br&gt;  &lt;br&gt;    - The leoTests.doTests function searches for @test and @suite nodes and &lt;br&gt;      processes them generally as described above. The details are a bit &lt;br&gt;      different from as described, but they usually don't matter. If you *really* &lt;br&gt;      care, see the source code for leoTests.doTests. &lt;br&gt; " id="721" linkTypes="1" links="331" title="How the unit test commands work" />
<node body="The timit button in unitTest.leo allows you to apply Python's timeit module. See http://docs.python.org/lib/module-timeit.html. The contents of @button timer is:: &lt;br&gt;  &lt;br&gt;     import leo.core.leoTest as leoTest &lt;br&gt;     leoTest.runTimerOnNode(c,p,count=100) &lt;br&gt;  &lt;br&gt; runTimerOnNode executes the script in the presently selected node using timit.Timer and prints the results. &lt;br&gt; " id="722" linkTypes="1" links="331" title="\@button timer" />
<node body="The profile button in unitTest.leo allows you to profile nodes using Python's profiler module. See http://docs.python.org/lib/module-profile.html The contents of @button profile is:: &lt;br&gt;  &lt;br&gt;     import leo.core.leoTest as leoTest &lt;br&gt;     leoTest.runProfileOnNode(p,outputPath=None) # Defaults to leo\test\profileStats.txt &lt;br&gt;  &lt;br&gt; runProfileOnNode runs the Python profiler on the script in the selected node, then reports the stats. &lt;br&gt; " id="723" linkTypes="1" links="331" title="\@button profile" />
<node body=".. _`FAQ`: http://leoeditor.com/FAQ.html#how-can-i-use-python-s-pdb-debugger-with-leo &lt;br&gt; .. _`pdb`: https://docs.python.org/3/library/pdb.html &lt;br&gt; .. _`run Leo in a console`: installing.html#running-leo-from-a-console-window &lt;br&gt; .. _`work flow`: http://leoeditor.com/FAQ.html#how-can-i-use-leo-to-develop-leo-itself &lt;br&gt;  &lt;br&gt; Inserting g.trace statements in my Python code is usually my first debugging choice. The g.trace statement prints the name of the function in which the call to g.trace occurs, followed by the value of its arguments. The output of the g.trace goes to the console, so you must `run Leo in a console`_ to use g.trace. &lt;br&gt;  &lt;br&gt; Inserting and deleting g.trace statements is fast, provided that your `work flow`_ makes it easy to restart the program under test. As a result, using g.trace statements is similar to setting tracepoints in a debugger, with the advantage that (disabled) tracepoints remain in the source code for future use. You will find many examples of using g.trace throughout Leo's source code. &lt;br&gt;  &lt;br&gt; My second choice is using g.pdb to set breakpoints for the `pdb`_ debugger. Pdb uses the console for all interaction, so you must `run Leo in a console`_. See the `FAQ`_ for a discussion of both g.trace and g.pdb. &lt;br&gt; " id="724" linkTypes="1" links="332" title="Using g.trace and g.pdb" />
<node body="The following settings in leoSettings.leo control debugger operation. The settings shown here will be assumed to be in effect throughout this chapter:: &lt;br&gt;  &lt;br&gt;     @string debugger_kind = winpdb &lt;br&gt;  &lt;br&gt; This setting controls what debugger the 'Debug Script' script button uses. Eventually this setting will control what debugger the debug command uses:: At present the only valid value is 'winpdb' &lt;br&gt;  &lt;br&gt;     @bool write_script_file = True &lt;br&gt;  &lt;br&gt; True: The execute script command writes the script to be executed to a file, then executes the script using Python's execFile function. The script_file_path setting specifies the path to this file. False (legacy): The execute script command uses Python's exec command to execute the script. &lt;br&gt;  &lt;br&gt; @string script_file_path = ../test/scriptFile.py &lt;br&gt;  &lt;br&gt; The path to the file to be written by the execute-script command. Notes: &lt;br&gt;  &lt;br&gt; - This setting has effect only if the write_script_file setting is True. &lt;br&gt; - Use / as the path delimiter, regardless of platform. &lt;br&gt; - The default path is ../test/scriptFile.py if no path is given. &lt;br&gt; - The path starts at g.app.loadDir, so for example ../test/scriptFile.py is equivalent to leo/test/scriptFile.py. &lt;br&gt; - The filename should end in .py. &lt;br&gt;  &lt;br&gt; @string debugger_path = None &lt;br&gt;  &lt;br&gt; " id="725" linkTypes="1" links="332" title="Settings for winpdb" />
<node body=".. _`embedded winpdb`: http://www.digitalpeers.com/pythondebugger/embedded.htm &lt;br&gt; .. _`winpdb`: http://www.digitalpeers.com/pythondebugger/ &lt;br&gt;  &lt;br&gt; The following three section discuss three ways of debugging scripts with `winpdb`_. The first two sections tell how to debug general scripts; the last section tells how to debug Leo-specific scripts. &lt;br&gt;  &lt;br&gt; winpdb_ and its documentation have been improved recently. For more details, see the `embedded winpdb`_ docs. The discussion of embedded debugging may have been written specifically with Leo in mind. &lt;br&gt; " id="726" linkTypes="3 3" links="1196 1197" title="Debugging scripts with winpdb" />
<node body="The .leo files in Leo's distribution contain many @button nodes (many disabled), that do repetitive chores. Here is one, @button promote-child-bodies, from LeoDocs.leo:: &lt;br&gt;  &lt;br&gt;     '''Copy the body text of all children to the parent's body text.''' &lt;br&gt;  &lt;br&gt;     # Great for creating what's new nodes. &lt;br&gt;     result = [p.b] &lt;br&gt;     b = c.undoer.beforeChangeNodeContents(p) &lt;br&gt;     for child in p.children(): &lt;br&gt;         if child.b: &lt;br&gt;             result.append('\n- %s\n\n%s\n' % (child.h,child.b)) &lt;br&gt;         else: &lt;br&gt;             result.append('\n- %s\n\n' % (child.h)) &lt;br&gt;     p.b = ''.join(result) &lt;br&gt;     c.undoer.afterChangeNodeContents(p,'promote-child-bodies',b) &lt;br&gt;  &lt;br&gt; This creates a fully undoable promote-child-bodies command." id="727" linkTypes="1" links="333" title="\@button example" />
<node body="efc.compareTrees does most of the work of comparing two similar outlines. &lt;br&gt; For example, here is &quot;@button compare vr-controller&quot; in leoPluginsRef.leo:: &lt;br&gt;  &lt;br&gt;     p1 = g.findNodeAnywhere(c, 'class ViewRenderedController (QWidget) (vr)') &lt;br&gt;     p2 = g.findNodeAnywhere(c, 'class ViewRenderedController (QWidget) (vr2)') &lt;br&gt;     assert p1 and p2 &lt;br&gt;     tag = 'compare vr1 &amp; vr2' &lt;br&gt;     c.editFileCommands.compareTrees(p1, p2, tag) &lt;br&gt;  &lt;br&gt; This script will compare the trees whose roots are p1 and p2 and show the results like &quot;Recovered nodes&quot;.  That is, the script creates a node called &quot;compare vr1 &amp; vr2&quot;.  This top-level node contains one child node for every node that is different.  Each child node contains a diff of the node.  The grand children are one or two clones of the changed or inserted node. &lt;br&gt; " id="728" linkTypes="1" links="333" title="Comparing two similar outlines" />
<node body="The following script will create a minimal Leo outline:: &lt;br&gt;  &lt;br&gt;     if 1: &lt;br&gt;         # Create a visible frame. &lt;br&gt;         c2 = g.app.newCommander(fileName=None) &lt;br&gt;     else: &lt;br&gt;         # Create an invisible frame. &lt;br&gt;         c2 = g.app.newCommander(fileName=None,gui=g.app.nullGui) &lt;br&gt;  &lt;br&gt;     c2.frame.createFirstTreeNode() &lt;br&gt;     c2.redraw() &lt;br&gt;      &lt;br&gt;     # Test that the script works. &lt;br&gt;     for p in c2.all_positions(): &lt;br&gt;         g.es(p.h) &lt;br&gt; " id="729" linkTypes="1" links="333" title="Creating minimal outlines" />
<node body="The following puts up a test window when run as a Leo script:: &lt;br&gt;  &lt;br&gt;     from PyQt4 import QtGui &lt;br&gt;     w = QtGui.QWidget() &lt;br&gt;     w.resize(250, 150) &lt;br&gt;     w.move(300, 300) &lt;br&gt;     w.setWindowTitle('Simple test') &lt;br&gt;     w.show() &lt;br&gt;     c.my_test = w # &lt;-- Keep a reference to the window! &lt;br&gt;      &lt;br&gt; **Important**: Something like the last line is essential. Without it, the window would immediately disappear after being created.  The assignment:: &lt;br&gt;  &lt;br&gt;     c.my_test = w &lt;br&gt;      &lt;br&gt; creates a permanent reference to the window so the window won't be garbage collected after the Leo script exits. &lt;br&gt;      &lt;br&gt; " id="730" linkTypes="1" links="333" title="Creating Qt Windows from Leo scripts" />
<node body="Scripts can invoke various dialogs using the following methods of the g.app.gui object. &lt;br&gt;  &lt;br&gt; Here is a partial list. Use typing completion to get the full list:: &lt;br&gt;  &lt;br&gt;     g.app.gui.runAskOkCancelNumberDialog(c,title,message) &lt;br&gt;     g.app.gui.runAskOkCancelStringDialog(c,title,message) &lt;br&gt;     g.app.gui.runAskOkDialog(c,title,message=None,text='Ok') &lt;br&gt;     g.app.gui.runAskYesNoCancelDialog(c,title,message=None, &lt;br&gt;         yesMessage='Yes',noMessage='No',defaultButton='Yes') &lt;br&gt;     g.app.gui.runAskYesNoDialog(c,title,message=None) &lt;br&gt;  &lt;br&gt; The values returned are in ('ok','yes','no','cancel'), as indicated by the method names. Some dialogs also return strings or numbers, again as indicated by their names. &lt;br&gt;  &lt;br&gt; Scripts can run File Open and Save dialogs with these methods:: &lt;br&gt;  &lt;br&gt;     g.app.gui.runOpenFileDialog(title,filetypes,defaultextension,multiple=False) &lt;br&gt;     g.app.gui.runSaveFileDialog(initialfile,title,filetypes,defaultextension) &lt;br&gt;  &lt;br&gt; For details about how to use these file dialogs, look for examples in Leo's own source code. The runOpenFileDialog returns a list of file names. &lt;br&gt; " id="731" linkTypes="1" links="333" title="g.app.gui.run* methods run dialogs" />
<node body="Each commander sets ivars corresponding to settings. &lt;br&gt;  &lt;br&gt; Scripts can get the following ivars of the Commands class:: &lt;br&gt;  &lt;br&gt;     ivars = ( &lt;br&gt;         'output_doc_flag', &lt;br&gt;         'page_width', &lt;br&gt;         'page_width', &lt;br&gt;         'tab_width', &lt;br&gt;         'target_language', &lt;br&gt;         'use_header_flag', &lt;br&gt;     ) &lt;br&gt;     print(&quot;Prefs ivars...\n&quot;,color=&quot;purple&quot;) &lt;br&gt;     for ivar in ivars: &lt;br&gt;         print(getattr(c,ivar)) &lt;br&gt;  &lt;br&gt; If your script sets c.tab_width it should call f.setTabWidth to redraw the screen:: &lt;br&gt;  &lt;br&gt;     c.tab_width = -4    # Change this and see what happens. &lt;br&gt;     c.frame.setTabWidth(c.tab_width) &lt;br&gt; " id="732" linkTypes="1" links="333" title="Getting commander preferences" />
<node body="Settings may be different for each commander. &lt;br&gt;  &lt;br&gt; The c.config class has the following getters. &lt;br&gt;  &lt;br&gt; - c.config.getBool(settingName,default=None) &lt;br&gt; - c.config.getColor(settingName) &lt;br&gt; - c.config.getDirectory(settingName) &lt;br&gt; - c.config.getFloat(settingName) &lt;br&gt; - c.config.getInt(settingName) &lt;br&gt; - c.config.getLanguage(settingName) &lt;br&gt; - c.config.getRatio(settingName) &lt;br&gt; - c.config.getShortcut(settingName) &lt;br&gt; - c.config.getString(settingName) &lt;br&gt;  &lt;br&gt; These methods return None if no setting exists. &lt;br&gt;  &lt;br&gt; The getBool 'default' argument to getBool specifies the value to be returned if the setting does not exist. &lt;br&gt; " id="733" linkTypes="1" links="333" title="Getting configuration settings" />
<node body="The following code can be run from a script to get input from the user using the minibuffer:: &lt;br&gt;  &lt;br&gt;     def getInput (event=None): &lt;br&gt;  &lt;br&gt;        stateName = 'get-input' &lt;br&gt;        k = c.k &lt;br&gt;        state = k.getState(stateName) &lt;br&gt;  &lt;br&gt;        if state == 0: &lt;br&gt;            k.setLabelBlue('Input: ',protect=True) &lt;br&gt;            k.getArg(event,stateName,1,getInput) &lt;br&gt;        else: &lt;br&gt;            k.clearState() &lt;br&gt;            g.es_print('input: %s' % k.arg) &lt;br&gt;  &lt;br&gt;     getInput() &lt;br&gt;  &lt;br&gt; Let's look at this in detail.  The lines:: &lt;br&gt;  &lt;br&gt;     stateName = 'get-input' &lt;br&gt;     k = c.k &lt;br&gt;     state = k.getState(stateName) &lt;br&gt;  &lt;br&gt; define a state *name*, 'get-input', unique to this code. k.getState returns the present state (an int) associated with this state. &lt;br&gt;  &lt;br&gt; When getInput() is first called, the state returned by k.getState will be 0, so the following lines are executed:: &lt;br&gt;  &lt;br&gt;     if state == 0: &lt;br&gt;         k.setLabelBlue('Input: ',protect=True) &lt;br&gt;         k.getArg(event,stateName,1,getInput) &lt;br&gt;  &lt;br&gt; These lines put a protected label in the minibuffer: the user can't delete the label by backspacing. getArg, and the rest of Leo's key handling code, take care of the extremely complex details of handling key strokes in states. The call to getArg never returns. Instead, when the user has finished entering the input by typing &lt;Return&gt; getArg calls getInput so that k.getState will return state 1, the value passed as the third argument to k.getArg. The following lines handle state 1:: &lt;br&gt;  &lt;br&gt;     else: &lt;br&gt;         k.clearState() &lt;br&gt;         g.es_print('input: %s' % k.arg) &lt;br&gt;  &lt;br&gt; k.arg is the value returned by k.getArg. This example code just prints the value of k.arg and clears the input state. &lt;br&gt; " id="734" linkTypes="1" links="333" title="Getting interactive input from scripts" />
<node body="You can add an icon to the presently selected node with c.editCommands.insertIconFromFile(path). path is an absolute path or a path relative to the leo/Icons folder. A relative path is recommended if you plan to use the icons on machines with different directory structures. &lt;br&gt;  &lt;br&gt; For example:: &lt;br&gt;  &lt;br&gt;     path = 'rt_arrow_disabled.gif'  &lt;br&gt;     c.editCommands.insertIconFromFile(path)  &lt;br&gt;  &lt;br&gt; Scripts can delete icons from the presently selected node using the following methods:: &lt;br&gt;  &lt;br&gt;     c.editCommands.deleteFirstIcon()  &lt;br&gt;     c.editCommands.deleteLastIcon()  &lt;br&gt;     c.editCommands.deleteNodeIcons()  &lt;br&gt; " id="735" linkTypes="1" links="333" title="Inserting and deleting icons" />
<node body="Leo dispatches commands using c.doCommand, which calls the &quot;command1&quot; and &quot;command2&quot; hook routines for the given label. c.doCommand catches all exceptions thrown by the command:: &lt;br&gt;  &lt;br&gt;     c.doCommand(c.markHeadline,label=&quot;markheadline&quot;) &lt;br&gt;  &lt;br&gt; You can also call command handlers directly so that hooks will not be called:: &lt;br&gt;  &lt;br&gt;     c.markHeadline() &lt;br&gt;  &lt;br&gt; You can invoke minibuffer commands by name.  For example:: &lt;br&gt;  &lt;br&gt;     c.executeMinibufferCommand('open-outline') &lt;br&gt;  &lt;br&gt; c.keyHandler.funcReturn contains the value returned from the command. In many cases, as above, this value is simply 'break'. &lt;br&gt; " id="736" linkTypes="1" links="333" title="Invoking commands from scripts" />
<node body="Plugins and scripts should call u.beforeX and u.afterX methods to describe the operation that is being performed. **Note**: u is shorthand for c.undoer. Most u.beforeX methods return undoData that the client code merely passes to the corresponding u.afterX method. This data contains the 'before' snapshot. The u.afterX methods then create a bead containing both the 'before' and 'after' snapshots. &lt;br&gt;  &lt;br&gt; u.beforeChangeGroup and u.afterChangeGroup allow multiple calls to u.beforeX and u.afterX methods to be treated as a single undoable entry. See the code for the Replace All, Sort, Promote and Demote commands for examples. The u.beforeChangeGroup and u.afterChangeGroup methods substantially reduce the number of u.beforeX and afterX methods needed. &lt;br&gt;  &lt;br&gt; Plugins and scripts may define their own u.beforeX and afterX methods. Indeed, u.afterX merely needs to set the bunch.undoHelper and bunch.redoHelper ivars to the methods used to undo and redo the operation. See the code for the various u.beforeX and afterX methods for guidance. &lt;br&gt;  &lt;br&gt; p.setDirty and p.setAllAncestorAtFileNodesDirty now return a dirtyVnodeList that all vnodes that became dirty as the result of an operation. More than one list may be generated: client code is responsible for merging lists using the pattern dirtyVnodeList.extend(dirtyVnodeList2) &lt;br&gt;  &lt;br&gt; See the section &lt;&lt; How Leo implements unlimited undo &gt;&gt; in leoUndo.py for more details. In general, the best way to see how to implement undo is to see how Leo's core calls the u.beforeX and afterX methods. &lt;br&gt; " id="737" linkTypes="1" links="333" title="Making operations undoable" />
<node body="The mod_scripting plugin runs @scripts before plugin initiation is complete. Thus, such scripts can not directly modify plugins. Instead, a script can create an event handler for the after-create-leo-frame that will modify the plugin. &lt;br&gt;  &lt;br&gt; For example, the following modifies the cleo.py plugin after Leo has completed loading it:: &lt;br&gt;  &lt;br&gt;     def prikey(self, v): &lt;br&gt;         try: &lt;br&gt;             pa = int(self.getat(v, 'priority')) &lt;br&gt;         except ValueError: &lt;br&gt;             pa = -1 &lt;br&gt;  &lt;br&gt;         if pa == 24: &lt;br&gt;             pa = -1 &lt;br&gt;         if pa == 10: &lt;br&gt;             pa = -2 &lt;br&gt;  &lt;br&gt;         return pa &lt;br&gt;  &lt;br&gt;     import types &lt;br&gt;     from leo.core import leoPlugins &lt;br&gt;  &lt;br&gt;     def on_create(tag, keywords): &lt;br&gt;         c.cleo.prikey = types.MethodType(prikey, c.cleo, c.cleo.__class__) &lt;br&gt;  &lt;br&gt;     leoPlugins.registerHandler(&quot;after-create-leo-frame&quot;,on_create) &lt;br&gt;  &lt;br&gt; Attempting to modify c.cleo.prikey immediately in the @script gives an AttributeError as c has no .cleo when the @script is executed. Deferring it by using registerHandler() avoids the problem. &lt;br&gt; " id="738" linkTypes="1" links="333" title="Modifying plugins with @script scripts" />
<node body="**Important**: The changes you make below **will not persist** unless your script calls c.frame.body.onBodyChanged after making those changes. This method has the following signature:: &lt;br&gt;  &lt;br&gt;     def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None): &lt;br&gt;  &lt;br&gt; Let:: &lt;br&gt;  &lt;br&gt;     w = c.frame.body.wrapper # Leo's body pane. &lt;br&gt;  &lt;br&gt; Scripts can get or change the context of the body as follows:: &lt;br&gt;  &lt;br&gt;     w.appendText(s)                     # Append s to end of body text. &lt;br&gt;     w.delete(i,j=None)                  # Delete characters from i to j. &lt;br&gt;     w.deleteTextSelection()             # Delete the selected text, if any. &lt;br&gt;     s = w.get(i,j=None)                 # Return the text from i to j. &lt;br&gt;     s = w.getAllText                    # Return the entire body text. &lt;br&gt;     i = w.getInsertPoint()              # Return the location of the cursor. &lt;br&gt;     s = w.getSelectedText()             # Return the selected text, if any. &lt;br&gt;     i,j = w.getSelectionRange (sort=True) # Return the range of selected text. &lt;br&gt;     w.replace(i,j,s)                    # Replace the text from i to j by s. &lt;br&gt;     w.setAllText(s)                     # Set the entire body text to s. &lt;br&gt;     w.setSelectionRange(i,j,insert=None) # Select the text. &lt;br&gt;  &lt;br&gt; **Notes**: &lt;br&gt;  &lt;br&gt; - These are only the most commonly-used methods. For more information, consult Leo's source code. &lt;br&gt;  &lt;br&gt; - i and j are zero-based indices into the the text. When j is not specified, it defaults to i. When the sort parameter is in effect, getSelectionRange ensures i &lt;= j. &lt;br&gt;  &lt;br&gt; - color is a Tk color name, even when using the Gt gui. &lt;br&gt; " id="739" linkTypes="1" links="333" title="Modifying the body pane directly" />
<node body="Positions become invalid whenever the outline changes.  &lt;br&gt;  &lt;br&gt; This script finds a position p2 having the same vnode as an invalid position p:: &lt;br&gt;  &lt;br&gt;     if not c.positionExists(p): &lt;br&gt;         for p2 in c.all_positions(): &lt;br&gt;             if p2.v == p.v: # found &lt;br&gt;                 c.selectPosition(p2) &lt;br&gt;         else: &lt;br&gt;             print('position no longer exists') &lt;br&gt; " id="740" linkTypes="1" links="333" title="Recovering vnodes" />
<node body="@pagewidth 75 &lt;br&gt;  &lt;br&gt; The following script won't work as intended: &lt;br&gt;  &lt;br&gt;     from PyQt4 import QtGui &lt;br&gt;     w = QtGui.QWidget() &lt;br&gt;     w.resize(250, 150) &lt;br&gt;     w.move(300, 300) &lt;br&gt;     w.setWindowTitle('Simple test') &lt;br&gt;     w.show() &lt;br&gt;      &lt;br&gt; When the script exits the sole reference to the window, w, ceases to exist, so the window is destroyed (garbage collected). To keep the window open, add the following code as the last line to keep the reference alive:: &lt;br&gt;  &lt;br&gt;     g.app.scriptsDict['my-script_w'] = w &lt;br&gt;  &lt;br&gt; Note that this reference will persist until the next time you run the execute-script. If you want something even more permanent, you can do something like:: &lt;br&gt;  &lt;br&gt;     g.app.my_script_w = w &lt;br&gt; " id="741" linkTypes="1" links="333" title="Retaining pointers to Qt windows" />
<node body="@language rest &lt;br&gt;  &lt;br&gt; g.IdleTime is a thin wrapper for the Leo's IdleTime class. The IdleTime class executes a handler with a given delay at idle time. The handler takes a single argument, the IdleTime instance:: &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt;      &lt;br&gt;     def handler(it): &lt;br&gt;         &quot;&quot;&quot;IdleTime handler.  it is an IdleTime instance.&quot;&quot;&quot; &lt;br&gt;         delta_t = it.time-it.starting_time &lt;br&gt;         g.trace(it.count,it.c.shortFileName(),'%2.4f' % (delta_t)) &lt;br&gt;         if it.count &gt;= 5: &lt;br&gt;             g.trace('done') &lt;br&gt;             it.stop() &lt;br&gt;  &lt;br&gt;     # Execute handler every 500 msec. at idle time. &lt;br&gt;     it = g.IdleTime(c,handler,delay=500) &lt;br&gt;     if it: it.start() &lt;br&gt;  &lt;br&gt; @language rest &lt;br&gt;  &lt;br&gt; The code creates an instance of the IdleTime class that calls the given handler at idle time, and no more than once every 500 msec.  Here is the output:: &lt;br&gt;  &lt;br&gt;     handler 1 ekr.leo 0.5100 &lt;br&gt;     handler 2 ekr.leo 1.0300 &lt;br&gt;     handler 3 ekr.leo 1.5400 &lt;br&gt;     handler 4 ekr.leo 2.0500 &lt;br&gt;     handler 5 ekr.leo 2.5610 &lt;br&gt;     handler done &lt;br&gt;      &lt;br&gt; Timer instances are completely independent:: &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt;  &lt;br&gt;     def handler1(it): &lt;br&gt;         delta_t = it.time-it.starting_time &lt;br&gt;         g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t)) &lt;br&gt;         if it.count &gt;= 5: &lt;br&gt;             g.trace('done') &lt;br&gt;             it.stop() &lt;br&gt;  &lt;br&gt;     def handler2(it): &lt;br&gt;         delta_t = it.time-it.starting_time &lt;br&gt;         g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t)) &lt;br&gt;         if it.count &gt;= 10: &lt;br&gt;             g.trace('done') &lt;br&gt;             it.stop() &lt;br&gt;  &lt;br&gt;     it1 = g.IdleTime(c,handler1,delay=500) &lt;br&gt;     it2 = g.IdleTime(c,handler2,delay=1000) &lt;br&gt;     if it1 and it2: &lt;br&gt;         it1.start() &lt;br&gt;         it2.start() &lt;br&gt;          &lt;br&gt; @language rest &lt;br&gt;  &lt;br&gt; Here is the output:: &lt;br&gt;  &lt;br&gt;     handler1  1 ekr.leo 0.5200 &lt;br&gt;     handler2  1 ekr.leo 1.0100 &lt;br&gt;     handler1  2 ekr.leo 1.0300 &lt;br&gt;     handler1  3 ekr.leo 1.5400 &lt;br&gt;     handler2  2 ekr.leo 2.0300 &lt;br&gt;     handler1  4 ekr.leo 2.0600 &lt;br&gt;     handler1  5 ekr.leo 2.5600 &lt;br&gt;     handler1 done &lt;br&gt;     handler2  3 ekr.leo 3.0400 &lt;br&gt;     handler2  4 ekr.leo 4.0600 &lt;br&gt;     handler2  5 ekr.leo 5.0700 &lt;br&gt;     handler2  6 ekr.leo 6.0800 &lt;br&gt;     handler2  7 ekr.leo 7.1000 &lt;br&gt;     handler2  8 ekr.leo 8.1100 &lt;br&gt;     handler2  9 ekr.leo 9.1300 &lt;br&gt;     handler2 10 ekr.leo 10.1400 &lt;br&gt;     handler2 done &lt;br&gt; " id="742" linkTypes="1" links="333" title="Running code at idle time" />
<node body="On startup, Leo looks for two arguments of the form:: &lt;br&gt;  &lt;br&gt;     --script scriptFile &lt;br&gt;  &lt;br&gt; If found, Leo enters batch mode. In batch mode Leo does not show any windows. Leo assumes the scriptFile contains a Python script and executes the contents of that file using Leo's Execute Script command. By default, Leo sends all output to the console window. Scripts in the scriptFile may disable or enable this output by calling app.log.disable or app.log.enable &lt;br&gt;  &lt;br&gt; Scripts in the scriptFile may execute any of Leo's commands except the Edit Body and Edit Headline commands. Those commands require interaction with the user. For example, the following batch script reads a Leo file and prints all the headlines in that file:: &lt;br&gt;  &lt;br&gt;     path = g.os_path_finalize_join(g.app.loadDir,'..','test','test.leo') &lt;br&gt;     assert g.os_path_exists(path),path &lt;br&gt;  &lt;br&gt;     g.app.log.disable() # disable reading messages while opening the file &lt;br&gt;     c2 = g.openWithFileName(path) &lt;br&gt;     g.app.log.enable() # re-enable the log. &lt;br&gt;  &lt;br&gt;     for p in c2.all_positions(): &lt;br&gt;         g.es(g.toEncodedString(p.h,&quot;utf-8&quot;)) &lt;br&gt; " id="743" linkTypes="1" links="333" title="Running Leo in batch mode" />
<node body="Scripts can easily determine what directives are in effect at a particular position in an outline. c.scanAllDirectives(p) returns a Python dictionary whose keys are directive names and whose values are the value in effect at position p. For example:: &lt;br&gt;  &lt;br&gt;     d = c.scanAllDirectives(p) g.es(g.dictToString(d)) &lt;br&gt;  &lt;br&gt; In particular, d.get('path') returns the full, absolute path created by all @path directives that are in ancestors of node p. If p is any kind of @file node (including @file, @auto, @clean, etc.), the following script will print the full path to the created file:: &lt;br&gt;  &lt;br&gt;     path = d.get('path') &lt;br&gt;     name = p.anyAtFileNodeName() &lt;br&gt;     if name: &lt;br&gt;        name = g.os_path_finalize_join(path,name) &lt;br&gt;        g.es(name) &lt;br&gt; " id="744" linkTypes="1" links="333" title="Working with directives and paths" />
<node body="g.es can send it's output to tabs other than the log tab:: &lt;br&gt;  &lt;br&gt;     c.frame.log.selectTab('Test') &lt;br&gt;         # Create Test or make it visible. &lt;br&gt;  &lt;br&gt;     g.es('Test',color='blue',tabName='Test') &lt;br&gt;         # Write to the test tab. &lt;br&gt;  &lt;br&gt; Plugins and scripts may call the c.frame.canvas.createCanvas method to create a log tab containing a graphics widget. Here is an example script:: &lt;br&gt;  &lt;br&gt;     log = c.frame.log ; tag = 'my-canvas' &lt;br&gt;     w = log.canvasDict.get(tag) &lt;br&gt;     if not w: &lt;br&gt;         w = log.createCanvas(tag) &lt;br&gt;         w.configure(bg='yellow') &lt;br&gt;     log.selectTab(tag) &lt;br&gt; " id="745" linkTypes="1" links="333" title="Writing g.es output to other tabs" />
<node body="You can learn *anything* about Leo, provided that you can cause Leo to execute the relevant code. That's usually very easy! &lt;br&gt;  &lt;br&gt; - It should be straightforward to isolate the module or modules involved. &lt;br&gt; - The next several sections give hints about finding interesting code. &lt;br&gt; - Once you find a bit of interesting code, use g.pdb or g.trace to study it. &lt;br&gt;  &lt;br&gt; The following sections provide more details... &lt;br&gt; " id="746" linkTypes="3 3 3 3 3" links="1198 1199 1200 1201 1202" title="How to explore Leo's sources" />
<node body="Leo uses a model/view/controller architecture. &lt;br&gt;  &lt;br&gt; - Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py. &lt;br&gt;  &lt;br&gt; - Model (data): The VNode and Position classes in leoNodes.py. &lt;br&gt;  &lt;br&gt; - View: The gui-independent base classes are in the node &quot;Gui Base Classes&quot;. The Qt-Specific subclasses are in the node &quot;Qt gui&quot;. &lt;br&gt;  &lt;br&gt; .. _`David Parnas`:   http://en.wikipedia.org/wiki/David_Parnas &lt;br&gt; .. _`Glenford Myers`: http://en.wikipedia.org/wiki/Glenford_Myers &lt;br&gt;  &lt;br&gt; In Leo, each class hides (encapsulates) the details of its internal workings from user (client) classes. This design principle has been spectacularly successful. Leo's overall design has remained remarkably stable for 20 years, even as the internal details of many classes have radically changed. Two computer scientists influenced my thinking greatly: `David Parnas`_ and `Glenford Myers`_. &lt;br&gt;  &lt;br&gt; The distinction between gui-dependent and gui-independent is important. Almost all gui-dependent code resides in the plugins folder. Leo's core code is almost completely gui independent. &lt;br&gt;  &lt;br&gt; Leo's core typically assumes that w (an abstract widget) is a subclass of the baseTextWidget class. This class implements the DummyHighLevelInterface interface. Actually, w is usually a LeoQTextBrowser or leoQtBaseTextWidget object, defined in qtGui.py. These classes provide thin wrappers for corresponding Qt widgets. &lt;br&gt;  &lt;br&gt; Wrapper classes are useful, regardless of gui independence: &lt;br&gt;  &lt;br&gt; - Wrapper classes often simplify the corresponding code in Leo's code. &lt;br&gt; - Wrapper classes provide convenient methods for debugging and tracing. &lt;br&gt; " id="747" linkTypes="1" links="334" title="The design of Leo's classes" />
<node body="The following methods are surprisingly fragile. Change them only after careful thought. Make *sure* to run all unit tests after changing them in any way: &lt;br&gt;  &lt;br&gt; - leoTree.select and c.selectPosition switch nodes. &lt;br&gt;  &lt;br&gt; - c.endEditing ends editing in a headline and updates undo data. &lt;br&gt;  &lt;br&gt; - leoBody.onBodyChanged updates undo data when body text changes. &lt;br&gt;  &lt;br&gt; - baseNativeTree.onHeadChanged (baseNativeTree.py) updates undo data. &lt;br&gt;  &lt;br&gt;   **Note**: This method overrides leoTree.onHeadChanged (leoFrame.py), &lt;br&gt;   which is not used. &lt;br&gt;  &lt;br&gt; In addition, *all* event handling in baseNativeTree.py is extremely fragile. Don't even think about changing this code unless you know exactly what you are doing. &lt;br&gt; " id="748" linkTypes="1" links="334" title="Fragile methods" />
<node body="Several modules contain long comments:: &lt;br&gt;  &lt;br&gt;     &lt;&lt; about new sentinels &gt;&gt; (leoAtFile.py) &lt;br&gt;     &lt;&lt; about the leoBridge module &gt;&gt; (leoBridge.py) &lt;br&gt;     &lt;&lt; how to write a new importer &gt;&gt; (leoImport.py) &lt;br&gt;     &lt;&lt; How Leo implements unlimited undo &gt;&gt; (leoUndo.py) &lt;br&gt;     &lt;&lt; about gui classes and gui plugins &gt;&gt; &lt;br&gt;     &lt;&lt; About handling events &gt;&gt; (leoFrame.py) &lt;br&gt;     &lt;&lt; Theory of operation of find/change &gt;&gt; (leoFind.py) &lt;br&gt;     &lt;&lt; Key bindings, an overview &gt;&gt; (leoKeys.py) &lt;br&gt;     &lt;&lt; about 'internal' bindings &gt;&gt; (leoKeys.py) &lt;br&gt;     &lt;&lt; about key dicts &gt;&gt; (leoKeys.py) &lt;br&gt;      &lt;br&gt; These comments may be helpful, but do *not* assume that they are accurate. When in doubt, trust the code, not the comments. &lt;br&gt; " id="749" linkTypes="1" links="334" title="Read long comments with caution" />
<node body="The LoadManager (LM) class (in leoApp.py) is responsible for initing all objects and settings. This is a complex process. Here is the big picture: &lt;br&gt;  &lt;br&gt; - The LM reads each local (non-settings) file twice. The first load discovers the settings to be used in the second load. This ensures that proper settings are *available* during the second load. &lt;br&gt;  &lt;br&gt; - Ctors init settings &quot;early&quot;, before calling the ctors for subsidiary objects. This ensures that proper settings are *in effect* for subsidiary ctors. &lt;br&gt; " id="750" linkTypes="1" links="334" title="Startup" />
<node body="Leo's grand strategy for handling text is as follows: &lt;br&gt;  &lt;br&gt; 1. Internally, Leo uses unicode objects for all text. &lt;br&gt;  &lt;br&gt; 2. When reading files or user input, Leo converts all plain (encoded) &lt;br&gt;    strings to unicode. &lt;br&gt;  &lt;br&gt; 3. When reading or writing files, Leo converts unicode strings to encoded &lt;br&gt;    strings. &lt;br&gt;     &lt;br&gt; To make this strategy work, Leo must know the encoding used for external files. This is why Leo supports the @encoding directive and various encoding-related settings. &lt;br&gt;  &lt;br&gt; The g.toUnicode and g.toEncodedString functions convert to and from unicode. These methods catch all unicode-related exceptions. &lt;br&gt;  &lt;br&gt; The g.u function should be used *only* to convert from the Qt string type (a wrapper for a unicode string) to unicode. Do not use g.u instead of g.toUnicode. &lt;br&gt; " id="751" linkTypes="1" links="334" title="Unicode" />
<node body="Leo's key handling is complex because it does inherently complex things: &lt;br&gt;  &lt;br&gt; - Code in various places translate user key bindings to dictionaries. &lt;br&gt;  &lt;br&gt; - eventFilter and its helpers translates incoming QKeyEvents to LeoKeyEvents. &lt;br&gt;  &lt;br&gt; - k.masterKeyHandler associates incoming LeoKeyEvents with &lt;br&gt;   mode-and-pane-dependent bindings. &lt;br&gt;    &lt;br&gt; Much of this complexity is a direct result in the flexibility given to users in specifying key bindings. &lt;br&gt; " id="752" linkTypes="1" links="334" title="Why key handling is complex" />
<node body="Sentinels are necessary for clones, but sentinels would still be necessary if clones did not exist. &lt;br&gt;  &lt;br&gt; Sentinels create **identity**, the notion that a particular nodes starts at *this* place in the external file and extends to *this other* place. Identity is a persistent, invariant attribute of a file: Leo recreates all the nodes of the external files when re-reading the file. &lt;br&gt;  &lt;br&gt; It's really that simple, but here are some consequences: &lt;br&gt;  &lt;br&gt; 1. Identity remains even when the contents of a node changes. Thus, there is *no way* to use content-related mechanisms to recreate identity. Git can never help recover identity. &lt;br&gt;  &lt;br&gt; 2. Leo's sentinels mark an *arbitrary* range of text within the external file. @auto files can never be as flexible as @file nodes. &lt;br&gt; " id="753" linkTypes="1" links="334" title="Leo must have sentinels, even without clones" />
<node body="Leo's handling of focus is complicated in order to reduce unwanted screen flash. The following methods queue *requests* for focus:: &lt;br&gt;  &lt;br&gt;     c.bodyWantsFocus() &lt;br&gt;     c.logWantsFocus() &lt;br&gt;     c.minibufferWantsFocus() &lt;br&gt;     c.treeWantsFocus() &lt;br&gt;     c.widgetWantsFocus(w) &lt;br&gt;      &lt;br&gt; Similarly, c.redraw and c.recolor queue requests to redraw the outline pane and to recolorize the body pane. &lt;br&gt;      &lt;br&gt; c.outerUpdate honors all requests after the present command completes, that is, just before idle time. &lt;br&gt;  &lt;br&gt; Sometimes a command requires that an action happen immediately.  The following methods queue a request and then immediately call c.outerUpdate:: &lt;br&gt;  &lt;br&gt;     c.bodyWantsFocusNow() &lt;br&gt;     c.logWantsFocusNow() &lt;br&gt;     c.minibufferWantsFocusNow() &lt;br&gt;     c.recolor_now() &lt;br&gt;     c.redraw_now() &lt;br&gt;     c.treeWantsFocusNow() &lt;br&gt;     c.widgetWantsFocusNow(w) &lt;br&gt; " id="754" linkTypes="1" links="334" title="Setting focus" />
<node body="Leo's vim mode dispatches keystrokes sent to it from k.masterKeyHandler to **key handlers**. &lt;br&gt;  &lt;br&gt; Each key handler handles the incoming key and then calls either vc.accept(), vc.done(), vc.ignore() or vc.quit(). These methods tell k.masterKeyHandler whether vim-mode has completely handled the key. If so, k.masterKeyHandler simply returns. Otherwise, k.masterKeyHandler handles the key as usual. &lt;br&gt; " id="755" linkTypes="1" links="335" title="The big picture" />
<node body="@language rest &lt;br&gt;  &lt;br&gt; The handler for the G command moves or extends the cursor depending on vc.state. &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     def vim_G(vc): &lt;br&gt;         '''Put the cursor on the last character of the body pane.''' &lt;br&gt;         if vc.is_text_widget(vc.w): &lt;br&gt;             if vc.state == 'visual': &lt;br&gt;                 vc.do('end-of-buffer-extend-selection') &lt;br&gt;             else: &lt;br&gt;                 vc.do('end-of-buffer') &lt;br&gt;             vc.done() &lt;br&gt;         else: &lt;br&gt;             vc.quit() &lt;br&gt;              &lt;br&gt; @language rest &lt;br&gt;  &lt;br&gt; On entry, the dispatcher has set vc.w to the widget with focus. First, the code ensures that this widget is a text widget. If so, the code uses the vc.do method, a thin wrapper for c.k.simulateCommand, to execute Leo commands by name. &lt;br&gt; " id="756" linkTypes="1" links="335" title="A simple key handler" />
<node body="The vc.vim_d method and its follow-on methods handle vim's d commands. &lt;br&gt;  &lt;br&gt; The vc.vis_d method handles the d keystroke that ends visual mode. &lt;br&gt;  &lt;br&gt; The following sections examine each piece of the code in detail. If you understand how it works you should know everything you need to write any other key handler. &lt;br&gt; " id="757" linkTypes="3 3 3 3" links="1203 1204 1205 1206" title="A more complex key handler" />
<node body="The VimCommands class in leoVim.py implements Leo's vim mode. Vim mode is active only if @bool vim-mode = True. &lt;br&gt;  &lt;br&gt; The following sections will be of interest only to those seeking a deep knowledge of how vim mode's dispatchers work. Such knowledge should rarely be required because dispatchers and key handlers are completely unaware of each other. Dispatch dicts and acceptance methods shield dispatchers and key handlers of all knowledge of each other. In particular, acceptance methods handle the sometimes tricky details of ending a key handler. &lt;br&gt;  &lt;br&gt; Leo's vim code is spectacularly different from the real vim's code. Wherever possible, Leo uses methods to hide implementation details. &lt;br&gt;  &lt;br&gt; Ironically, now that everything is hard coded in tables, it would be easy for plugins to customize the workings of vim-mode. &lt;br&gt; " id="758" linkTypes="3 3 3 3 3 3 3" links="1207 1208 1209 1210 1211 1212 1213" title="Code level details" />
<node body="When focus is in the outline pane:: &lt;br&gt;  &lt;br&gt;     Right-arrow (expand-and-go-right) &lt;br&gt;     Left-arrow (contract-or-go-left) &lt;br&gt;     Up-arrow (goto-prev-visible)  &lt;br&gt;     Down-arrow (goto-next-visible) &lt;br&gt;      &lt;br&gt; Regardless of focus:: &lt;br&gt;  &lt;br&gt;     Alt-Home (goto-first-visible-node)  &lt;br&gt;     Alt-End (goto-last-visible-node) &lt;br&gt;     Alt-Right-arrow (expand-and-go-right) &lt;br&gt;     Alt-Left-arrow (contract-or-go-left) &lt;br&gt;     Alt-Up-arrow (goto-prev-visible)  &lt;br&gt;     Alt-Down-arrow (goto-next-visible) &lt;br&gt; " id="759" linkTypes="1" links="337" title="Selecting outline nodes" />
<node body="When focus is in the outline:: &lt;br&gt;  &lt;br&gt;     Shift-Down-arrow (move-outline-down)  &lt;br&gt;     Shift-Left-arrow (move-outline-left)  &lt;br&gt;     Shift-Right-arrow (move-outline-right)  &lt;br&gt;     Shift-Up-arrow (move-outline-up) &lt;br&gt;  &lt;br&gt; Regardless of focus:: &lt;br&gt;  &lt;br&gt;     Alt-Shift-Down-arrow (move-outline-down)  &lt;br&gt;     Alt-Shift-Left-arrow (move-outline-left)  &lt;br&gt;     Alt-Shift-Right-arrow (move-outline-right)  &lt;br&gt;     Alt-Shift-Up-arrow (move-outline-up) &lt;br&gt;     Ctrl-D (move-outline-down) &lt;br&gt;     Ctrl-L (move-outline-left)  &lt;br&gt;     Ctrl-R (move-outline-right) &lt;br&gt;     Ctrl-U (move-outline-up) &lt;br&gt; " id="760" linkTypes="1" links="337" title="Moving outline nodes" />
<node body="When focus is in any of Leo's text panes (body pane, log pane, headlines): &lt;br&gt;  &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;     | **Key**           | **Move Cursor**       | &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;     | Arrow keys        | one character         | &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;     | Ctrl-LeftArrow    | back one word         | &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;     | Ctrl-RightArrow   | forward one word      | &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;     | Home              | beginning of line     | &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;     | End               | end of line           | &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;     | Ctrl-Home         | beginning of the body | &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;     | Ctrl-End          | end of body           | &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;     | PageDown          | down one page         | &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;     | PageUp            | up one page           | &lt;br&gt;     +-------------------+-----------------------+ &lt;br&gt;      &lt;br&gt; Adding the Shift key modifier to any of the keys above moves the cursor and extends the selected text. &lt;br&gt; " id="761" linkTypes="1" links="337" title="Moving the cursor" />
<node body="execute-script predefines:: &lt;br&gt;  &lt;br&gt;     c: The commander of the present outline. &lt;br&gt;     g: The leo.core.leoGlobals module. &lt;br&gt;     p: The presently selected position, c.p. &lt;br&gt;      &lt;br&gt; @test scripts predefine all the above, plus:: &lt;br&gt;  &lt;br&gt;     self: The instance of unittest.TestCase &lt;br&gt; " id="762" linkTypes="1" links="346" title="Pre-defined symbols" />
<node body=":: &lt;br&gt;  &lt;br&gt;     c.all_positions() &lt;br&gt;     c.all_unique_positions() &lt;br&gt;     p.children() &lt;br&gt;     p.parents() &lt;br&gt;     p.self_and_parents() &lt;br&gt;     p.self_and_siblings() &lt;br&gt;     p.following_siblings() &lt;br&gt;     p.subtree() &lt;br&gt;     p.self_and_subtree() &lt;br&gt; " id="763" linkTypes="1" links="346" title="Generators" />
<node body=":: &lt;br&gt;  &lt;br&gt;     c.frame         c's outer frame, a leoFrame instance. &lt;br&gt;     c.user_dict     a temporary dict for use of scripts and plugins. &lt;br&gt;     c.redraw() &lt;br&gt;     c.positionExists(p) &lt;br&gt;  &lt;br&gt; Here is a partial list of the **official ivars** of any leoFrame f:: &lt;br&gt;  &lt;br&gt;     f.c                     is the frame’s commander. &lt;br&gt;     f.body                  is a leoBody instance. &lt;br&gt;     f.body.wrapper          is a leoQTextEditWidget instance. &lt;br&gt;     f.body.wrapper.widget   is a LeoQTextBrowser(QTextBrowser) instance. &lt;br&gt;     f.log                   is a leoLog instance. &lt;br&gt;     f.tree                  is a leoQtTree instance. &lt;br&gt;     f.tree.treeWidget       is a LeoQTreeWidget (a QTreeWidget) instance. &lt;br&gt;      &lt;br&gt; Use autocompletion to explore these objects! &lt;br&gt; " id="764" linkTypes="1" links="346" title="Commands class" />
<node body=":: &lt;br&gt;  &lt;br&gt;     v.b: v's body text. &lt;br&gt;     v.h: v's headline text. &lt;br&gt;     v.u: v.unknownAttributes, a persistent Python dictionary. &lt;br&gt;      &lt;br&gt; v.u (uA's or unknownAttributes or userAttributes) allow plugins or scripts &lt;br&gt; to associate persistent data with vnodes. For details see the section about &lt;br&gt; `userAttributes`_ in the `Customizing Leo`_ chapter. &lt;br&gt; " id="765" linkTypes="1" links="346" title="vnode class" />
<node body="**Properties**:: &lt;br&gt;  &lt;br&gt;     p.b: same as p.v.b. &lt;br&gt;     p.h: same as p.v.h. &lt;br&gt;     p.u: same as p.v.u. &lt;br&gt;  &lt;br&gt; **Getters**:: &lt;br&gt;  &lt;br&gt;     p.back() &lt;br&gt;     p.children() &lt;br&gt;     p.firstChild() &lt;br&gt;     p.hasBack() &lt;br&gt;     p.hasChildren() &lt;br&gt;     p.hasNext() &lt;br&gt;     p.hasParent() &lt;br&gt;     p.hasThreadBack() &lt;br&gt;     p.hasThreadNext() &lt;br&gt;     p.isAncestorOf(p2) &lt;br&gt;     p.isAnyAtFileNode() &lt;br&gt;     p.isAt...Node() &lt;br&gt;     p.isCloned() &lt;br&gt;     p.isDirty() &lt;br&gt;     p.isExpanded() &lt;br&gt;     p.isMarked() &lt;br&gt;     p.isRoot() &lt;br&gt;     p.isVisible() &lt;br&gt;     p.lastChild() &lt;br&gt;     p.level() &lt;br&gt;     p.next() &lt;br&gt;     p.nodeAfterTree() &lt;br&gt;     p.nthChild() &lt;br&gt;     p.numberOfChildren() &lt;br&gt;     p.parent() &lt;br&gt;     p.parents() &lt;br&gt;     p.threadBack() &lt;br&gt;     p.threadNext() &lt;br&gt;     p.visBack() &lt;br&gt;     p.visNext() &lt;br&gt;      &lt;br&gt; **Setters**:: &lt;br&gt;  &lt;br&gt;     p.setDirty() &lt;br&gt;     p.setMarked() &lt;br&gt;  &lt;br&gt; **Operations on nodes**:: &lt;br&gt;  &lt;br&gt;     p.clone() &lt;br&gt;     p.contract() &lt;br&gt;     p.doDelete(new_position) &lt;br&gt;     p.expand() &lt;br&gt;     p.insertAfter() &lt;br&gt;     p.insertAsNthChild(n) &lt;br&gt;     p.insertBefore() &lt;br&gt;     p.moveAfter(p2) &lt;br&gt;     p.moveToFirstChildOf(parent,n) &lt;br&gt;     p.moveToLastChildOf(parent,n) &lt;br&gt;     p.moveToNthChildOf(parent,n) &lt;br&gt;     p.moveToRoot(oldRoot=None) &lt;br&gt;         # oldRoot **must** be the old root position if it exists. &lt;br&gt;          &lt;br&gt; **Moving positions** &lt;br&gt;  &lt;br&gt; The following move positions *themselves*: they change the node to which a &lt;br&gt; position refers. They do *not* change outline structure in any way! Use &lt;br&gt; these when generators are not flexible enough:: &lt;br&gt;  &lt;br&gt;     p.moveToBack() &lt;br&gt;     p.moveToFirstChild() &lt;br&gt;     p.moveToLastChild() &lt;br&gt;     p.moveToLastNode() &lt;br&gt;     p.moveToNext() &lt;br&gt;     p.moveToNodeAfterTree(p2) &lt;br&gt;     p.moveToNthChild(n))  &lt;br&gt;     p.moveToParent() &lt;br&gt;     p.moveToThreadBack() &lt;br&gt;     p.moveToThreadNext() &lt;br&gt;     p.moveToVisBack(c) &lt;br&gt;     p.moveToVisNext(c) &lt;br&gt; " id="766" linkTypes="1" links="346" title="position class" />
<node body="For full details, see @file leoGlobals.py in LeoPyRef.leo. &lt;br&gt;  &lt;br&gt; **g vars**:: &lt;br&gt;  &lt;br&gt;     g.app &lt;br&gt;     g.app.gui &lt;br&gt;     g.app.windowlist &lt;br&gt;     g.unitTesting &lt;br&gt;     g.user_dict  # a temporary dict for use of scripts and plugins. &lt;br&gt;      &lt;br&gt; **g decorator**:: &lt;br&gt;  &lt;br&gt;     @g.command(command-name) &lt;br&gt;      &lt;br&gt; **g functions** (the most interesting: there are many more in leoGlobals.py):: &lt;br&gt;      &lt;br&gt;     g.angleBrackets() &lt;br&gt;     g.app.commanders() &lt;br&gt;     g.app.gui.guiName() &lt;br&gt;     g.es(*args,**keys) &lt;br&gt;     g.es_print(*args,**keys) &lt;br&gt;     g.es_exception() &lt;br&gt;     g.getScript(c,p, &lt;br&gt;         useSelectedText=True, &lt;br&gt;         forcePythonSentinels=True, &lt;br&gt;         useSentinels=True) &lt;br&gt;     g.openWithFileName(fileName,old_c=None,gui=None) &lt;br&gt;     g.os_path_... # Wrappers for os.path methods. &lt;br&gt;     g.pdb(message='') &lt;br&gt;     g.toEncodedString(s,encoding='utf-8',reportErrors=False) &lt;br&gt;     g.toUnicode(s, encoding='utf-8',reportErrors=False) &lt;br&gt;     g.trace(*args,**keys) &lt;br&gt;     g.warning(*args,**keys) &lt;br&gt; " id="767" linkTypes="1" links="346" title="leo.core.leoGlobals module" />
<node body="The following sections describe the complexities that were involved in designing Leo's simple-looking mechanisms. They give a pseudo-chronological list of the major Aha's involved in creating Leo2. These Aha's form the real design and theory of operation of Leo.  &lt;br&gt;  &lt;br&gt; I am writing these notes for several reasons. First, the initial design and coding of Leo2, spanning a period of about 8 weeks, was some of the most creative and rewarding work I have ever done. The result is elegant and simple. I'm proud of it. Second, much of the design work is not reflected in the code, because improved design often eliminated code entirely. The final code is so elegant that it obscures the hard work that created it. Third, you must understand this design in order to understand the implementation of @file trees and their external files. Someday someone else may take charge of Leo. That person should know what really makes Leo work. &lt;br&gt; " id="768" linkTypes="1" links="353" title="Overview" />
<node body="In the summer of 2001 I began work on a project that for a long time I had considered impossible. I had long considered that &quot;private&quot; file formats such as .leo files were the only way to represent an outline properly and safely. I'm not sure what changed my mind, but I finally was willing to consider that information embedded in external files might be useful. This meant accepting the possibility that sentinel lines might be corrupted. This was a crucial first step. If we can trust the user not to corrupt sentinel lines than we can embed almost any kind of information into a external file. &lt;br&gt;  &lt;br&gt; There were several motivations for this work. I wanted to eliminate the need for explicit Tangle and Untangle commands. I thought of this as &quot;Untangle on Read/Tangle on Write.&quot; If tangling and untangling could be made automatic it would save the user a lot of work. I also wanted to make external files the primary sources files. .leo files might be made much smaller external files contained the primary source information. This hope turned out to be false. &lt;br&gt;  &lt;br&gt; The result of this design work was something I originally called Leo2. Now, I prefer to talk about @file trees. Initially most design issues were unresolved or unknown. I resolved to attempt a robust error-recovery scheme, not knowing in advance what that might involve. I also wanted to solve what I thought of as the &quot;cross-file clone&quot; problem: clones that point from a .leo outline into a external file. With Leo1 cross-file clones do not exist; everything is in the same .leo file. It was clear that Leo2 would have to change some aspects of clones, but all details were fuzzy. &lt;br&gt; " id="769" linkTypes="1" links="353" title="First steps" />
<node body="The next step was also crucial. I started to use Leo1 as a prototype to design what the new body pane would look like to the user. In retrospect, using Leo1 as a prototype for Leo2 was just as inspired as using MORE as a prototype for Leo1. Both prototypes marked the true beginning of their respective projects. The Leo2 prototype was a mockup in Python of the code for reading and writing derived files. &lt;br&gt;  &lt;br&gt; Writing the prototype got me thinking about improving noweb. With my experience with Leo1, I was able to create a new markup language that took advantage of outline structure. I called the new language &quot;simplified noweb&quot;, though that terminology is obsolete. I created @file nodes to distinguish between the old and new ways of creating external files. In Leo1, the @code directive is simply an abbreviation for a section definition line. Simplified noweb used @c as an abbreviation for @code. More importantly, simplified noweb used @c to separate doc parts from code parts without necessarily specifying a section name. It quickly became apparent that most nodes could be unnamed. All I needed was the @others directive to specify the location for all such unnamed nodes. &lt;br&gt;  &lt;br&gt; From the start, simplified noweb was a joy to use. The @others directive could replace all section definition lines. Furthermore, I could make @doc directive optional if the body pane started in &quot;code mode&quot;. But this meant that plain body text could become a program! This was an amazing discovery. These Aha's got me excited about Leo2. This was important, as it motivated me to do a lot of difficult design work. &lt;br&gt; " id="770" linkTypes="1" links="353" title="A prototype: simplified noweb" />
<node body="In spite of this excitement, I was uneasy. After much &quot;daydreaming&quot; I realized that I was afraid that reading and writing external files would be interrupted by a long series of alerts. I saw that designing the &quot;user interaction&quot; during reading and writing would be very important. The next Aha was that I could replace a long series of alerts with messages to the log window, followed by a single &quot;summary&quot; alert. Much later I saw how to eliminate alerts entirely. &lt;br&gt;  &lt;br&gt; At this time I thought there would be two kinds of &quot;errors&quot; while reading external files. Warnings would alert the user that something non-serious had happened. True errors would alert the user that data might have been lost. Indeed, if Leo2 saves orphan and ignored nodes in a .leo file under an @file node, then read errors could endanger such nodes. Much later I saw that a robust error recovery scheme demands that @file nodes not contain orphan and @ignored nodes. (More on this subject later.) But if orphan and @ignored nodes are moved out of @file trees, there are no read errors that can cause data loss! So the distinction between warnings and errors finally went away. &lt;br&gt; " id="771" linkTypes="1" links="353" title="Avoiding error notifications" />
<node body="I next turned my attention to writing @file nodes. A huge Aha: I realized that sentinel lines must contain both a leading and a trailing newline. The general principle is this: the write code must contain absolutely no &quot;conditional&quot; logic, because otherwise the read code could not figure out whether the condition should be true or false. So external files contain blank lines between sentinel lines. These &quot;extra&quot; newlines are very useful, because the read (untangle) code can now easily determine exactly where every blank, tab and newline of the external file came from. It would be hard to overstate how important this simplifying principle was in practice. &lt;br&gt;  &lt;br&gt; Much later, with urging from a customer, I realized that the write code could safely remove &quot;extra&quot; newlines between sentinels with a caching scheme in the low level atFile::os() routine. This scheme does not alter the body of the write code in any way: in effect, sentinels still contain leading and trailing &quot;logical&quot; newlines. The read code had to be modified to handle &quot;missing&quot; leading newlines, but this can always be done assuming that sentinels still contain logical leading and trailing newlines! &lt;br&gt;  &lt;br&gt; At about this time I designed a clever way of having the write code tell the read code which newlines were inserted in doc parts. (The whole point of doc parts is to have the write code format long comments by splitting long lines.) To quote from my diary: &lt;br&gt;  &lt;br&gt; &quot;We can use the following convention to determine where putDocPart has inserted line breaks: A line in a doc part is followed by an inserted newline if and only if the newline is preceded by whitespace. This is an elegant convention, and is essentially invisible to the user. Tangle outputs words until the line would become too long, and then it inserts a newline. To preserve all whitespace, tangle always includes the whitespace that terminates a word on the same line as the word itself. Therefore, split lines always end in whitespace. To make this convention work, tangle only has to delete the trailing whitespace of all lines that are followed by a 'real' newline.&quot; &lt;br&gt; " id="772" linkTypes="1" links="353" title="The write code" />
<node body="After the write code was working I turned my attention to the read (untangle) code. Leo's Untangle command is the most complex and difficult code I have ever written. Imagine my surprise when I realized that the Leo2 read code is essentially trivial! Indeed, the Leo2 untangle code is like an assembler. The read code scans lines of a external files looking for &quot;opcodes&quot;, that is, sentinel lines, and executes some simple code for each separate opcode. The heart of this code is the scanText routine in atFile.cpp. &lt;br&gt;  &lt;br&gt; The read code was written and debugged in less than two days! It is the most elegant code I have ever written. While perfecting the read code I realized that sentinel lines should show the complete nesting structure found in the outline, even if this information seems redundant. For example, I was tempted to use a single sentinel to represent an @other directive, but finally abandoned this plan in favor of the @+other and @-other sentinels. &lt;br&gt;  &lt;br&gt; This redundancy greatly simplified the read code and made the structure of external files absolutely clear. Moreover, it turned out that we need, in general, all the information created by the present sentinel lines. In short, sentinels are as simple as they can be, and no simpler. &lt;br&gt;  &lt;br&gt; The atFile::createNthChild method is a very important: it ensures that nodes will be correctly inserted into the outline. createNthChild must be bullet-proof if the Read code is to be robust. Note that the write code outputs @node sentinels, that is, section definitions, in the order in which sections are referenced in the outline, not the order in which sections appear in the outline. So createNthChild must insert the n'th node of parent p properly even if p contains fewer than n-1 children! The write code ensures that section references are properly nested: @node sentinels are enclosed in @node sentinels for all their ancestors in the @file tree. createNthChild creates dummy siblings as needed, then replaces the dummy siblings later when their actual definitions, that is, @node sentinels, are encountered. &lt;br&gt;  &lt;br&gt; At this point the fundamental read/write code was complete. I found three minor bugs in the code over the next week or so, but it was clear that the read/write code formed a rock-solid base from which to continue design and implementation. This was an entirely unexpected surprise. &lt;br&gt; " id="773" linkTypes="1" links="353" title="The read code" />
<node body="At this point I could read and write external files &quot;by hand&quot;, using temporary Read and Write commands. The next step was to integrate the reading and writing of external files with the loading and saving of .leo files. From time to time I made minor changes to the drivers for the read/write code to accommodate the Load and Save code, but at no time did I significantly alter the read or write code itself. &lt;br&gt;  &lt;br&gt; The user interaction of the Load and Save commands drove the design and implementation of the load/store code. The most important questions were: &quot;what do we tell the user?&quot;, and &quot;what does the user do with the information?&quot; It turns out that the user can't make any complex decision during error recovery because the user doesn't have nearly enough information to make an informed choice. In turn, this means that certain kinds of error recovery schemes are out of the question... &lt;br&gt; " id="774" linkTypes="1" links="353" title="The load/save code" />
<node body="I now turned my attention to &quot;attributes&quot; of nodes. Most attributes, like user marks, are non-essential. However, clone information is essential; we must never lose clone links. At this time I had a preliminary design for cross-file clones that involved a two part &quot;pointer&quot; consisting of a full path name and an immutable clone index within the external file. Eventually such pointers completely disappeared, but the immutable clone indices remain. &lt;br&gt;  &lt;br&gt; My first thought was that it would be good to store all attributes in @node sentinels in the external file, but experience showed that would be irritating. Indeed, one wants Leo2 to rewrite external files only if something essential has changed. For example, one doesn't want to rewrite the external file just because a different node as been selected. &lt;br&gt;  &lt;br&gt; At this point I had another Aha: we can use the .leo file to store all non-essential attributes. For example, this means that the .leo file, not the external files, will change if we select a new node. In effect, the .leo file mirrors the external file. The only reason to store nodes in the .leo file under an @file node is to carry these attributes, so Leo2 wrote dummy nodes that do not reference body text. Much later I saw that dummy nodes were dangerous and that .leo files should contain all information found in external files. &lt;br&gt; " id="775" linkTypes="1" links="353" title="Attributes, mirroring and dummy nodes" />
<node body="The concept of mirroring created a huge breakthrough with cross-file clones: Here is an excerpt of an email i sent to my brother Speed: &lt;br&gt;  &lt;br&gt; &quot;I realized this morning that since a .leo file contains dummy vnodes for all nodes in a external file, those dummy nodes can carry clone info! I changed one line to make sure that the write code always writes clone info in dummy vnodes and voila! Cross-file clones worked!&quot; &lt;br&gt;  &lt;br&gt; All of Leo1's clone code could be used completely unchanged. Everything &quot;just works&quot;. &lt;br&gt; " id="776" linkTypes="1" links="353" title="Clones" />
<node body="At first I thought we could make sure that the .leo file always correctly mirrors all external file, but disastrous experience showed that is a completely false hope. Indeed, backup .leo files will almost never mirror external file correctly. So it became urgent to find a completely fool-proof error recovery scheme. &lt;br&gt;  &lt;br&gt; I had known for quite a while that error recovery should work &quot;as if&quot; the mirroring nodes were deleted, then recreated afresh. Several failed attempts at an error recovery scheme convinced me that error recovery would actually have to delete all dummy nodes and then do a complete reread. This is what Leo2 does. &lt;br&gt;  &lt;br&gt; But erasing dummy nodes would destroy any orphan and ignored nodes--by definition such nodes appear nowhere in the external file. Therefore, I had to enforce the rule that @file nodes should contain no such nodes. Here is an email I wrote to my brother, Speed Ream discussing what turned out to be the penultimate error recovery scheme: &lt;br&gt;  &lt;br&gt; &quot;The error recovery saga continues. After much pondering and some trial coding I have changed my mind about orphans and @ignored nodes. They simply should never appear as descendants of @file nodes. Fortunately, this simplifies all aspects of Leo2. Leo2 will issue a warning (not an error) if an orphan or @ignored node appears as the descendant of an @file node when a .leo file is being saved. If any warnings occur while writing the external file, Leo2 will write the &quot;offending&quot; @file tree to the .leo file instead of the external file. This has several advantages: &lt;br&gt;  &lt;br&gt; 1. The user gets warned about orphan nodes. These are useful warnings! Orphan nodes arise from missing @others directives or missing section references. &lt;br&gt;  &lt;br&gt; 2. The user doesn't have to change anything immediately in order to save an outline. This is very important. Besides warnings about orphans, Leo2 will also warn about undefined or unreferenced sections. User's shouldn't have to fix these warnings to do a Save! &lt;br&gt;  &lt;br&gt; 3. No errors or alerts will occur during Reading or Writing, so the user's anxiety level goes way down. At worst, some informational message will be sent to the log. The user will never have to make important decisions during Loads or Saves. [At last the dubious distinction between errors and warnings disappears.] &lt;br&gt;  &lt;br&gt; 4. Error recovery can be bullet-proof. Simple code will guarantee that after any read operation the structure of an @file node will match the structure of the external file. Also, sentinels in external files will now account for all children of an @file node. There are no more &quot;missing nodes&quot; that must be filled in using the .leo file. Finally, error recovery will never change the @file tree in any way: no more &quot;recovered nodes&quot; nodes. &lt;br&gt;  &lt;br&gt; 5. The present read code can be used almost unchanged. The only addition is the posting of a warning if the structure of the .leo file does not match the structure of the external file. We need a warning because non-essential attribute of nodes (like user marks) may be altered.&quot; &lt;br&gt;  &lt;br&gt; This ends the original history of Leo2. In fact, it took quite a while before Leo recovered properly from all errors. I finally saw that .leo files should duplicate all information in external files. This allows a .leo file to be used a single backup file and allows maximal error recovery in all situations. It took several months to stamp out several subtle bugs involving clones that caused spurious read errors. Such errors undermine confidence in Leo and can cause disastrous reversions. See my diary entries for January 2002 in leo.py for details. &lt;br&gt; " id="777" linkTypes="1" links="353" title="Error recovery, at last" />
<node body="Leo 4.4.1 final was released August 30, 2006. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Added new colorizer plugin controlled by jEdit language description files &lt;br&gt;     Added the shadow files plugin, a precursor to @shadow &lt;br&gt;     Added support for multiple editors in the body pane &lt;br&gt; " id="778" linkTypes="1" links="362" title="4.4.1: new colorizer, slideshow, multiple editors" />
<node body="Leo 4.4.2.1 final was released October 29, 2006. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     The find command optionally closes nodes: &lt;br&gt;         Added @bool collapse_nodes_during_finds &lt;br&gt;         Added @bool sparse_move_outline_left &lt;br&gt;     Added support for ZODB in Leo's vnode and tnode classes &lt;br&gt;     Added support for opml files &lt;br&gt;     Added leoPymacs module &lt;br&gt;     Leo optionally began reading .leo files using a sax parser &lt;br&gt;     Added the leoOPML, slideshow, leo_to_rtf and leo_to_html plugins &lt;br&gt;     Added leoPymacs module &lt;br&gt;  &lt;br&gt; " id="779" linkTypes="1" links="362" title="4.4.2: autocontract, opml, zodb, sax, myLeoSettings, leoPymacs" />
<node body="Leo 4.4.3 final was released June 26, 2006. The **big reorg** made the vnode and tnode classes completely independent of the rest of Leo. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Added chapters &lt;br&gt;     Added zipped .leo files &lt;br&gt;     Added a leoBridge module &lt;br&gt;     Added spell checking with aspell &lt;br&gt;      &lt;br&gt; Leo 4.4.3.1 was released July 3, 2006:: &lt;br&gt;  &lt;br&gt;     Added better support for unit testing &lt;br&gt; " id="780" linkTypes="1" links="362" title="4.4.3: winpdb, leoBridge, gui reorg, chapters" />
<node body="Leo 4.4.4 Final was released November 2, 2007. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Added @auto &lt;br&gt;     Added @menus trees &lt;br&gt;     Added @buttons trees &lt;br&gt;     Added a threading_colorizer plugin &lt;br&gt;  &lt;br&gt; The **Great Graph Aha**: Leo outlines can represent arbitrary directed graphs. There is no need for a separate 'graph world'. The graphed.py plugin is a direct result of this Aha. &lt;br&gt; " id="781" linkTypes="1" links="362" title="4.4.4: @auto, @menus, threading syntax colorer, the Great Graph Aha" />
<node body="Leo 4.4.5 final was released December 11, 2007:: &lt;br&gt;  &lt;br&gt;     Fixed all known bugs &lt;br&gt;     Leo now recognizes directives in headlines &lt;br&gt; " id="782" linkTypes="1" links="362" title="4.4.5: Directives in headlines" />
<node body="Leo 4.4.6 final was released January 26, 2008." id="783" linkTypes="1" links="362" title="4.4.6: Bug fixes" />
<node body="Leo 4.4.7 final was released February 18, 2008.  This release added ipython plugin, the result of an excellent collaboration between EKR and Ville M. Vainio. &lt;br&gt; " id="784" linkTypes="1" links="362" title="4.4.7: The ipython plugin" />
<node body="Leo 4.4.8 final was released April 6, 2008. &lt;br&gt;  &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     Leo's discussion is now hosted by Google Groups &lt;br&gt;     Arguments to g.es and g.es_print can be translated using gettext &lt;br&gt; " id="785" linkTypes="1" links="362" title="4.4.8: translation" />
<node body="I just want to provide my own thoughts about the importance of @clean. I look at the posts in this group a fair amount because I find the discussion interesting but I had abandoned leo as a day-to-day tool principally because of the sentinels in @file nodes. Even for solo projects, I just found them visually unappealing and beyond that occasionally confusing when I went to edit files with external editors. I would sometimes start a project in leo, particularly if it was based on code I developed in the past using leo, and then would use the old @nosent to save a version of the code without sentinels and then use my external editor of choice and not use leo at all. I missed many of the features of leo but just couldn't get over the sentinel issue. &lt;br&gt;  &lt;br&gt; @clean really seems to solve all the issues that I had. In particular--and somehow this point doesn't seem to me to have been emphasized enough--it seems to fully support organizer nodes. They are one of the great things about leo--it's happy to guess initially at what the structure of your program is but it's completely up to you to determine the structure and the ability to do things like break up long methods, group like methods, group menu actions in GUI code, etc etc is one of the very cool things about leo. My limited but growing experience with @clean's handling of external changes has been mainly with incremental (as opposed to more sweeping) code changes, and the assignment of new lines is reasonable and you can always fix them it quickly if you don't like how external changes have been handled. &lt;br&gt;  &lt;br&gt; There have been some posts about the recovered nodes, comparing the old and new nodes where there were external changes. I think it's genius. As opposed to hoping that leo has correctly incorporated external changes, it's all there in case you want to take a closer look. Without this, I would just not have the confidence that external changes were being applied correctly and while you can always do a git diff, I am not looking to do that every time I change a file externally especially if I am not at the point where I am about to do a commit. &lt;br&gt;  &lt;br&gt; There has been some discussion of @auto v. @clean. Preference is obviously a matter of taste. I will say that for me the fact that node headlines are unaffected by external file changes is a feature not a problem since I place notes in the headlines that I want preserved when I edit files externally. Yes, if the node headlines are the method names then they won't be updated if an external edit changes a method name but this was true of @file as well. &lt;br&gt;  &lt;br&gt; The ability to work on projects with people who don't have leo is obvious; one perhaps slightly less obvious benefit of no sentinels is that I suspect that the likelihood that someone will clone a git repository is reduced when that repository's code is riddled with leo sentinels (unless the potential cloner is a leo loyalist). The one downside to no sentinels--there is no evidence that leo is being used but I think that raises the broader question of marketing leo, which I certainly believe will be aided significantly by being able to take advantage of leo without sentinels in external files. &lt;br&gt; " id="786" linkTypes="1" links="371" title="Steve Zatz: in praise of @clean" />
<node body=".. _`import script`: tutorial-scripting.html#import-scripts &lt;br&gt; .. _git: http://git-scm.com/ &lt;br&gt;  &lt;br&gt; @clean is the long-sought breakthrough that just might allow Leo to &quot;go viral&quot;. For the very first time, Leo can be used in *all* situations without compromise.  There is no longer any need to make excuses for sentinel lines, or argue whether people should accept them.  Sentinels are simply gone. &lt;br&gt;  &lt;br&gt; I have just realized how inconvenient sentinels might be for my *own* work flow.  This was a shocking revelation.  To illustrate, here is an excerpt from the programming tutorial: &lt;br&gt;  &lt;br&gt; When I study other people's code I do the following: &lt;br&gt;  &lt;br&gt; - Create a git repo of the directory to be studied, adding all the source files and doing an initial commit. &lt;br&gt;   &lt;br&gt; - Use an `import script`_ to create the desired @clean nodes. &lt;br&gt;  &lt;br&gt; - Explicitly save all the imported files using Ctrl-Shift-W (write-at-file-nodes). &lt;br&gt;  &lt;br&gt; - Use `git`_ diff to ensure that no important changes have been made while importing the nodes. &lt;br&gt;  &lt;br&gt; - Use git diff to track any changes I make (such as adding tracing or debugging statements) for the purposes of studying the code. Using @clean is an essential part of this work flow. The diffs would be much harder to read if I had imported files into @file trees instead. &lt;br&gt;  &lt;br&gt; In short, I have just now realized how badly sentinels interfered with git diffs. &lt;br&gt; " id="787" linkTypes="1" links="371" title="EKR: Why @clean is so important" />
<node body="In February 2015 I realized that the @shadow algorithm could be used to update @clean (aka @nosent) files. This inspired me to simplify the @shadow update algorithm. The Mulder/Ream algorithm emerged several days later. &lt;br&gt;  &lt;br&gt; Thinking of using Leo as a diff program may have been the line of thought that lead to @clean. It turned my attention to the @shadow algorithm, and that may have been enough to see that the algorithm could get sentinels from the .leo file instead of hidden shadow files. &lt;br&gt;  &lt;br&gt; I'll probably never be able to recreate a clearer picture of how the Aha came to be.  That's the nature of big Aha's: they obliterate previous ways of thought so completely that it's hard to remember the time before the Aha. &lt;br&gt; " id="788" linkTypes="1" links="371" title="Genesis of @clean" />
<node body="For simplicity, this discussion will assume that we are updating an &lt;br&gt; external file, x, created with @clean x. The update algorithm works &lt;br&gt; exactly the same way with @shadow trees. &lt;br&gt;  &lt;br&gt; The algorithm works with *any* kind of text file. The algorithm uses only &lt;br&gt; difflib. It knows nothing about the text or its meaning. No parsing is ever &lt;br&gt; done. &lt;br&gt;  &lt;br&gt; Suppose file x has been changed outside of Leo. When Leo reads x it does &lt;br&gt; the following: &lt;br&gt;  &lt;br&gt; 1. Recreates the *old* version of x *without* sentinels by writing the &lt;br&gt;    @clean x *outline* into a string, as if it were writing the @clean x &lt;br&gt;    outline again. &lt;br&gt;     &lt;br&gt; 2. Recreates all the lines of x *with* sentinels by writing the @clean x &lt;br&gt;    *outline* into a string, as if it was writing an @file node! Let's call &lt;br&gt;    these lines the **old sentinels** lines. &lt;br&gt;     &lt;br&gt; 3. Uses difflib.SequenceMatcher to create a set of diffs between the &lt;br&gt;    old and new versions of x *without* sentinels. &lt;br&gt;     &lt;br&gt;    **Terminology**: the diffs tell how to change file a into file b. The &lt;br&gt;    actual code uses this terminology: **a** is set of lines in the old &lt;br&gt;    version of x, **b** is the set of lines in the new version of x. &lt;br&gt;     &lt;br&gt; 4. Creates a set of lines, the **new sentinels lines** using the old &lt;br&gt;    sentinels lines, the a and b lines and the diffs. &lt;br&gt;     &lt;br&gt;    This is the magic. Bernhard Mulder's genius was conceiving that a &lt;br&gt;    three-way merge of lines could produce the new outline, *with* &lt;br&gt;    sentinels. The code is in x.propagate_changed_lines and its helpers. &lt;br&gt;     &lt;br&gt; 5. Replaces the @clean tree with the new tree created by reading the new &lt;br&gt;    sentinels lines with the @file read logic. &lt;br&gt;  &lt;br&gt; **Important**: The update algorithm never changes sentinels. It never &lt;br&gt; inserts or deletes nodes. The user is responsible for creating nodes to &lt;br&gt; hold new lines, or for deleting nodes that become empty as the result of &lt;br&gt; deleting lines. &lt;br&gt; " id="789" linkTypes="1" links="376" title="What the algorithm does" />
<node body="There are several boundary cases that the update algorithm can not resolve. &lt;br&gt; For example, if a line is inserted between nodes, the algorithm can not &lt;br&gt; determine whether the line should be inserted at the end of one node or the &lt;br&gt; start of the next node. Let us call such lines **ambiguous lines**. &lt;br&gt;  &lt;br&gt; The algorithm *guesses* that ambiguous lines belongs at the end of a node &lt;br&gt; rather than at the start of the next node. This is usually what is &lt;br&gt; wanted--we usually insert lines at the end of a node. &lt;br&gt;  &lt;br&gt; Happily, **guesses don't matter**, for the following reasons: &lt;br&gt;  &lt;br&gt; 1. The external file that results from writing the @clean x tree will be &lt;br&gt;    the same as the updated external file *no matter where* ambiguous lines &lt;br&gt;    are placed. In other words, the update algorithm is **sound**. &lt;br&gt;  &lt;br&gt; 2. Leo reports nodes that were changed when reading any external file. The &lt;br&gt;    user can review changes to @clean and @file trees in the same way. &lt;br&gt;  &lt;br&gt; 3. The user can permanently correct any mistaken guess. Guesses only happen &lt;br&gt;    for *newly inserted or changed* lines. Moving an ambiguous line to the &lt;br&gt;    following node will not change the external file. As a result, the &lt;br&gt;    next time Leo reads the file the line will be placed in the correct node! &lt;br&gt;  &lt;br&gt; This proves that @shadow and @clean are easy and safe to use. The &lt;br&gt; remaining sections of this document discuss code-level details. &lt;br&gt;  &lt;br&gt; " id="790" linkTypes="1" links="376" title="Guesses don't matter" />
<node body="The algorithm depends on three simple, guaranteed, properties of &lt;br&gt; SequenceMatcher.opcodes. See &lt;br&gt; https://docs.python.org/2/library/difflib.html#sequencematcher-examples &lt;br&gt;  &lt;br&gt; **Fact 1**: The opcodes tell how to turn x.a (a list of lines) into x.b &lt;br&gt; (another list of lines). &lt;br&gt;  &lt;br&gt; The code uses the a and b terminology. It's concise and easy to remember. &lt;br&gt;  &lt;br&gt; **Fact 2**: The opcode indices ai, aj, bi, bj *never* change because &lt;br&gt; neither x.a nor x.b changes. &lt;br&gt;  &lt;br&gt; Plain lines of the result can be built up by copying lines from x.b to x.results:: &lt;br&gt;  &lt;br&gt;     'replace'   x.results.extend(x.b[b1:b2]) &lt;br&gt;     'delete'    do nothing  (b1 == b2) &lt;br&gt;     'insert'    x.results.extend(x.b[b1:b2]) &lt;br&gt;     'equal'     x.results.extend(x.b[b1:b2]) &lt;br&gt;  &lt;br&gt; **Fact 3**: The opcodes *cover* both x.a and x.b, in order, without any gaps. &lt;br&gt;  &lt;br&gt; This is an explicit requirement of sm.get_opcode: &lt;br&gt;  &lt;br&gt; - The first tuple has ai==aj==bi==bj==0. &lt;br&gt;  &lt;br&gt; - Remaining tuples have ai == (aj from the preceding tuple) and bi == (bj &lt;br&gt;   from the previous tuple). &lt;br&gt;    &lt;br&gt; Keep in mind this crucial picture: &lt;br&gt;  &lt;br&gt; - The slices x.a[ai:aj] cover the x.a array, in order without gaps. &lt;br&gt; - The slices x.b[bi:bj] cover the x.b array, in order without gaps. &lt;br&gt;  &lt;br&gt; " id="791" linkTypes="1" links="376" title="Background of the code" />
<node body="Mulder's original algorithm was hard to understand or to change. The &lt;br&gt; culprit was the x.mapping array, which mapped indices into arrays of lines &lt;br&gt; *with* sentinels to indices into arrays of lines *without* sentinels. &lt;br&gt;  &lt;br&gt; The new algorithm replaces the x.mapping array with the x.sentinels array. &lt;br&gt; As a result, diff indices never need to be adjusted and handling diff &lt;br&gt; opcodes is easy. &lt;br&gt;  &lt;br&gt; For any index i, x.sentinels[i] is the (possibly empty) list of sentinel &lt;br&gt; lines that precede line a[i]. Computing x.sentinels from old_private_lines &lt;br&gt; is easy. Crucially, x.a and x.sentinels are *parallel arrays*. That is, &lt;br&gt; len(x.a) == len(x.sentinels), so indices into x.a are *also* indices into &lt;br&gt; x.sentinels. &lt;br&gt; " id="792" linkTypes="1" links="376" title="Aha: the x.sentinels array" />
<node body="Given the x.sentinels array, the strategy for creating the results is &lt;br&gt; simple. Given indices ai, aj, bi, bj from an opcode, the algorithm: &lt;br&gt;  &lt;br&gt; - Writes sentinels from x.sentinels[i], for i in range(ai,aj). &lt;br&gt;  &lt;br&gt; - Writes plain lines from b[i], for i in range(bi,bj). &lt;br&gt;  &lt;br&gt; This &quot;just works&quot; because the indices cover both a and b. &lt;br&gt;  &lt;br&gt; - The algorithm writes sentinels exactly once (in order) because each &lt;br&gt;   sentinel appears in x.sentinels[i] for some i in range(len(x.a)). &lt;br&gt;  &lt;br&gt; - The algorithm writes plain lines exactly once (in order) because &lt;br&gt;   each plain line appears in x.b[i] for some i in range(len(x.b)). &lt;br&gt;  &lt;br&gt; This completes an informal proof of the correctness of the algorithm. &lt;br&gt;  &lt;br&gt; The leading and trailing sentinels lines are easy special cases. This &lt;br&gt; code, appearing before the main loop, ensures that leading lines are &lt;br&gt; written first, and only once:: &lt;br&gt;  &lt;br&gt;     x.put_sentinels(0) &lt;br&gt;     x.sentinels[0] = [] &lt;br&gt;  &lt;br&gt; Similarly, this line, at the end of the main loop, writes trailing &lt;br&gt; sentinels:: &lt;br&gt;  &lt;br&gt;     x.results.extend(x.trailing_sentinels) &lt;br&gt; " id="793" linkTypes="1" links="376" title="Strategy &amp; proof of correctness" />
<node body="The algorithm creates an updated set of lines *with* sentinels using the &lt;br&gt; @clean outline and the updated external file. These new lines then replace &lt;br&gt; the original @clean with a new @clean tree. The algorithm uses only &lt;br&gt; difflib. It will work with *any* kind of text file. No knowledge of any &lt;br&gt; language is needed. &lt;br&gt;  &lt;br&gt; The algorithm depends on simple, guaranteed, properties of indices in &lt;br&gt; SequenceMatcher opcodes. &lt;br&gt;  &lt;br&gt; The algorithm steps through x.sentinels and x.b, extending x.results &lt;br&gt; as it goes. &lt;br&gt;  &lt;br&gt; The algorithm gets all needed data directly from opcode indices into &lt;br&gt; x.sentinels and x.b. Using opcode indices requires neither reader &lt;br&gt; classes nor auxiliary indices. &lt;br&gt;  &lt;br&gt; The algorithm is simple enough to be understood at first reading. I'll &lt;br&gt; remember its details for the rest of my life. &lt;br&gt; " id="794" linkTypes="1" links="376" title="Summary" />
<node body="What struck me first as I converted C++ code to Python is how much less blah, blah, blah there is in Python. No braces, no stupid semicolons and most importantly, *no declarations*. No more pointless distinctions between const, char \*, char const \*, char \* and wxString. No more wondering whether a variable should be signed, unsigned, short or long. &lt;br&gt;  &lt;br&gt; Declarations add clutter, declarations are never obviously right and declarations don't prevent memory allocation tragedies. Declarations also hinder prototyping. In C++, if I change the type of something I must change all related declarations; this can be a huge and dangerous task. With Python, I can change the type of an object without changing the code at all! It's no accident that Leo's new log pane was created first in Python. &lt;br&gt;  &lt;br&gt; Functions returning tuples are a &quot;minor&quot; feature with a huge impact on code clarity. No more passing pointers to data, no more defining (and allocating and deallocating) temporary structs to hold multiple values. &lt;br&gt;  &lt;br&gt; .. _`pylint`: http://www.logilab.org/857 &lt;br&gt;  &lt;br&gt; Python can't check declarations because there aren't any. However, there is a really nifty tool called `pylint`_ that does many of the checks typically done by compilers. &lt;br&gt; " id="795" linkTypes="1" links="377" title="Clarity" />
<node body="Python is much more powerful than C++, not because Python has more features, but because Python needs *less* features. Some examples: &lt;br&gt;  &lt;br&gt; - Python does everything that the C++ Standard Template Library (STL) does, without any of the blah, blah, blah needed by STL. No fuss, no muss, no code bloat. &lt;br&gt;  &lt;br&gt; - Python's slicing mechanism is very powerful and applies to any sequence (string, list or tuple). Python's string library does more with far less functions because slices replace many functions typically found in other string libraries. &lt;br&gt;  &lt;br&gt; - Writing dict = {} creates a dictionary (hash table). Hash tables can contain anything, including lists and other hash tables. &lt;br&gt;  &lt;br&gt; - Python's special functions,  __init__, __del__, __repr__, __cmp__, etc. are an elegant way to handle any special need that might arise. &lt;br&gt; " id="796" linkTypes="1" links="377" title="Power" />
<node body="Before using Python I never fully realized how difficult and dangerous memory allocation is in C++. Try doing:: &lt;br&gt;  &lt;br&gt;         aList[i:j] = list(aString) &lt;br&gt;  &lt;br&gt; in C.  You will write about 20 lines of C code. Any error in this code will create a memory allocation crash or leak. &lt;br&gt;  &lt;br&gt; Python is fundamentally safe. C++ is fundamentally unsafe. When I am using Python I am free from worry and anxiety. When I am using C++ I must be constantly &quot;on guard.&quot; A momentary lapse can create a hard-to-find pointer bug. With Python, almost nothing serious can ever go wrong, so I can work late at night, or after a beer. The Python debugger is always available. If an exception occurs, the debugger/interpreter tells me just what went wrong. I don't have to plan a debugging strategy! Finally, Python recovers from exceptions, so Leo can keep right on going even after a crash! &lt;br&gt; " id="797" linkTypes="1" links="377" title="Safety" />
<node body="Python has almost all the speed of C. Other interpretive environments such as icon and Smalltalk have clarity, power and safety similar to Python. What makes Python unique is its seamless way of making C code look like Python code. Python executes at essentially the speed of C code because most Python modules are written in C. The overhead in calling such modules is negligible. Moreover, if code is too slow, one can always create a C module to do the job. &lt;br&gt;  &lt;br&gt; In fact, Python encourages optimization by moving to higher levels of expression. For example, Leo's Open command reads an XML file. If this command is too slow I can use Python's XML parser module. This will speed up Leo while at the same time raising the level of the code. &lt;br&gt; " id="798" linkTypes="1" links="377" title="Speed" />
<node body="Little of Python is completely new. What stands out is the superb engineering judgment evident in Python's design. Python is extremely powerful, yet small, simple and elegant. Python allows me to express my intentions clearly and at the highest possible level. &lt;br&gt;  &lt;br&gt; The only hope of making Leo all it can be is to use the best possible tools. I believe Python will allow me to add, at long last, the new features that Leo should have. &lt;br&gt;  &lt;br&gt; Edward K. Ream, October 25, 2001.  P.S., September, 2005: &lt;br&gt;  &lt;br&gt; Four years of experience have only added to my admiration for Python. Leo could &lt;br&gt; not possibly be what it is today without Python. &lt;br&gt; " id="799" linkTypes="1" links="377" title="Conclusions" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 5.2-final release March 18, 2016 &lt;br&gt;  &lt;br&gt;     Easy install with PyInstaller packaging &lt;br&gt;     c.cloneFindByPredicate &lt;br&gt;     clone-find-marked commands: &lt;br&gt;         cfam (clone-find-all-marked) &lt;br&gt;         cffm (clone-find-all-flattened-marked) &lt;br&gt;     decorators create all Leo commands &lt;br&gt;     find-def and find-var &lt;br&gt;     help-for-keystroke &lt;br&gt;     Optional line numbers in the left gutter &lt;br&gt;     show-invisibles uses Qt characters &lt;br&gt;     --ipyhon command-line option works with latest IPython versions &lt;br&gt;     Themes &lt;br&gt;     Wildcard file names on Leo's command line" id="800" linkTypes="1" links="386" title="Highlights" />
<node body=":: &lt;br&gt;      &lt;br&gt;     cfa, cff, cfam, cfam &lt;br&gt;     clear-log &lt;br&gt;     clone-to-at-spot &lt;br&gt;     Ctrl-x &amp; Ctrl-C cut/copy the entire line if no text is selected &lt;br&gt;     find-all now writes to the body of a new top-level node &lt;br&gt;     find-def and find-var &lt;br&gt;     flatten-outline-to-node &lt;br&gt;     goto-next-clone falls back to find-next-clone &lt;br&gt;     help-for-keystroke &lt;br&gt;     kill commands cut selected text &lt;br&gt;     show-invisibles uses Qt characters &lt;br&gt;     vim-open-file &lt;br&gt;     @beautify and @nobeautify" id="801" linkTypes="1" links="386" title="Commands &amp; directives" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Abbreviations now support auto-close quotes &lt;br&gt;     https://groups.google.com/d/msg/leo-editor/yJLz-p3I4mY/Pqa1phYN_10J &lt;br&gt;     Ctrl-G resets status line &lt;br&gt;     declutter node: substituting icons for @clean, @file, etc. &lt;br&gt;     Find commands now show status &lt;br&gt;     New menu: Settings: Edit Settings &lt;br&gt;     https://groups.google.com/d/msg/leo-editor/pM8aVJ1D6ao/Z8lq43t7FAAJ &lt;br&gt;     New menu: File:Print &lt;br&gt;     Optional line numbers in the left gutter &lt;br&gt;     Themes &lt;br&gt;     Wildcard file names on Leo's command line &lt;br&gt; " id="802" linkTypes="1" links="386" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     leoOPML.py plugin &lt;br&gt;  &lt;br&gt;     mod_http.py plugin can control Leo remotely &lt;br&gt;     (https://groups.google.com/d/msg/leo-editor/wWWUgfDhPi4/VmRRRa_xDAAJ) &lt;br&gt;      &lt;br&gt;     make_stub_files.py script creates stub (.pyi) files &lt;br&gt;     https://github.com/edreamleo/make-stub-files &lt;br&gt;  &lt;br&gt;     python_to_coffescript.py script converts .py files to .coffee files &lt;br&gt;     https://github.com/edreamleo/python-to-coffeescript &lt;br&gt; " id="803" linkTypes="1" links="386" title="Plugins &amp; scripts" />
<node body=":: &lt;br&gt;  &lt;br&gt;     @bool find-ignore-duplicates &lt;br&gt;     @bool preload-find-pattern &lt;br&gt;     @bool syntax-error-popup &lt;br&gt;     @bool use_find_dialog &lt;br&gt;     @bool use_gutter = True &lt;br&gt;     @color find-found-bg = blue &lt;br&gt;     @color find-found-fg = white &lt;br&gt;     @color find-not-found-bg = red &lt;br&gt;     @color find-not-found-fg = white &lt;br&gt;     @color gutter-bg = @LightSteelBlue1 &lt;br&gt;     @color gutter-fg = black &lt;br&gt; 	@data abbreviations-subst-env now allows Leo directives &lt;br&gt;     @data history-list &lt;br&gt; 	@data qt-gui-user-style-sheet &lt;br&gt;     (https://github.com/leo-editor/leo-editor/issues/183) &lt;br&gt; 	@ifenv &lt;br&gt;     @ifplatform &amp; @ifhostname (improved) &lt;br&gt;     @int gutter-w-adjust = 12 &lt;br&gt;     @int gutter-y-adjust = 10 &lt;br&gt;     @language coffeescript &lt;br&gt;     @string gutter-font-family = @font-family &lt;br&gt;     @string gutter-font-size = @small-font-size &lt;br&gt;     @string gutter-font-style = @font-style &lt;br&gt;     @string gutter-font-weight = @font-weight &lt;br&gt; " id="804" linkTypes="1" links="386" title="Settings" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 5.1 b2 released April 10, 2015. &lt;br&gt;     @clean outlines create external files without sentinels. &lt;br&gt;     Leo regularly checks the integrity of the outline. &lt;br&gt;     Up/Down arrows in the minibuffer cycle though command history. &lt;br&gt;     http://leoeditor.com/load-leo.html displays .leo files in the browser. &lt;br&gt;     Leo now honors @language inside @doc parts. &lt;br&gt;     @data nodes can now be composed from a tree of nodes. &lt;br&gt;         This feature appeared in Leo 5.0, but was not documented. &lt;br&gt;     Added @int qt-cursor-width setting. &lt;br&gt;     Added g.IdleTime &amp; LeoQtGui.IdleTime. &lt;br&gt; " id="805" linkTypes="1" links="387" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     @bool make-node-conflicts-node &lt;br&gt;     goto-global-line prefers to find a node *outside* any @&lt;file&gt; tree. &lt;br&gt;     Added unformat-paragraph." id="806" linkTypes="1" links="387" title="Commands &amp; settings" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Added nodes-dark icons &amp; stylesheet. &lt;br&gt;     (https://groups.google.com/d/msg/leo-editor/BrruEaWaX4Y/A0g4HQFvNtAJ) &lt;br&gt;     Added --diff command-line option. &lt;br&gt;     @auto persistence enabled if and only if an @persistence node exists. &lt;br&gt;     @auto style parse on first @clean 'Refresh From Disk' &lt;br&gt;     (https://github.com/leo-editor/leo-editor/issues/148) &lt;br&gt;     Added LeoReleaseNotes.leo. &lt;br&gt;     Improved messages when find commands fail. &lt;br&gt;     Improved &lt;?xml-stylesheet&gt;. &lt;br&gt;     Added g.getLanguageAtPosition. Should have been done long ago." id="807" linkTypes="1" links="387" title="Features" />
<node body="@clean is a long-sought breakthrough. For the first time, Leo can be used in *all* situations without compromise.  There is no longer any need to make excuses for sentinel lines, or argue whether people should accept them.  Sentinels are simply gone. &lt;br&gt; " id="808" linkTypes="1" links="387" title="Why @clean is so important" />
<node body="Leo updates @clean trees using a simplified version of the Mulder update algorithm previously used to update @shadow trees. This algorithm  is easy to understand, provably correct and completely documented. It may be of interest to the developers of other outliners. &lt;br&gt;  &lt;br&gt; http://leoeditor.com/appendices.html#the-mulder-ream-update-algorithm &lt;br&gt; " id="809" linkTypes="1" links="387" title="The Mulder/Ream update algorithm" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 5.0 final released November 24, 2014 &lt;br&gt;  &lt;br&gt;     Better compatibility with vim, Emacs, pylint and PyQt: &lt;br&gt;  &lt;br&gt;         Optional native emulation of vim commands &lt;br&gt;         Full support for Emacs org-mode outlines &lt;br&gt;         Better support for pylint &lt;br&gt;         Support for both PyQt4 and PyQt5 &lt;br&gt;      &lt;br&gt;     Better handling of nodes containing large text: &lt;br&gt;  &lt;br&gt;         Idle time syntax coloring eliminates delay &lt;br&gt;         Optional delayed loading of large text &lt;br&gt;  &lt;br&gt;     Power features: &lt;br&gt;  &lt;br&gt;         File name completion &lt;br&gt;         Cloned nodes expand and contract independently &lt;br&gt;         @data nodes can be composed from descendant nodes &lt;br&gt;         Leo's main style sheet can be customized with @color and @font settings &lt;br&gt;         @persistence nodes save data in @auto trees &lt;br&gt;         Leo now uses pluggable architecture for @auto nodes &lt;br&gt;         &lt;Alt-X&gt;&lt;tab&gt; shows all commands &lt;br&gt;         Leo's beautify commands now uses PythonTidy by default &lt;br&gt;  &lt;br&gt;     New plugins for tagging, display and node evaluation &lt;br&gt;      &lt;br&gt;     Leo's default workbook files contains Leo's quickstart guide &lt;br&gt; " id="810" linkTypes="1" links="388" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Idle-time commands: &lt;br&gt;      &lt;br&gt;         disable-idle-time-events &lt;br&gt;         disable-idle-time-tracing &lt;br&gt;         enable-idle-time-events &lt;br&gt;         enable-idle-time-tracing &lt;br&gt;         toggle-idle-time-events &lt;br&gt;         toggle-idle-time-tracing &lt;br&gt;          &lt;br&gt;     Spell as you type commands: &lt;br&gt;      &lt;br&gt;         spell-as-you-type-toggle &lt;br&gt;         spell-as-you-type-next &lt;br&gt;         spell-as-you-type-undo &lt;br&gt;          &lt;br&gt;     Other commands: &lt;br&gt;  &lt;br&gt;         clone-find-parents &lt;br&gt;         clone-to-last-node &lt;br&gt;         flatten-outline-to-node &lt;br&gt;         focus-to-find &lt;br&gt;         focus-to-spell &lt;br&gt;         help-for-drag-and-drop &lt;br&gt;         insert-file-name &lt;br&gt;         pylint &lt;br&gt;         style-reload" id="811" linkTypes="1" links="388" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     --no-persist and --trace-plugins command-line options &lt;br&gt;     Optional warning buttons when selecting large text &lt;br&gt;     Added support for delegate languages &lt;br&gt;     Added support for the dart language &lt;br&gt;     Added leo/external/leoftsindex.py &lt;br&gt; " id="812" linkTypes="3" links="1214" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Most plugins now work with PyQt5 &lt;br&gt;     Rewrote at_produce.py &lt;br&gt;     Added livecode.py &lt;br&gt;     Added nodetags.py &lt;br&gt;     Added viewrendered2.py &lt;br&gt;     Added wikiview.py &lt;br&gt; " id="813" linkTypes="1" links="388" title="Plugins" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Added settings that control PythonTidy-based beautify command: &lt;br&gt;  &lt;br&gt;         @bool use_python_tidy = True &lt;br&gt;         @bool tidy_add_blank_lines_around_comments = True &lt;br&gt;         @bool tidy_double_quoted_strings = False &lt;br&gt;         @bool tidy_keep_blank_lines = True &lt;br&gt;         @bool tidy_left_adjust_docstrings = False &lt;br&gt;         @int  tidy_lines_before_split_lit = 2 &lt;br&gt;         @int  tidy_seps_before_split_line = 8 &lt;br&gt;          &lt;br&gt;     Other settings: &lt;br&gt;      &lt;br&gt;         Added @bool auto-scroll-find-tab &lt;br&gt;         Added support for html handlebar syntax coloring &lt;br&gt;         Leo's main style sheet is fully parameterized &lt;br&gt;         Leo stylesheets now support all color names in leoColor.py &lt;br&gt; " id="814" linkTypes="1" links="388" title="Settings" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.11 final released November 6, 2013 &lt;br&gt;     Leo's tutorials have been rewritten and simplified &lt;br&gt;     Greatly improved abbreviations, including templates &lt;br&gt;     Clones are now valid anywhere in @file nodes &lt;br&gt;     Leo now warns if a .leo file is open elsewhere &lt;br&gt;     Leo's IPython bridge now works with IPython 1.x &lt;br&gt;     Added support for @testsetup and @testclass &lt;br&gt;     Added support for sessions &lt;br&gt;     Added colorizing themes &lt;br&gt;     A colored border highlights the pane with focus &lt;br&gt;     Added support for the clojure, markdown and TypeScript languages &lt;br&gt;     Added importers for .ipynb, .otl and vimoutliner files &lt;br&gt; " id="815" linkTypes="1" links="389" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     go-anywhere (quicksearch plugin) &lt;br&gt;     help-for-abbreviations &lt;br&gt;     help-for-dynamic-abbreviations &lt;br&gt;     help-for-find-commands &lt;br&gt;     help-for-regular-expressions &lt;br&gt;     insert-node-before &lt;br&gt;     leoscreen-jump-to-error &lt;br&gt;     normalize-whitespace &lt;br&gt;     parse-body &lt;br&gt;     print-buttons &lt;br&gt;     vr-expand &amp; vr-contract. All viewrendered commands now start with vr &lt;br&gt;     zoom-in/out commands &lt;br&gt; " id="816" linkTypes="1" links="389" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     --no-plugins command-line option &lt;br&gt;     @wrap now suppresses horizontal scrolling &lt;br&gt;     Added importers for .otl, .ipnyb, TypeScript and vimoutliner &lt;br&gt;     Added sublime Text 2, a dark colorizing theme &lt;br&gt;     Added support for @testsetup and @testclass &lt;br&gt;     Added syntax coloring for clojure language &lt;br&gt;     Added yes-to-all button when prompting for dangerous writes &lt;br&gt;     Allow periods before section names in headlines &lt;br&gt;     Border color changes depending on input state &lt;br&gt;     Clones are now valid anywhere in @file nodes &lt;br&gt;     Fully supported `:`: convention in @mode nodes &lt;br&gt;     Help commands now use &lt;pre&gt; formatting if docutils is not available &lt;br&gt;     Leo issues a warning if the same .leo file is open in another Leo instance &lt;br&gt;     Show all commands after &lt;alt-x&gt;&lt;tab&gt; &lt;br&gt;     Major additions to abbreviations, including templates &lt;br&gt; " id="817" linkTypes="1" links="389" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     leomylyn.py &lt;br&gt;     markup_inline.py &lt;br&gt;     printing.py &lt;br&gt;     richtext.py &lt;br&gt;     rss.py &lt;br&gt;     screen_capture.py &lt;br&gt;     screencast.py &lt;br&gt;     timestamp.py &lt;br&gt; " id="818" linkTypes="1" links="389" title="Plugins" />
<node body=":: &lt;br&gt;  &lt;br&gt;     By Terry Brown: &lt;br&gt;      &lt;br&gt;         Add @script node &lt;br&gt;         Cross-outline node editing &lt;br&gt;         Export full contents &lt;br&gt;         Full tree view (See the discussion in the child) &lt;br&gt;         Indexing files for full text search &lt;br&gt;         Persistent state with json as a leo abbreviation &lt;br&gt;         Tool for diffing Leo files &lt;br&gt;          &lt;br&gt;     By Edward K. Ream: &lt;br&gt;      &lt;br&gt;         Cleanup imported nodes &lt;br&gt;         Create global data structures from in modes/*.py files &lt;br&gt;         Get all comments from modes (slow) &lt;br&gt;         Import org mode &lt;br&gt;         jinja2 templating &lt;br&gt;         Recursive import script &lt;br&gt;          &lt;br&gt;     By Brian Theado: &lt;br&gt;      &lt;br&gt;         Display function call hierarchy in Leo &lt;br&gt; " id="819" linkTypes="1" links="389" title="Scripts in scripts.leo" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Added @color minibuffer-foreground-color &lt;br&gt;     Added @color log_warning_color &lt;br&gt;     Added @bool enable-tree-dragging" id="820" linkTypes="1" links="389" title="Settings" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.10 final released March 29, 2012 &lt;br&gt;     Detached windows &lt;br&gt;     Major improvements to Leo's abbreviations &lt;br&gt; " id="821" linkTypes="1" links="390" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     beautify-c &lt;br&gt;     c-to-python &lt;br&gt;     clone-find-all-flattened &lt;br&gt;     clone-marked-nodes &lt;br&gt;     delete-marked-nodes &lt;br&gt;     move-marked-nodes &lt;br&gt;     run-marked-unit-tests-externally &lt;br&gt;     run-marked-unit-tests-locally &lt;br&gt;     select-to-matching-bracket &lt;br&gt;     split-defs &lt;br&gt; " id="822" linkTypes="1" links="390" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     EditCommandsManager &lt;br&gt;     KeyStroke &amp; ShortcutInfo &lt;br&gt;     LoadManager &lt;br&gt;     TestManager &lt;br&gt; " id="823" linkTypes="1" links="390" title="Classes" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Tab completion now shows all @command &amp; @button nodes &lt;br&gt;     Leo can highlight the pane containing the focus &lt;br&gt;     The bigdash plugin searches across multiple files &lt;br&gt;     The new quick edit/save mode makes Leo work like SciTe &lt;br&gt; " id="824" linkTypes="1" links="390" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.9 final released June 21, 2011 &lt;br&gt;     The Qt gui completely replaces Tk gui &lt;br&gt;     Nodes may contain multiple @language directives &lt;br&gt;     Unified extract and import commands &lt;br&gt;     Greatly improved the autocompleter &lt;br&gt;     The rendering pane displays movies, html, svg images, etc." id="825" linkTypes="1" links="391" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Commands now have common prefixes: &lt;br&gt;      &lt;br&gt;         abbrev-     abbreviation commands &lt;br&gt;         apropos-    help &lt;br&gt;         buffer-     buffer command &lt;br&gt;         ddabrev-    dynamic abbreviations &lt;br&gt;         directory-  director commands &lt;br&gt;         file-       file commands &lt;br&gt;         find-       find commands &lt;br&gt;         gc-         garbage collection &lt;br&gt;         isearch-    incremental search &lt;br&gt;         macro-      macro expansion &lt;br&gt;         print-      print information &lt;br&gt;         rectangle-  rectangle commands &lt;br&gt;         register    register commands &lt;br&gt;         run-        run unit tests &lt;br&gt;         toggle-     toggle settings &lt;br&gt;         yank-       yank &lt;br&gt;  &lt;br&gt;     The import-file commands replaces all the following commands: &lt;br&gt;  &lt;br&gt;         import-at-file                     &lt;br&gt;         import-cweb-files          &lt;br&gt;         import-derived-file        &lt;br&gt;         import-flattened-outline       &lt;br&gt;         import-noweb-files &lt;br&gt;  &lt;br&gt;     Commands related to uA's: &lt;br&gt;      &lt;br&gt;         clear-all-uas &lt;br&gt;         clear-node-uas &lt;br&gt;         print-all-uas &lt;br&gt;         print-node-uas &lt;br&gt;         set-ua &lt;br&gt;          &lt;br&gt;     Other commands: &lt;br&gt;      &lt;br&gt;         insert-hard-tab &lt;br&gt;         insert-soft-tab &lt;br&gt;         replace-current-character command &lt;br&gt;         save-all &lt;br&gt;         toggle-abbrev-mode &lt;br&gt;         toggle-case-region &lt;br&gt; " id="826" linkTypes="1" links="391" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Added --no-splash, --script and --silent command-line options &lt;br&gt;     Leo highlights URL's everywhere &lt;br&gt;     Ctrl-clicking a URL's opens them in the browser &lt;br&gt;     Leo uses an @file node's extension if there is no @language directive &lt;br&gt;     Plain up/down arrow keys in headline-editing mode select a new node &lt;br&gt;     Added namespace directive to .leo files &lt;br&gt;     Added cython colorizing &lt;br&gt; " id="827" linkTypes="1" links="391" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.8 final released November 26, 2010 &lt;br&gt;     New-style sentinels &lt;br&gt;     Drag and drop &lt;br&gt;     Improved abbreviations &lt;br&gt;     Spell checking based on PyEnchant &lt;br&gt;     Leo creates &quot;Resurrected Nodes&quot; &lt;br&gt; " id="828" linkTypes="1" links="392" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     code-to-rst &lt;br&gt;     cascade-windows &lt;br&gt;     minimize-all-windows &lt;br&gt;     head-to-prev-node &lt;br&gt;     tail-to-next-node &lt;br&gt;     extract-python-method &lt;br&gt; " id="829" linkTypes="1" links="392" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo can open multiple files from the command line &lt;br&gt;     Added an .ini importer &lt;br&gt;     Added support for .nsi files &lt;br&gt;     New screenshots plugin &lt;br&gt; " id="830" linkTypes="1" links="392" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.7 final released February 23, 2010 &lt;br&gt;     The one-node world &lt;br&gt;     Leo now works with Python 3 &amp; requires Python 2.6+ &lt;br&gt;     'Recovered Nodes' nodes guard against clone conflicts &lt;br&gt; " id="831" linkTypes="1" links="393" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     --debug &lt;br&gt;     --version &lt;br&gt; " id="832" linkTypes="1" links="393" title="Command-line options" />
<node body=":: &lt;br&gt;  &lt;br&gt;     clear-all-caches &lt;br&gt;     clear-cache &lt;br&gt; " id="833" linkTypes="1" links="393" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.6 final released July 15, 2009 &lt;br&gt;     Cached external files &lt;br&gt;     Automatic syntax checking of .py files &lt;br&gt;     The Qt gui is now the default &lt;br&gt;     @auto-rst &lt;br&gt;     Added p.b, p.h and p.gnx; v.b, v.h and v.gnx properties &lt;br&gt;     Tab and Shift-Tab indent &amp; unindent text &lt;br&gt; " id="834" linkTypes="1" links="394" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     back-to-home &lt;br&gt;     open-quickstart-leo &lt;br&gt;     pdb &lt;br&gt; " id="835" linkTypes="1" links="394" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     New --config, --file and --gui command-line options &lt;br&gt;     The open command creates @edit nodes when opening non-.leo files &lt;br&gt;     Leo opens a workbook if no file is given &lt;br&gt;     Predefined 'self' in @test/@suite nodes &lt;br&gt;     Escapes for underindented lines &lt;br&gt;     Improved Leo's unit testing framework &lt;br&gt;     New warnings for dangerous writes to @auto and @file nodes &lt;br&gt;     @nocolor-node directive &lt;br&gt;     qtGui and tkGui plugins &lt;br&gt; " id="836" linkTypes="1" links="394" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.5 final released September 2, 2008 &lt;br&gt;     @shadow &lt;br&gt;     Improved Leo's key-binding code &lt;br&gt;     Improved support for vim bindings &lt;br&gt;     Allow v.uA's in @file and @shadow nodes &lt;br&gt;     Sax-based parser for .leo files &lt;br&gt;     Unified nodes &lt;br&gt;     Reorganized Leo's drawing and focus code: &lt;br&gt;     Removed calls to c.beginUpdate and c.endUpdate &lt;br&gt; " id="837" linkTypes="1" links="395" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.4.8 final released April 6, 2008 &lt;br&gt;     Host Leo's sources on bzr &lt;br&gt;     Began using Google groups &lt;br&gt;     Translate arguments to g.es and g.es_print with gettext &lt;br&gt;     Completed ILeo: a bridge between IPython and Leo &lt;br&gt;     Common @commands nodes in settings files &lt;br&gt; " id="838" linkTypes="1" links="396" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.4.7 final released February 18, 2008 &lt;br&gt;     The IPython bridge (ipython plugin) &lt;br&gt; " id="839" linkTypes="1" links="397" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.4.6 final released January 26, 2008 &lt;br&gt;     Added @data nodes &lt;br&gt;     Added @auto importers for javascript and xml files &lt;br&gt;     Added find-next-clone and toggle-sparse-move commands &lt;br&gt; " id="840" linkTypes="1" links="398" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.4.5 final released December 11, 2007 &lt;br&gt;     Leo now recognizes directives in headlines &lt;br&gt; " id="841" linkTypes="1" links="399" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     delete-all-icons &lt;br&gt;     delete-first-icon &lt;br&gt;     delete-last-icon &lt;br&gt;     delete-node-icons &lt;br&gt;     insert-icon &lt;br&gt;     reverse-sort-lines &lt;br&gt;     reverse-sort-lines-ignoring-case &lt;br&gt;     sort-lines-ignoring-case &lt;br&gt;     toggle-collapse_nodes_during_finds &lt;br&gt; " id="842" linkTypes="1" links="399" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Created unitTest.leo &lt;br&gt;     The rst3 plugin now supports @rst-preformat nodes &lt;br&gt; " id="843" linkTypes="1" links="399" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.4.4 Final released November 2, 2007 &lt;br&gt;     The Great Graph Aha.  See the History of Leo &lt;br&gt;     @auto &lt;br&gt;     @menus trees &lt;br&gt;     @buttons trees &lt;br&gt;     A faster colorizer plugin &lt;br&gt; " id="844" linkTypes="1" links="400" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     check-derived-file &lt;br&gt;     check-leo-file &lt;br&gt;     compare-leo-outlines &lt;br&gt;     insert-child &lt;br&gt;     read-at-auto-nodes &lt;br&gt;     read-file-into-node &lt;br&gt;     write-at-auto-nodes &lt;br&gt;     write-dirty-at-auto-nodes &lt;br&gt;     write-file-from-node &lt;br&gt; " id="845" linkTypes="1" links="400" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     @buttons trees &lt;br&gt;     @menus trees &lt;br&gt;     Added 'clear-all-marks' hook &lt;br&gt;     Added graphed.py plugin &lt;br&gt; " id="846" linkTypes="1" links="400" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.4.3 final released June 26, 2006 &lt;br&gt;     The **big reorg** removed all gui-dependent code from Leo's core &lt;br&gt;     Added chapters &lt;br&gt;     Added zipped .leo files &lt;br&gt;     Added leoBridge module &lt;br&gt;     Better support for the winpdb debugger &lt;br&gt;     Added @enabled-plugins and @openwith nodes &lt;br&gt;     Added __wx_gui.py &lt;br&gt; " id="847" linkTypes="1" links="401" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.4.2.1 final released October 29, 2006 &lt;br&gt;     The 'big reorg': vnode and tnode classes are independent of Leo's core &lt;br&gt;     Support for ZODB in the vnode and tnode classes &lt;br&gt;     The find command closes nodes behind it &lt;br&gt; " id="848" linkTypes="1" links="402" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     extend-to-line &lt;br&gt;     extend-to-paragraph &lt;br&gt;     extend-to-sentence &lt;br&gt;     forward-end-word &lt;br&gt;     forward-end-word-extend-selection &lt;br&gt; " id="849" linkTypes="1" links="402" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo can be called from Emacs: See the `Leo and Emacs` chapter &lt;br&gt;     Added support for middle-button paste &lt;br&gt;     Writing .leo files is about twice as fast as before &lt;br&gt;     Integrated sax with read logic &lt;br&gt;     Much faster navigation through the outline using Alt-arrow keys &lt;br&gt;     When focus is in the outline pane, you can move to headlines by &lt;br&gt;     typing the first letter of headlines &lt;br&gt;     The find command now closes nodes &lt;br&gt;     Leo is easier to use without using a mouse &lt;br&gt; " id="850" linkTypes="1" links="402" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Improved mod_scripting.py: &lt;br&gt;      &lt;br&gt;         Creates a command for every button &lt;br&gt;         The Script Button button creates the press-script-button-button command &lt;br&gt;  &lt;br&gt;     New plugins: &lt;br&gt;      &lt;br&gt;         leo_to_html.py &lt;br&gt;         leo_to_rtf.py &lt;br&gt;         paste_as_headlines.py &lt;br&gt;         slideshow.py &lt;br&gt;         word_count.py &lt;br&gt; " id="851" linkTypes="1" links="402" title="Plugins" />
<node body=":: &lt;br&gt;  &lt;br&gt;     @bool collapse_nodes_during_finds &lt;br&gt;     @bool insert_new_nodes_at_end &lt;br&gt;     @bool sparse_move_outline_left &lt;br&gt; " id="852" linkTypes="1" links="402" title="Settings" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo 4.4.1 final released August 30, 2006 &lt;br&gt;     Multiple editors in Leo's body pane &lt;br&gt;     A new colorizer plugin controlled by jEdit language description files &lt;br&gt;     Search commands now support regex replace patterns &lt;br&gt;     Support for external debuggers: http://leoeditor.com/debuggers.html &lt;br&gt; " id="853" linkTypes="1" links="403" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     add-editor &lt;br&gt;     delete-editor &lt;br&gt;     cycle-editor-focus &lt;br&gt;     cycle-focus &lt;br&gt;     debug &lt;br&gt;     find-character &lt;br&gt;     find-word &lt;br&gt;     help-for-command &lt;br&gt;     hide-invisibles  &lt;br&gt;     isearch-with-present-options &lt;br&gt;     open-users-guide &lt;br&gt;     python-help &lt;br&gt;     run-unit-test &lt;br&gt;     scroll-outline-left &lt;br&gt;     scroll-outline-right &lt;br&gt;     toggle-autocompleter &lt;br&gt;     toggle-calltips &lt;br&gt;     toggle-invisibles &lt;br&gt; " id="854" linkTypes="1" links="403" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Leo matching brackets &lt;br&gt;     \1, \2, etc. replacements are valid in regex searches &lt;br&gt;     \n and \t are valid in plain searches &lt;br&gt;     The shortcut for the replace-string command changes &lt;br&gt;     from the find command to the replace command &lt;br&gt; " id="855" linkTypes="1" links="403" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;    Added slideshow.py &lt;br&gt;    mod_scripting.py creates a press-x-button commands &lt;br&gt; " id="856" linkTypes="1" links="403" title="Plugins" />
<node body=":: &lt;br&gt;  &lt;br&gt;     @abbrev settings &lt;br&gt;     @font settings &lt;br&gt;     Commands can be executed on entry to a mode &lt;br&gt;     Bindings that are active only in command, enter and insert key states &lt;br&gt;  &lt;br&gt;     New Settings: &lt;br&gt;      &lt;br&gt;         @bool autoindent_in_nocolor_mode &lt;br&gt;         @bool flash_matching_brackets &lt;br&gt;         @bool idle_redraw &lt;br&gt;         @bool trace_bind_key_exceptions &lt;br&gt;         @bool warn_about_redefined_shortcuts &lt;br&gt;         @color flash_brackets_background_color &lt;br&gt;         @color flash_brackets_foreground_color &lt;br&gt;         @int flash-brackets-delay &lt;br&gt;         @int flash_brackets_count &lt;br&gt;         @string close_flash_brackets &lt;br&gt;         @string open_flash_brackets &lt;br&gt;         @string editor_orientation &lt;br&gt; " id="857" linkTypes="1" links="403" title="Settings" />
<node body=":: &lt;br&gt;  &lt;br&gt;     4.4 final released May 11, 2006 &lt;br&gt;     An Emacs-like mini-buffer &lt;br&gt;     Many new commands &lt;br&gt;     You can use Leo without using a mouse &lt;br&gt;     Flexible key bindings and input modes &lt;br&gt;     A tabbed log pane &lt;br&gt;     Autocompletion and calltips" id="858" linkTypes="1" links="404" title="Highlights" />
<node body=":: &lt;br&gt;  &lt;br&gt;     activate-cmds-menu &lt;br&gt;     activate-edit-menu &lt;br&gt;     activate-file-menu &lt;br&gt;     activate-help-menu &lt;br&gt;     activate-outline-menu &lt;br&gt;     activate-plugins-menu &lt;br&gt;     activate-window-menu &lt;br&gt;     add-space-to-lines &lt;br&gt;     add-tab-to-lines &lt;br&gt;     clean-lines &lt;br&gt;     clear-selected-text &lt;br&gt;     click-click-box &lt;br&gt;     click-headline &lt;br&gt;     click-icon-box &lt;br&gt;     clone-find-all &lt;br&gt;     contract-and-go-right &lt;br&gt;     contract-body-pane &lt;br&gt;     contract-log-pane &lt;br&gt;     contract-outline-pane &lt;br&gt;     contract-pane &lt;br&gt;     double-click-headline &lt;br&gt;     double-click-icon-box &lt;br&gt;     dump-all-objects &lt;br&gt;     dump-new-objects &lt;br&gt;     expand-body-pane &lt;br&gt;     expand-log-pane &lt;br&gt;     expand-outline-pane &lt;br&gt;     expand-pane &lt;br&gt;     find-again &lt;br&gt;     find-all &lt;br&gt;     find-tab-find command &lt;br&gt;     find-tab-find-previous &lt;br&gt;     free-text-widgets &lt;br&gt;     fully-expand-body-pane &lt;br&gt;     fully-expand-log-pane &lt;br&gt;     fully-expand-outline-pane &lt;br&gt;     fully-expand-pane &lt;br&gt;     goto-first-sibling &lt;br&gt;     goto-global-line &lt;br&gt;     goto-last-sibling &lt;br&gt;     help &lt;br&gt;     help-for-command &lt;br&gt;     hide-body-pane &lt;br&gt;     hide-find-tab &lt;br&gt;     hide-log-pane &lt;br&gt;     hide-minibuffer &lt;br&gt;     hide-outline-pane &lt;br&gt;     hide-pane, &lt;br&gt;     open-find-tab &lt;br&gt;     open-find-tab &lt;br&gt;     open-outline-by-name (uses filename completion) &lt;br&gt;     open-spell-tab &lt;br&gt;     print-bindings &lt;br&gt;     print-commands    re-search-backward &lt;br&gt;     re-search-forward &lt;br&gt;     remove-space-from-lines &lt;br&gt;     remove-tab-from-lines &lt;br&gt;     replace-string &lt;br&gt;     run-unit-test &lt;br&gt;     scroll-down &lt;br&gt;     scroll-down-extend-selection &lt;br&gt;     scroll-outline-down-line &lt;br&gt;     scroll-outline-down-page  &lt;br&gt;     scroll-outline-up-line &lt;br&gt;     scroll-outline-up-page &lt;br&gt;     scroll-up &lt;br&gt;     scroll-up-extend-selection &lt;br&gt;     search-backward &lt;br&gt;     search-forward &lt;br&gt;     search-with-present-options &lt;br&gt;     set-find-everywhere &lt;br&gt;     set-find-node-only &lt;br&gt;     set-find-suboutline-only &lt;br&gt;     show-colors &lt;br&gt;     show-fonts &lt;br&gt;     show-minibuffer &lt;br&gt;     show-search-options &lt;br&gt;     simulate-begin-drag &lt;br&gt;     simulate-end-drag &lt;br&gt;     toggle-find-ignore-case-option &lt;br&gt;     toggle-find-in-body-option, &lt;br&gt;     toggle-find-in-headline-option &lt;br&gt;     toggle-find-mark-changes-option &lt;br&gt;     toggle-find-mark-finds-option &lt;br&gt;     toggle-find-regex-option &lt;br&gt;     toggle-find-reverse-option &lt;br&gt;     toggle-find-word-option and &lt;br&gt;     toggle-find-wrap-around-option &lt;br&gt;     toggle-mini-buffer &lt;br&gt;     verbose-dump-objects &lt;br&gt;     word-search-backward &lt;br&gt;     word-search-forward &lt;br&gt; " id="859" linkTypes="1" links="404" title="Commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Added script to update new copies of leoSetttings.leo from previous copies &lt;br&gt;     Made all edit command undoable &lt;br&gt;     Added colorizing support for Lua language &lt;br&gt;     Autocompletion and calltips &lt;br&gt;     Leo remembers the previous open directory &lt;br&gt;     User input modes &lt;br&gt;     Installed many standard bindings to leoSettings.leo &lt;br&gt;     Added support for @mode nodes &lt;br&gt;     Added modes/\*.xml to distribution &lt;br&gt;     Allow multiple key bindings to the same command &lt;br&gt;     Moved all scripts into scripts.leo &lt;br&gt;     Bound &lt;Return&gt; to end-edit-headline &lt;br&gt;     Created scripts.leo and unitTest.leo &lt;br&gt;     The tabbed log &lt;br&gt;     The Find tab replaces the old Find panel" id="860" linkTypes="1" links="404" title="Features" />
<node body=":: &lt;br&gt;  &lt;br&gt;     Changed path to stylesheet in the rst3 plugin &lt;br&gt;     Fixed crasher in Word (and other) plugins &lt;br&gt;     Fixed problem with labels plugin &lt;br&gt;      &lt;br&gt;     Added the following commands for the groupoperations plugin: &lt;br&gt;      &lt;br&gt;         group-operations-clear-marked &lt;br&gt;         group-operations-mark-for-copy &lt;br&gt;         group-operations-mark-for-move &lt;br&gt;         group-operations-mark-for-clone &lt;br&gt;         group-operations-mark-target &lt;br&gt;         group-operations-operate-on-marked &lt;br&gt;         group-operations-transfer &lt;br&gt;      &lt;br&gt;     The scripting plugin now supports shortcuts in @button nodes: &lt;br&gt;      &lt;br&gt;         @button name @key=shortcut &lt;br&gt;      &lt;br&gt;     The scripting plugin now supports @command nodes: &lt;br&gt;      &lt;br&gt;         @command name @key=shortcut &lt;br&gt; " id="861" linkTypes="1" links="404" title="Plugins" />
<node body=":: &lt;br&gt;  &lt;br&gt;     New settings features: &lt;br&gt;      &lt;br&gt;         Per-pane bindings: command-name ! pane = shortcut &lt;br&gt;         Spelling settings replace the settings in spellpyx.ini &lt;br&gt;             @shortcuts nodes &lt;br&gt;          &lt;br&gt;     New settings: &lt;br&gt;  &lt;br&gt;         @bool allow_idle_time_hook &lt;br&gt;         @bool autocomplete-brackets &lt;br&gt;         @bool gc_before_redraw &lt;br&gt;         @bool minibufferSearchesShowFindTab &lt;br&gt;         @bool show_only_find_tab_options &lt;br&gt;         @bool show_tree_stats &lt;br&gt;         @bool trace_autocompleter &lt;br&gt;         @bool trace_bindings &lt;br&gt;         @bool trace_doCommand &lt;br&gt;         @bool trace_f.set_focus &lt;br&gt;         @bool trace_focus &lt;br&gt;         @bool trace_g.app.gui.set_focus &lt;br&gt;         @bool trace_gc &lt;br&gt;         @bool trace_gc_calls &lt;br&gt;         @bool trace_gc_verbose &lt;br&gt;         @bool trace_key_event &lt;br&gt;         @bool trace_masterClickHandler &lt;br&gt;         @bool trace_masterCommand &lt;br&gt;         @bool trace_masterFocusHandler &lt;br&gt;         @bool trace_masterKeyHandler &lt;br&gt;         @bool trace_minibuffer &lt;br&gt;         @bool trace_modes &lt;br&gt;         @bool trace_redraw_now &lt;br&gt;         @bool trace_select &lt;br&gt;         @bool trace_status_line &lt;br&gt;         @bool trace_tree &lt;br&gt;         @bool trace_tree_alloc &lt;br&gt;         @bool trace_tree_edit &lt;br&gt;         @bool useCmdMenu &lt;br&gt;         @bool useMinibuffer &lt;br&gt;         @bool use_syntax_coloring &lt;br&gt;         @color body_text_selection_background_color &lt;br&gt;         @color body_text_selection_foreground_color &lt;br&gt;         @color log_pane_Find_tab_background_color &lt;br&gt;         @color log_pane_Spell_tab_background_color, etc. &lt;br&gt;         @int max_undo_stack_size, &lt;br&gt;         @string trace_bindings_filter &lt;br&gt;         @string trace_bindings_pane_filter &lt;br&gt; " id="862" linkTypes="1" links="404" title="Settings" />
<node body="My to-do list. &lt;br&gt; " id="863" linkTypes="3 3 3 3" links="1215 1216 1217 1218" title="To Do List" />
<node body="" id="864" linkTypes="3 3" links="1219 1220" title="Diary" />
<node body="class MeldController: &lt;br&gt;  &lt;br&gt;     def __init__ (self,c,p,slideshow_dir,wink_dir): &lt;br&gt;  &lt;br&gt;         self.c = c &lt;br&gt;         self.slideshow_dir = slideshow_dir &lt;br&gt;         self.slideshow_node = p &lt;br&gt;         self.wink_dir = wink_dir &lt;br&gt;  &lt;br&gt;     @others &lt;br&gt; " id="865" linkTypes="3 3" links="1221 1222" title="class MeldController" />
<node body="&lt;a class=&quot;FlattrButton&quot; style=&quot;display:none;&quot; rev=&quot;flattr;button:compact;&quot; &lt;br&gt; href=&quot;http://leoeditor.com&quot;&gt;&lt;/a&gt; &lt;br&gt; &lt;noscript&gt; &lt;br&gt; &lt;a href=&quot;http://flattr.com/thing/410073/Leo&quot; target=&quot;_blank&quot;&gt; &lt;br&gt; &lt;img src=&quot;http://api.flattr.com/button/flattr-badge-large.png&quot; &lt;br&gt; alt=&quot;Flattr this&quot; title=&quot;Flattr this&quot; border=&quot;0&quot; /&gt; &lt;br&gt; &lt;/a&gt; &lt;br&gt; &lt;/noscript&gt; &lt;br&gt; " id="866" linkTypes="1" links="431" title="&lt;&lt; flattr icon &gt;&gt;" />
<node body="" id="867" linkTypes="1" links="432" title="Using @button nodes" />
<node body="" id="868" linkTypes="1" links="432" title="Using @test nodes" />
<node body="" id="869" linkTypes="1" links="432" title="Using @url nodes" />
<node body="" id="870" linkTypes="1" links="433" title="Top 10 coolest features" />
<node body="" id="871" linkTypes="1" links="433" title="How to make slide shows" />
<node body="- Execute IPython scripts from Leo. &lt;br&gt; - Execute Leo scripts from IPython. &lt;br&gt; " id="872" linkTypes="1" links="433" title="IPython" />
<node body="" id="873" linkTypes="1" links="433" title="Vim &amp; Emacs" />
<node body="@nocolor-node &lt;br&gt;  &lt;br&gt; Ville's server code to interact with a running Leo &lt;br&gt; http://mail.google.com/mail/#inbox/12adebe2ffe80572 &lt;br&gt;  &lt;br&gt; Reusing Emacs instances with gnuserv &lt;br&gt; http://www.debian-administration.org/articles/257 &lt;br&gt;  &lt;br&gt; " id="874" linkTypes="1" links="433" title="leoremote plugin" />
<node body="http://mail.google.com/mail/#inbox/12adebe2ffe80572 &lt;br&gt; " id="875" linkTypes="1" links="433" title="@url Document Ville's server" />
<node body="" id="876" linkTypes="3 3 3 3 3 3" links="1223 1224 1225 1226 1227 1228" title="@slideshow Leo's NSIS Installer" />
<node body="@pagewidth 50 &lt;br&gt; " id="877" linkTypes="3 3 3 3 3 3 3 3 3 3 3" links="1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239" title="@slideshow Whetting Your Appetite" />
<node body="By Joe Orr. &lt;br&gt; " id="878" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263" title="@slideshow What is Leo" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\installation\_build\html\slide-001.html &lt;br&gt; " id="879" linkTypes="1" links="434" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\installation\_build\html\slide-002.html &lt;br&gt; " id="880" linkTypes="1" links="435" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\installation\_build\html\slide-003.html &lt;br&gt; " id="881" linkTypes="1" links="436" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\installation\_build\html\slide-004.html &lt;br&gt; " id="882" linkTypes="1" links="437" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\installation\_build\html\slide-005.html &lt;br&gt; " id="883" linkTypes="1" links="438" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\installation\_build\html\slide-006.html &lt;br&gt; " id="884" linkTypes="1" links="439" title="@url built slide" />
<node body="" id="885" linkTypes="1" links="441" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-001.html &lt;br&gt; " id="886" linkTypes="1" links="441" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-002.png &lt;br&gt; " id="887" linkTypes="1" links="442" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-002.html &lt;br&gt; " id="888" linkTypes="1" links="442" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-003.png &lt;br&gt; " id="889" linkTypes="1" links="443" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-003.html &lt;br&gt; " id="890" linkTypes="1" links="443" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-004.png &lt;br&gt; " id="891" linkTypes="1" links="444" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-004.html &lt;br&gt; " id="892" linkTypes="1" links="444" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-005.png &lt;br&gt; " id="893" linkTypes="1" links="445" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-005.html &lt;br&gt; " id="894" linkTypes="1" links="445" title="@url built slide" />
<node body="" id="895" linkTypes="1" links="446" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-006.html &lt;br&gt; " id="896" linkTypes="1" links="446" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-007.png &lt;br&gt; " id="897" linkTypes="1" links="447" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-007.html &lt;br&gt; " id="898" linkTypes="1" links="447" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-008.png &lt;br&gt; " id="899" linkTypes="1" links="448" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-008.html &lt;br&gt; " id="900" linkTypes="1" links="448" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-009.png &lt;br&gt; " id="901" linkTypes="1" links="449" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-009.html &lt;br&gt; " id="902" linkTypes="1" links="449" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-010.png &lt;br&gt; " id="903" linkTypes="1" links="450" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-010.html &lt;br&gt; " id="904" linkTypes="1" links="450" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-011.png &lt;br&gt; " id="905" linkTypes="1" links="451" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-011.html &lt;br&gt; " id="906" linkTypes="1" links="451" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-012.png &lt;br&gt; " id="907" linkTypes="1" links="452" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-012.html &lt;br&gt; " id="908" linkTypes="1" links="452" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-013.png &lt;br&gt; " id="909" linkTypes="1" links="453" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-013.html &lt;br&gt; " id="910" linkTypes="1" links="453" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-014.png &lt;br&gt; " id="911" linkTypes="1" links="454" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-014.html &lt;br&gt; " id="912" linkTypes="1" links="454" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-015.png &lt;br&gt; " id="913" linkTypes="1" links="455" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-015.html &lt;br&gt; " id="914" linkTypes="1" links="455" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-016.png &lt;br&gt; " id="915" linkTypes="1" links="456" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-016.html &lt;br&gt; " id="916" linkTypes="1" links="456" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-017.png &lt;br&gt; " id="917" linkTypes="1" links="457" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-017.html &lt;br&gt; " id="918" linkTypes="1" links="457" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-018.png &lt;br&gt; " id="919" linkTypes="1" links="458" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-018.html &lt;br&gt; " id="920" linkTypes="1" links="458" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-019.png &lt;br&gt; " id="921" linkTypes="1" links="459" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-019.html &lt;br&gt; " id="922" linkTypes="1" links="459" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-020.png &lt;br&gt; " id="923" linkTypes="1" links="460" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-020.html &lt;br&gt; " id="924" linkTypes="1" links="460" title="@url built slide" />
<node body="" id="925" linkTypes="1" links="461" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-021.html &lt;br&gt; " id="926" linkTypes="1" links="461" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-022.png &lt;br&gt; " id="927" linkTypes="1" links="462" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-022.html &lt;br&gt; " id="928" linkTypes="1" links="462" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-023.png &lt;br&gt; " id="929" linkTypes="1" links="463" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-023.html &lt;br&gt; " id="930" linkTypes="1" links="463" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/leo-basics-step-by-step/slide-024.png &lt;br&gt; " id="931" linkTypes="1" links="464" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-024.html &lt;br&gt; " id="932" linkTypes="1" links="464" title="@url built slide" />
<node body="" id="933" linkTypes="1" links="465" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\leo-basics-step-by-step\_build\html\slide-025.html &lt;br&gt; " id="934" linkTypes="1" links="465" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-001.html &lt;br&gt; " id="935" linkTypes="1" links="466" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-002.html &lt;br&gt; " id="936" linkTypes="1" links="467" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-003.html &lt;br&gt; " id="937" linkTypes="1" links="468" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-004.html &lt;br&gt; " id="938" linkTypes="1" links="469" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-005.html &lt;br&gt; " id="939" linkTypes="1" links="470" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-006.html &lt;br&gt; " id="940" linkTypes="1" links="471" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-007.html &lt;br&gt; " id="941" linkTypes="1" links="472" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-008.html &lt;br&gt; " id="942" linkTypes="1" links="473" title="@url built slide" />
<node body="" id="943" linkTypes="1" links="474" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-009.html &lt;br&gt; " id="944" linkTypes="1" links="474" title="@url built slide" />
<node body="" id="945" linkTypes="1" links="475" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-010.html &lt;br&gt; " id="946" linkTypes="1" links="475" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\scripting-leo\_build\html\slide-011.html &lt;br&gt; " id="947" linkTypes="1" links="476" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/using-leos-minibuffer/slide-001.png &lt;br&gt; " id="948" linkTypes="1" links="478" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\using-leos-minibuffer\_build\html\slide-001.html &lt;br&gt; " id="949" linkTypes="1" links="478" title="@url built slide" />
<node body="" id="950" linkTypes="1" links="479" title="@no-screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/using-leos-minibuffer/slide-003.png &lt;br&gt; " id="951" linkTypes="1" links="480" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\using-leos-minibuffer\_build\html\slide-003.html &lt;br&gt; " id="952" linkTypes="1" links="480" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/using-leos-minibuffer/slide-004.png &lt;br&gt; " id="953" linkTypes="1" links="481" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\using-leos-minibuffer\_build\html\slide-004.html &lt;br&gt; " id="954" linkTypes="1" links="481" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/using-leos-minibuffer/slide-005.png &lt;br&gt; " id="955" linkTypes="1" links="482" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\using-leos-minibuffer\_build\html\slide-005.html &lt;br&gt; " id="956" linkTypes="1" links="482" title="@url built slide" />
<node body="" id="957" linkTypes="1" links="483" title="@no-screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/using-leos-minibuffer/slide-007.png &lt;br&gt; " id="958" linkTypes="1" links="484" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\using-leos-minibuffer\_build\html\slide-007.html &lt;br&gt; " id="959" linkTypes="1" links="484" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/using-leos-minibuffer/slide-008.png &lt;br&gt; " id="960" linkTypes="1" links="485" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\using-leos-minibuffer\_build\html\slide-008.html &lt;br&gt; " id="961" linkTypes="1" links="485" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/using-leos-minibuffer/slide-009.png &lt;br&gt; " id="962" linkTypes="1" links="486" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\using-leos-minibuffer\_build\html\slide-009.html &lt;br&gt; " id="963" linkTypes="1" links="486" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/using-leos-minibuffer/slide-010.png &lt;br&gt; " id="964" linkTypes="1" links="487" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\using-leos-minibuffer\_build\html\slide-010.html &lt;br&gt; " id="965" linkTypes="1" links="487" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/using-leos-minibuffer/slide-011.png &lt;br&gt; " id="966" linkTypes="1" links="488" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\using-leos-minibuffer\_build\html\slide-011.html &lt;br&gt; " id="967" linkTypes="1" links="488" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/clones-and-views/slide-001.png &lt;br&gt; " id="968" linkTypes="1" links="490" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-001.html &lt;br&gt; " id="969" linkTypes="1" links="490" title="@url built slide" />
<node body="" id="970" linkTypes="1" links="491" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-002.html &lt;br&gt; " id="971" linkTypes="1" links="491" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/clones-and-views/slide-003.png &lt;br&gt; " id="972" linkTypes="1" links="492" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-003.html &lt;br&gt; " id="973" linkTypes="1" links="492" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/clones-and-views/slide-004.png &lt;br&gt; " id="974" linkTypes="1" links="493" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-004.html &lt;br&gt; " id="975" linkTypes="1" links="493" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/clones-and-views/slide-005.png &lt;br&gt; " id="976" linkTypes="1" links="494" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-005.html &lt;br&gt; " id="977" linkTypes="1" links="494" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/clones-and-views/slide-006.png &lt;br&gt; " id="978" linkTypes="1" links="495" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-006.html &lt;br&gt; " id="979" linkTypes="1" links="495" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/clones-and-views/slide-007.png &lt;br&gt; " id="980" linkTypes="1" links="496" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-007.html &lt;br&gt; " id="981" linkTypes="1" links="496" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/clones-and-views/slide-008.png &lt;br&gt; " id="982" linkTypes="1" links="497" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-008.html &lt;br&gt; " id="983" linkTypes="1" links="497" title="@url built slide" />
<node body="" id="984" linkTypes="1" links="498" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-009.html &lt;br&gt; " id="985" linkTypes="1" links="498" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/clones-and-views/slide-010.png &lt;br&gt; " id="986" linkTypes="1" links="499" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-010.html &lt;br&gt; " id="987" linkTypes="1" links="499" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/clones-and-views/slide-011.png &lt;br&gt; " id="988" linkTypes="1" links="500" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-011.html &lt;br&gt; " id="989" linkTypes="1" links="500" title="@url built slide" />
<node body="" id="990" linkTypes="1" links="501" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\clones-and-views\_build\html\slide-012.html &lt;br&gt; " id="991" linkTypes="1" links="501" title="@url built slide" />
<node body="" id="992" linkTypes="1" links="503" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-001.html &lt;br&gt; " id="993" linkTypes="1" links="503" title="@url built slide" />
<node body="" id="994" linkTypes="1" links="504" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-002.html &lt;br&gt; " id="995" linkTypes="1" links="504" title="@url built slide" />
<node body="" id="996" linkTypes="1" links="505" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-003.html &lt;br&gt; " id="997" linkTypes="1" links="505" title="@url built slide" />
<node body="" id="998" linkTypes="1" links="506" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-004.html &lt;br&gt; " id="999" linkTypes="1" links="506" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-005.png &lt;br&gt; " id="1000" linkTypes="1" links="507" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-005.html &lt;br&gt; " id="1001" linkTypes="1" links="507" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-006.png &lt;br&gt; " id="1002" linkTypes="1" links="508" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-006.html &lt;br&gt; " id="1003" linkTypes="1" links="508" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-007.png &lt;br&gt; " id="1004" linkTypes="1" links="509" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-007.html &lt;br&gt; " id="1005" linkTypes="1" links="509" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-008.png &lt;br&gt; " id="1006" linkTypes="1" links="510" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-008.html &lt;br&gt; " id="1007" linkTypes="1" links="510" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-009.png &lt;br&gt; " id="1008" linkTypes="1" links="511" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-009.html &lt;br&gt; " id="1009" linkTypes="1" links="511" title="@url built slide" />
<node body="" id="1010" linkTypes="1" links="512" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-010.html &lt;br&gt; " id="1011" linkTypes="1" links="512" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-012.png &lt;br&gt; " id="1012" linkTypes="1" links="513" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-011.html &lt;br&gt; " id="1013" linkTypes="1" links="513" title="@url built slide" />
<node body="" id="1014" linkTypes="1" links="514" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-012.html &lt;br&gt; " id="1015" linkTypes="1" links="514" title="@url built slide" />
<node body="" id="1016" linkTypes="1" links="515" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-013.html &lt;br&gt; " id="1017" linkTypes="1" links="515" title="@url built slide" />
<node body="" id="1018" linkTypes="1" links="516" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-014.html &lt;br&gt; " id="1019" linkTypes="1" links="516" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-016.png &lt;br&gt; " id="1020" linkTypes="1" links="517" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-015.html &lt;br&gt; " id="1021" linkTypes="1" links="517" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-017.png &lt;br&gt; " id="1022" linkTypes="1" links="518" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-016.html &lt;br&gt; " id="1023" linkTypes="1" links="518" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-018.png &lt;br&gt; " id="1024" linkTypes="1" links="519" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-017.html &lt;br&gt; " id="1025" linkTypes="1" links="519" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-019.png &lt;br&gt; " id="1026" linkTypes="1" links="520" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-018.html &lt;br&gt; " id="1027" linkTypes="1" links="520" title="@url built slide" />
<node body="" id="1028" linkTypes="1" links="521" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-019.html &lt;br&gt; " id="1029" linkTypes="1" links="521" title="@url built slide" />
<node body="" id="1030" linkTypes="1" links="522" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-020.html &lt;br&gt; " id="1031" linkTypes="1" links="522" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-022.png &lt;br&gt; " id="1032" linkTypes="1" links="523" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-021.html &lt;br&gt; " id="1033" linkTypes="1" links="523" title="@url built slide" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/external-files/slide-023.png &lt;br&gt; " id="1034" linkTypes="1" links="524" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\external-files\_build\html\slide-022.html &lt;br&gt; " id="1035" linkTypes="1" links="524" title="@url built slide" />
<node body=".. _`SourceForge download page`: http://sourceforge.net/projects/leo/files/Leo/ &lt;br&gt; .. _`Running Leo`: running.html &lt;br&gt;  &lt;br&gt; Leo has a binary installer for Windows, available at the `SourceForge download page`_. The binary installer installs Leo and sets Windows file associations. Now see `Running Leo`_ for how to run Leo after installing it. &lt;br&gt; " id="1036" linkTypes="1" links="536" title="Using the single-click installer" />
<node body=".. _`Leo's download page`: http://leoeditor.com/download.html &lt;br&gt;  &lt;br&gt; You may download Leo's sources in one of three ways, as described at `Leo's download page`_. If the sources are zipped, unpack them into a temp folder. You may place the sources anywhere you like, including Python's \*site-packages* folder, for example, C:\\Python26\\Lib\\site-packages. &lt;br&gt;  &lt;br&gt; Next, you will find it convenient to create Windows files associations for .leo files, as described in the next section. &lt;br&gt; " id="1037" linkTypes="1" links="536" title="Installing from sources (Windows)" />
<node body="*Important*: Leo's binary Windows installer sets file associations &lt;br&gt; automatically, so this section is needed only if you are installing Leo &lt;br&gt; from a .zip file or other sources. &lt;br&gt;  &lt;br&gt; There are two ways of associating .leo files with Leo. The first uses the &lt;br&gt; Windows control panel, the second, the Windows console. &lt;br&gt;  &lt;br&gt; **Method 1: Using the Windows Control Panel** &lt;br&gt;  &lt;br&gt; The goal is that you want to associate .leo files with the following command:: &lt;br&gt;  &lt;br&gt;     &quot;&lt;path to python&gt;\python.exe&quot; &quot;&lt;path to launchLeo.py&gt;\launchLeo.py&quot; &quot;%1&quot; &lt;br&gt;      &lt;br&gt; Before Windows 7, you do this with using the Folder Options control panel. &lt;br&gt; In Windows 7, you do this with the Default Programs control panel. &lt;br&gt;  &lt;br&gt; *Note*: &quot;%1&quot; passes just the file being clicked on, quoted for spaces etc. &lt;br&gt; The quotation marks are needed to handle file paths containing spaces. &lt;br&gt;  &lt;br&gt; *Warning:* In a batch file, %1 passes just the first command line parameter. &lt;br&gt; It is logical to expect %* to work for file associations just as in batch &lt;br&gt; files. Alas, it does not. &lt;br&gt;  &lt;br&gt; **Method 2: Using the Windows Console** &lt;br&gt;  &lt;br&gt; Open a Windows console with administrator privileges, then type:: &lt;br&gt;  &lt;br&gt;     ftype LeoFile=&quot;&lt;path to python&gt;\pythonw.exe&quot; &quot;&lt;path to launchLeo.py&gt;\launchLeo.py&quot; &quot;%1&quot; %* &lt;br&gt;     assoc .leo=LeoFile &lt;br&gt;  &lt;br&gt; And put this leo.bat in %PATH%:: &lt;br&gt;  &lt;br&gt;     @start /b &quot;Leo&quot; &quot;&lt;path to python&gt;\python.exe&quot; &quot;&lt;path to launchLeo.py&gt;\launchLeo.py&quot; %* &lt;br&gt;      &lt;br&gt; You may omit the /b option if you want to create a separate console window for Leo. &lt;br&gt; " id="1038" linkTypes="1" links="536" title="Creating Windows file associations" />
<node body="Add these files to `/etc/apt/sources.list`:: &lt;br&gt;  &lt;br&gt;     deb http://ppa.launchpad.net/villemvainio/ppa/ubuntu jaunty main &lt;br&gt;     deb-src http://ppa.launchpad.net/villemvainio/ppa/ubuntu jaunty main &lt;br&gt;  &lt;br&gt; Then run:: &lt;br&gt;  &lt;br&gt;     sudo apt-get update &lt;br&gt;     sudo apt-get install leo &lt;br&gt; " id="1039" linkTypes="1" links="537" title="Installing from a debian package" />
<node body="You may download Leo's sources in one of three ways, as described at: &lt;br&gt; http://leoeditor.com/download.html If the sources are zipped, unzip them &lt;br&gt; into a folder in your home directory, say ~/leo-5.3. &lt;br&gt;  &lt;br&gt; You now have several choices. &lt;br&gt;  &lt;br&gt; 1. You can run Leo from your home directory. Just add  ~/leo-5.3 to your path. &lt;br&gt;  &lt;br&gt; 2. You can install leo into /usr/local/lib and /usr/local/bin with: &lt;br&gt;  &lt;br&gt;     cd ~/leo-5.3 &lt;br&gt;     sudo python setup.py install &lt;br&gt;  &lt;br&gt; See `Running Leo`_ for how to run Leo after installing it. &lt;br&gt; " id="1040" linkTypes="1" links="537" title="Installing from sources (Linux)" />
<node body="The primary purpose of this script is to open your app at a fixed, unchanging size. This is surprisingly important: &lt;br&gt;  &lt;br&gt; - It ensures that the window will always render to pixels in the same way. &lt;br&gt; - It makes it easier to splice in new video to an existing video. &lt;br&gt; - It makes it easier to plan your video to ensure everything will appear as you expect. &lt;br&gt; - It provides continuity when making a series of videos. &lt;br&gt;  &lt;br&gt; Here is a script that I use when making Leo's screencasts:: &lt;br&gt;  &lt;br&gt;     python27 launchLeo.py --no-cache --gui=qttabs &lt;br&gt;     --window-size=682x1264 &lt;list of .leo files&gt; %*​ &lt;br&gt;      &lt;br&gt; This *particular* --window-size causes Camtasia to create a window whose actual size is 720x1280, the nominal 720p resolution. It may prevent text blur. Or not. I do know that Leo's screencasts look great at 720p. &lt;br&gt; " id="1041" linkTypes="1" links="600" title="Use a script to open your app" />
<node body="Make sure that you can actually upload *excellent quality* videos before doing anything else. This step is crucial. If you skip this step, all of your initial recording an post-production work could be utterly wasted. &lt;br&gt;  &lt;br&gt; Use *short* (10-second) test videos at this step. Their primary purpose verify that you can can get to the *end* of the production process successfully. You *are* going to make lots of mistakes here: using short videos helps you make these mistakes quickly. &lt;br&gt;  &lt;br&gt; Don't even *think* about making longer videos until the answers to all the following questions are clearly &quot;yes&quot;: &lt;br&gt;  &lt;br&gt; - Is your camera working? &lt;br&gt; - Is your microphone working? &lt;br&gt; - Do you know how to record your voice and screen? &lt;br&gt; - Can you log into YouTube or screencast.com? &lt;br&gt; - Can you upload to YouTube or screencast.com? &lt;br&gt; - Is the sound in your *uploaded* video great? &lt;br&gt; - Do the pixels in your *uploaded* look great? &lt;br&gt;  &lt;br&gt; This last item is particularly important. Just because pixels look good in your video editor is no guarantee that they will look good when uploaded. &lt;br&gt;  &lt;br&gt; You are ready to try your first &quot;real&quot; take *only* when you can upload a video that looks and sounds great. &lt;br&gt; " id="1042" linkTypes="1" links="600" title="Debug your workflow with short videos" />
<node body="Before rushing right out and making your first video, I recommend watching the tutorial screencasts at screencast.com: http://www.techsmith.com/tutorial-camtasia-8.html &lt;br&gt;  &lt;br&gt; Watch the tutorials to see how the presentations themselves are organized. Watch them until it feels natural to emulate their style. &lt;br&gt;  &lt;br&gt; If you will be using Camtasia, you will also want to watch the tutorials to learn how Camtasia works. &lt;br&gt; " id="1043" linkTypes="1" links="600" title="Emulate the screencast.com tutorials" />
<node body="Now it's time to go beyond test videos. Even now, though, I recommend keeping your first efforts short: one minute or so. Again, this saves time. You'll ending up throwing away two or three anyway ;-) &lt;br&gt;  &lt;br&gt; Bring up your app using you demo script and run through your presentation. &lt;br&gt;  &lt;br&gt; Here's the **most important tip**: As you narrate your video, audio flubs are inevitable, but they don't matter at all *provided* that you *realize* that you have just flubbed a word or phrase. &lt;br&gt;  &lt;br&gt; When you flub a line, don't panic! Just *pause*, regroup, and repeat the phrase until you get it right. *Pausing is essential*: it simplifies inserting and deleting sound bites during post production. &lt;br&gt;  &lt;br&gt; You'll relax once you realize that flubs don't matter and that pausing makes post-production easier. Once you relax, getting a good take will suddenly become easier. &lt;br&gt;  &lt;br&gt; Correcting flubs *as soon as they happen* is absolutely essential. Don't even *think* about fixing audio flubs in post-production. It simply can't be done. Instead of spending 20 minutes trying (and failing) to correct a flub in post production, it is much faster and better to take 20 seconds during your take to correct the flub. &lt;br&gt;  &lt;br&gt; Similar remarks apply to video, but in my experience it's much easier to get the video right. If you do flub the video, it will be much easier if you just do a complete retake. With Camtasia, you can separate the audio and video tracks, but usually that won't work, especially if there is audio of key clicks. &lt;br&gt;  &lt;br&gt; By retaking audio flubs as they happen, I find it easy to work without a script. It feels more natural to me than reading a script. YMMV. When I get stuck, I just pause. Or just start over. Otoh, it wouldn't be that hard to read a script. Just *pause* before and after each phrase. Never rush your audio! &lt;br&gt;  &lt;br&gt; In short, the key Aha is: insert (audio) pauses *everywhere* as needed. It's easy to edit them out. It's virtually impossible to edit in the middle of words, even with the world's best audio editor. &lt;br&gt; " id="1044" linkTypes="1" links="600" title="Record your first real take" />
<node body="Post production should be easy provided that you have corrected all audio flubs as they happen. This keeps the audio and video in sync. Just edit out flubs and reduce overly-long pauses. &lt;br&gt;  &lt;br&gt; I won't discuss production details here because they depend on the editor you are using. &lt;br&gt;  &lt;br&gt; Do a new take if you don't have clean audio. Depending on the complexity of your video, it may be possible to splice a partial take in the middle or end of your video. Similarly, it may be possible to splice in a new take to add material you didn't cover in your first take. &lt;br&gt;  &lt;br&gt; One final word of advice. When editing your video, settle for &quot;good enough&quot;. Perfectionism is not your friend. &lt;br&gt; " id="1045" linkTypes="1" links="600" title="Edit your raw take" />
<node body="Making a screencast is a lot easier than you think :-) &lt;br&gt;  &lt;br&gt; - Create a script that will open your app at a fixed, optimal, size. &lt;br&gt;  &lt;br&gt; - Emulate the style and form of screencast.com tutorials. &lt;br&gt;  &lt;br&gt; - Verify the *entire* production process with short test videos. &lt;br&gt;  &lt;br&gt;   Before making longer videos, make *sure* that the test videos look and sound great *when they have been uploaded*. &lt;br&gt;    &lt;br&gt; - When doing a take, flubs don't matter, *provided* you correct them *during the take*.  Use pauses.  Make haste slowly! &lt;br&gt;  &lt;br&gt; - Splice in new takes during post-production to fix flubs and add new material. &lt;br&gt; " id="1046" linkTypes="1" links="600" title="Summary" />
<node body="Here are some more tips I've learned from experience: &lt;br&gt;  &lt;br&gt; 1. Redo audio tests and video tests every time you start a new session. It's amazing how hum can creep into recordings. &lt;br&gt;  &lt;br&gt; 2. The most important step in post production is to get the pacing so it feels right. Beware of editing out pauses. Make sure you give your viewers time to see what you are doing, and to see what you have done. &lt;br&gt;     &lt;br&gt; 3. Don't waste time on callouts or captions until the audio and video work together at a relaxed pace. It's almost as hard to correct pacing mistakes as it is to correct audio flubs. &lt;br&gt; " id="1047" linkTypes="1" links="600" title="Additional tips" />
<node body="1. Enable volume leveling and noise removal in Camtasia. This tip, all by itself, makes a big difference. &lt;br&gt;  &lt;br&gt; 2. Use a better microphone, preferably one with about a 1-inch diaphragm. This is the kind of microphone that Andrew Price uses. The Audio-technica AT2020 USB is relatively inexpensive. &lt;br&gt;    &lt;br&gt; 3. Use &quot;pop filter&quot; with the microphone. This is a cloth or (better) a metal screen that is placed in front of the microphone. It smooths the sound. &lt;br&gt;    &lt;br&gt; 4. Adjust the sound level for maximum volume without distortion: With the microphone about a foot from your mouth, turn the volume as loud as possible, then turn down until no red is visible in the meter. &lt;br&gt; " id="1048" linkTypes="1" links="600" title="Tips for improving audio" />
<node body="Settings files can be found in the following directories: &lt;br&gt;  &lt;br&gt; - **homeDir**, the HOME/.leo directory. HOME is given by Python's HOME environment variable, or by os.expanduser('~') if no HOME environment variable exists. &lt;br&gt;  &lt;br&gt; - **configDir**, Leo's configuration directory: leo/config. &lt;br&gt;  &lt;br&gt; - **machineDir**, the HOME/.leo/MACHINE directory. MACHINE is given by Python's HOSTNAME environment variable, or by Python's COMPUTERNAME environment variable if there is no HOSTNAME variable, or by the value returned by socket.gethostname() if neither environment variable exists. &lt;br&gt;  &lt;br&gt; - **localDir**, the directory containing the .leo file being loaded. &lt;br&gt;  &lt;br&gt; " id="1049" linkTypes="1" links="644" title="Configuration directories" />
<node body="When reading a .leo file, Leo looks for settings in default settings files first, then settings in personal settings files, and finally settings in local settings files.  The exact search order is: &lt;br&gt;  &lt;br&gt; 1. Default settings files: &lt;br&gt;  &lt;br&gt;    a. configDir/leoSettings.leo &lt;br&gt;    b. homeDir/leoSettings.leo &lt;br&gt;    c. localDir/leoSettings.leo &lt;br&gt;  &lt;br&gt; 2. Personal settings files: &lt;br&gt;  &lt;br&gt;    a. configDir/myLeoSettings.leo &lt;br&gt;    b. homeDir/myLeoSettings.leo &lt;br&gt;    c. homeDir/&lt;machine-name&gt;LeoSettings.leo (note capitalization) &lt;br&gt;    d. localDir/myLeoSettings.leo &lt;br&gt;  &lt;br&gt; 3. Local settings files: the file being loaded. &lt;br&gt;  &lt;br&gt; Settings that appear later in this list override settings that appear earlier in this list.  This happens on a setting-by-setting basis, *not* on a file-by-file basis.  In other words, each individual setting overrides only the *corresponding* setting in previously-read files.  Reading a setting file does *not* reset all previous settings. Note that the same file might appear several times in the search list. Leo detects such duplicate file names and only loads each settings file once. Leo remembers all the settings in settings files and does not reread those settings when reading another .leo file. &lt;br&gt;  &lt;br&gt; **Caution**: This search order offers almost too much flexibility. This can be confusing, even for power users. It's important to choose the &quot;simplest configuration scheme that could possibly work&quot;.  Something like: &lt;br&gt;  &lt;br&gt; - Use a single leoSettings.leo file for installation-wide defaults. &lt;br&gt; - Use a single myLeoSettings.leo files for personal defaults. &lt;br&gt; - Use local settings sparingly. &lt;br&gt;  &lt;br&gt; **Important**: it is good style to limit settings placed in myLeoSettings.leo to those settings that differ from default settings. &lt;br&gt; " id="1050" linkTypes="1" links="644" title="Search order for settings files" />
<node body="You should use special care when placing default or personal settings files in **local** directories, that is, directories other than homeDir, configDir or machineDir. In particular, the value of localDir can change when Leo reads additional files. This can result in Leo finding new default and personal settings files. The values of these newly-read settings files will, as always, override any previously-read settings. &lt;br&gt;  &lt;br&gt; Let us say that a setting is **volatile** if it is different from a default setting. Let us say that settings file A.leo **covers** settings file if B.leo if all volatile settings in B.leo occur in A.leo. With these definitions, the **safe rule** for placing settings files in local directories is:: &lt;br&gt;  &lt;br&gt;    Settings files in local directories should &lt;br&gt;    cover all other settings files. &lt;br&gt;  &lt;br&gt; Following this rule will ensure that the per-directory defaults specified in the local settings file will take precedence over all previously-read default and personal settings files. Ignore this principle at your peril. &lt;br&gt; " id="1051" linkTypes="1" links="644" title="Safe rules for local settings" />
<node body="Organizer nodes have headlines that do no start with @. Organizer nodes may be inserted freely without changing the meaning of an @setting tree. &lt;br&gt; " id="1052" linkTypes="1" links="644" title="Organizer nodes" />
<node body="Leo ignores any subtree of an @settings tree whose headline starts with @ignore. &lt;br&gt;  &lt;br&gt; You can use several other kinds of nodes to cause Leo to ignore parts of  an @settings tree: &lt;br&gt;  &lt;br&gt; - @if *expression* &lt;br&gt;  &lt;br&gt;   A node whose headline starts with @if *expression* acts like an organizer node if the expression evaluates to True, otherwise acts like an @ignore node. If the expression is empty the body text should contain a script that will be evaluated (in an empty context). &lt;br&gt;  &lt;br&gt; - @ifplatform *platform-name* &lt;br&gt;  &lt;br&gt;   Same as @if sys.platform == &quot;platform-name&quot;: except that it isn't necessary to import sys. &lt;br&gt;  &lt;br&gt; - @ifhostname *hostA,!hostB* &lt;br&gt;  &lt;br&gt;   Evaluates to True if and only if: h=g.computeMachineName(); h==hostA and h!=hostB. The &quot;!&quot; version allows matching to every machine name except the given one to allow differing settings on only a few machines. &lt;br&gt; " id="1053" linkTypes="1" links="644" title="\@ignore and \@if nodes" />
<node body="Simple settings nodes have headlines of the form ``@&lt;type&gt; name = val``. &lt;br&gt; These settings set the value of name to val, with the indicated type:: &lt;br&gt;  &lt;br&gt;     &lt;type&gt;          Valid values &lt;br&gt;     ------          ------------ &lt;br&gt;     @bool           True, False, 0, 1 &lt;br&gt;     @color          A Qt color name or value, such as 'red' or 'xf2fddff'    &lt;br&gt;                     (without the quotes) &lt;br&gt;     @directory      A path to a directory &lt;br&gt;     @float          A floating point number of the form nn.ff. &lt;br&gt;     @int            An integer &lt;br&gt;     @ints[list]     An integer (must be one of the ints in the list). &lt;br&gt;                     Example: @ints meaningOfLife[0,42,666]=42 &lt;br&gt;     @keys[name]     Gives a name to a set of bindings. &lt;br&gt;                     (For the Check Bindings script in leoSettings.leo.) &lt;br&gt;     @path           A path to a directory or file &lt;br&gt;     @ratio          A floating point number between 0.0 and 1.0, inclusive. &lt;br&gt;     @string         A string &lt;br&gt;     @strings[list]  A string (must be one of the strings in the list). &lt;br&gt;                     Example: @strings tk_relief['flat','groove','raised']='groove' &lt;br&gt;  &lt;br&gt; **Note**: For a list of Tk color specifiers see: &lt;br&gt;  &lt;br&gt; - http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm &lt;br&gt; - http://www.tcl.tk/man/tcl8.4/TkLib/GetColor.htm &lt;br&gt;  &lt;br&gt; **Important**: you can use the show-colors minibuffer command to guide you in making these settings. &lt;br&gt; " id="1054" linkTypes="1" links="644" title="Simple settings nodes" />
<node body="Complex settings nodes have headlines of the form ``@&lt;type&gt; description``:: &lt;br&gt;  &lt;br&gt;     @&lt;type&gt;             Valid values &lt;br&gt;     -------             ------------ &lt;br&gt;     @buttons            Child @button nodes create global buttons. &lt;br&gt;     @commands           Child @command nodes create global buttons. &lt;br&gt;     @command-history    Body is a list of commands pre-loaded into history list. &lt;br&gt;     @data               Body is a list of strings, one per line. &lt;br&gt;     @enabled-plugins    Body is a list of enabled plugins. &lt;br&gt;     @font               Body is a font description. &lt;br&gt;     @menus              Child @menu and @item nodes create menus and menu items. &lt;br&gt;     @menuat             Child @menu and @item nodes modify menu trees &lt;br&gt;                         created by \@menus. &lt;br&gt;     @mode [name]        Body is a list of shortcut specifiers. &lt;br&gt;     @recentfiles        Body is a list of file paths. &lt;br&gt;     @shortcuts          Body is a list of shortcut specifies. &lt;br&gt;  &lt;br&gt; Complex nodes specify settings in their body text. &lt;br&gt; See the following sections for details. &lt;br&gt; " id="1055" linkTypes="3 3 3 3 3 3 3 3 3 3 3" links="1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274" title="Complex settings nodes" />
<node body="Here is a complete list of options for the rst3 and code-to-rst commands: &lt;br&gt;  &lt;br&gt; .. glossary:: &lt;br&gt;     :sorted: &lt;br&gt;  &lt;br&gt; ``call_docutils (default: True)`` &lt;br&gt;     Call docutils to process the intermediate file. &lt;br&gt;  &lt;br&gt; ``default_path (default: '')`` &lt;br&gt;     The path to be prepended to filenames given in root nodes. &lt;br&gt;  &lt;br&gt; ``default_encoding (default: utf-8)`` &lt;br&gt;     The default encoding to be used for non-ascii (unicode characters). &lt;br&gt;  &lt;br&gt; ``generate_rst (default: True)`` &lt;br&gt;     A master switch. **True**: generate rST markup for rST sections and rST code-blocks. **False**: generate plain text and ignore ``@ @rst-markup`` doc parts. &lt;br&gt;  &lt;br&gt; ``generate_rst_header_comment (default: True)`` &lt;br&gt;     **True**: Leo writes a comment line of the form ``.. rst3: filename: &lt;filename&gt;`` at the start of intermediate files. This option has effect only if the ``generate_rst`` and ``write_intermediate_file`` options are both True. &lt;br&gt;  &lt;br&gt; ``publish-argv-for-missing-stylesheets (Default: '')`` &lt;br&gt;     The arguments to be passed to ``docutils.core.Publisher().publish()`` when no stylesheet is in effect. This is a string that represents a comma-separated list of strings: For example, the option:: &lt;br&gt;  &lt;br&gt;         publish-argv-for-missing-stylesheets=--language=de,--documentclass=report,--use-latex-toc &lt;br&gt;  &lt;br&gt;     results in the call:: &lt;br&gt;  &lt;br&gt;         publish(['--language=de','--documentclass=report','--use-latex-toc']) &lt;br&gt;  &lt;br&gt; ``show_headlines (default: True)`` &lt;br&gt;     **True**: automatically generate rST sections from headlines. **False**: ignore headlines. &lt;br&gt;      &lt;br&gt;     **Note**: The level of the node in the outline determines the level of the section underlining in the rST markup. Higher-level headlines in the outline correspond to higher-level section headings; lower-level headlines in the outline correspond to lower-level section headings. &lt;br&gt;  &lt;br&gt; ``show_organizer_nodes (default: True)`` &lt;br&gt;     **True**: generate rST sections for nodes that do not contain body text. *This option has no effect unless the rST section would otherwise be written*. &lt;br&gt;  &lt;br&gt; ``show_sections (default: True)`` &lt;br&gt;     **True**: generate rST sections corresponding to headlines. **False**: Generate lines of the form ``headline`` instead of sections. &lt;br&gt;      &lt;br&gt; ``silent (default: False)`` &lt;br&gt;     Write only the number of files written and the time taken to the log and console. &lt;br&gt;  &lt;br&gt; ``strip_at_file_prefixes (default: True)`` &lt;br&gt;     **True**: remove ``@auto``, ``@file``, ``@clean``, and ``@thin`` from the start of headlines. &lt;br&gt;  &lt;br&gt; ``stylesheet_name (default: 'default.css')`` &lt;br&gt;     The name of the stylesheet passed to docutils. &lt;br&gt;  &lt;br&gt; ``stylesheet_path (default: '')`` &lt;br&gt;     The directory containing the stylesheet passed to docutils. &lt;br&gt;      &lt;br&gt;     **Note**: If the ``stylesheet_embed`` option is True, specify a path relative to the location of the Leo file. If the ``stylesheet_embed`` option is False, specify a path relative to the location of the HTML file. &lt;br&gt;  &lt;br&gt; ``stylesheet_embed (default: True)`` &lt;br&gt;     **True**: The content of the stylesheet file will be embedded in the HTML file. **False**: The HTML file will link to an external stylesheet file. &lt;br&gt;  &lt;br&gt; ``underline_characters (default: #=+*^~&quot;'\`-:&gt;\_)`` &lt;br&gt;     The underlining characters to be used to specify rST sections. The first character is reserved so you can specify the top-level section explicitly. &lt;br&gt;  &lt;br&gt; ``verbose (default: True)`` &lt;br&gt;     **True**: write informational messages to the log as well as the console. &lt;br&gt;  &lt;br&gt; ``write_intermediate_file (default: False)`` &lt;br&gt;     Tells whether to write an intermediate file. &lt;br&gt;      &lt;br&gt;     **True**: writes the intermediate file to the external file system. The name of the intermediate file has the name of the output file with ``.txt`` appended. This option has effect only if the ``generate_rst option`` is True. &lt;br&gt; " id="1056" linkTypes="1" links="649" title="General options" />
<node body="Any headline that starts with @rst- controls the rst3 command. &lt;br&gt;  &lt;br&gt; .. glossary:: &lt;br&gt;     :sorted: &lt;br&gt;  &lt;br&gt; ..  @rst-code &lt;section&gt;  &lt;br&gt; ..      Enter code mode. (Code mode is covered in the advanced topics sections) &lt;br&gt; ..      Create a section if the show_headlines option is True. &lt;br&gt;  &lt;br&gt; ``@rst-ignore &lt;ignored-text&gt;`` &lt;br&gt;     Ignore the node and its descendants. &lt;br&gt;  &lt;br&gt; ``@rst-ignore-node &lt;ignored-text&gt;`` &lt;br&gt;     Ignore the node, but *not* its descendants. &lt;br&gt;  &lt;br&gt; ``@rst-ignore-tree &lt;ignored-text&gt;`` &lt;br&gt;     Same as @rst-ignore. Ignore the node and its descendants. &lt;br&gt;  &lt;br&gt; ``@rst-no-head &lt;ignored-text&gt;`` &lt;br&gt;     Ignore the headline but not the body text of this node. *This option has no effect on descendant nodes*. &lt;br&gt;  &lt;br&gt; ``@rst-no-headlines &lt;ignored-text&gt;`` &lt;br&gt;     Ignore the headline of this node and descendant nodes. &lt;br&gt;      &lt;br&gt; ``@rst-table &lt;ignored text&gt;`` &lt;br&gt;     Ignore headlines and write exactly one newline at the end of this node and all descendant nodes. Very useful for creating rST tables. &lt;br&gt;  &lt;br&gt; ``@rst-option &lt;option&gt; = &lt;value&gt;`` &lt;br&gt;     Set a single option to the given value. The default value is True. &lt;br&gt;  &lt;br&gt; ``@rst-options &lt;ignored-text&gt;`` &lt;br&gt;     Set options from body text. The body text should contain nothing but &lt;br&gt;     lines of the form ``&lt;option&gt;=&lt;value&gt;`` &lt;br&gt;  &lt;br&gt; ``@rst-preformat &lt;ignored-text&gt;`` &lt;br&gt;     Format the body text of the node as computer source code. In effect, this option adds a line containing '::' at the start of the body text. The option then indents all following lines. *This option has no effect on descendant nodes*. &lt;br&gt;  &lt;br&gt; ..  @rst-rst &lt;br&gt; ..      Enter rst mode. (Rst mode is the mode of operation discussed in the tutorial.) &lt;br&gt; ..      Create a section if the show_headlines option is True. &lt;br&gt; " id="1057" linkTypes="1" links="649" title="Headline commands" />
<node body="**Option doc parts** set rst3 options. Option doc parts start with ``@ @rst-options`` followed by lines of the form ``name=value``. Comment lines starting with ``..`` are allowed. For example:: &lt;br&gt;  &lt;br&gt;     @ @rst-options &lt;br&gt;     .. This comment line is ignored. &lt;br&gt;     show_headlines=False &lt;br&gt;     show_leo_directives=False &lt;br&gt;     verbose=True &lt;br&gt;     @c &lt;br&gt;  &lt;br&gt; This is a real Leo doc part. Like all other doc parts an option doc part starts with ``@`` and continues until the end of body text or until the next ``@c``. &lt;br&gt; " id="1058" linkTypes="1" links="649" title="Option doc parts" />
<node body="Settings in leoSettings.leo or myLeoSettings.leo specify the defaults to be used for all rst3 options.  The form of these settings is:: &lt;br&gt;  &lt;br&gt;     @bool rst3_&lt;option name&gt; = True/False &lt;br&gt;     @string rst3_&lt;option name&gt; = aString &lt;br&gt;  &lt;br&gt; That is, to create a default value for an rst3 setting, you must prefix the option name with ``rst3_``.  For example:: &lt;br&gt;  &lt;br&gt;     @bool rst3_write_intermediate_file = True &lt;br&gt; " id="1059" linkTypes="1" links="649" title="Settings give defaults for options" />
<node body="The following options are for the use of Bernhard Mulder's http plugin. The http plugin creates an http server running on a local port, typically 8080. When the http plugin is running you will see a purple message in the log window that looks something like this:: &lt;br&gt;  &lt;br&gt;     http serving enabled on port 8080, version 0.91 &lt;br&gt;  &lt;br&gt; To use the http plugin, start a web browser and enter this url:: &lt;br&gt;  &lt;br&gt;     http://localhost:8080/ &lt;br&gt;  &lt;br&gt; You will see a a top level page containing one link for every open .leo file. Clicking on a link will cause the http server to pass a new page to the browser. You can use the browser's refresh button to update the top-level view in the browser after you have opened or closed files. &lt;br&gt;  &lt;br&gt; **Important**: See the docstring for the http plugin for information on configuring the plugin. Some of the following rst3 settings must match values of settings for the http plugin. &lt;br&gt;  &lt;br&gt; Here are the rst3 options that support the http plugin: &lt;br&gt;  &lt;br&gt; .. glossary:: &lt;br&gt;  &lt;br&gt; ``http_server_support (default: False)`` &lt;br&gt;     A master switch: none of the following options have any effect unless this option is True. If True, the rst3 command does the following: &lt;br&gt;  &lt;br&gt; - Writes **node markers** in the rst output for use by the http plugin. Node markers are rst named hyperlink targets. By default they look like: ``.. _http-node-marker-N``, where N is a unique node number. &lt;br&gt;  &lt;br&gt; - Adds additional information to all nodes of the tree being formatted using Leo's unknownAttributes mechanism. &lt;br&gt;  &lt;br&gt; ``http_attributename (default: rst_http_attribute)`` &lt;br&gt;     The name of the attribute name written to the ``unknownAttributes`` attribute of each outline node in the rst root tree. The default is ``rst_http_attribute``. It should match this setting: ``@string rst_http_attributename = rst_http_attribute``. &lt;br&gt;  &lt;br&gt; ``clear_http_attributes (default: False)`` &lt;br&gt;     **True**: the rst3 command initially clears the fields specified by `http_attributename`.   &lt;br&gt;  &lt;br&gt; ``node_begin_marker (default: http-node-marker-)`` &lt;br&gt;     The string used for node markers. &lt;br&gt; " id="1060" linkTypes="1" links="649" title="Http plugin options" />
<node body="The following options allow you to expand noweb section references, much like Leo itself does. The rst3 command ensures that unbounded expansions can not happen. While expanding any section, the rst3 will not expand again any sections that have already occurred in the expansion. &lt;br&gt;  &lt;br&gt; ``expand_noweb_references`` &lt;br&gt;    True: Replace references by definitions. Definitions must be descendants of the referencing node. &lt;br&gt;  &lt;br&gt; ``ignore_noweb_definitions`` &lt;br&gt;     True: ignore section definition nodes. &lt;br&gt;  &lt;br&gt; ``expand_noweb_recursively`` &lt;br&gt;     True: recursively expand definitions by expanding any references found in definitions. &lt;br&gt;          &lt;br&gt; **Note**: This is an experimental feature: all aspects might changed. The defaults for all these options ensure that the rst3 command works as it has always. &lt;br&gt; " id="1061" linkTypes="1" links="649" title="Section expansion options" />
<node body="**Markup doc parts** have the following form:: &lt;br&gt;  &lt;br&gt;     @ @rst-markup &lt;br&gt;     any rST markup &lt;br&gt;     @c &lt;br&gt;  &lt;br&gt; Markup doc parts inserts the markup directly into the output. Markup doc parts are most useful when formatting an outline as code using the code-to-rst command. &lt;br&gt; " id="1062" linkTypes="1" links="650" title="Markup doc parts" />
<node body="HTML files generated by the rst3 command assume that three .css (cascading style sheet) files exist in the same directory. For the HTML output to look good the following .css files should exist: &lt;br&gt;  &lt;br&gt; - default.css is the default style sheet that docutils expects to exist. &lt;br&gt;  &lt;br&gt; - leo_rst.css contains some style improvements based on Gunnar Schwant's DocFactory. &lt;br&gt;  &lt;br&gt; .. - silver_city.css is the style sheet that controls the syntax highlighting generated by SilverCity. &lt;br&gt;  &lt;br&gt; The latter two style sheets are imported at the end of the default.css. &lt;br&gt;  &lt;br&gt; **Important:** You can use cascading style sheets to do things that otherwise wouldn't be possible with &quot;plain&quot; rST. For instance, the background color of this page was specified in a body style. &lt;br&gt; " id="1063" linkTypes="1" links="650" title="Required cascading style sheets" />
<node body="A new method has been added to make it more easily to write rST code from scripts:: &lt;br&gt;  &lt;br&gt;     c.rstCommands.writeNodeToString(p) &lt;br&gt;  &lt;br&gt; ``writeNodeToString`` scans p's tree (p defaults to presently selected node) looking for @rst nodes. When the first @rst node is found, writeNodeToString processes the node as usual, with the following changes: &lt;br&gt;  &lt;br&gt; - @rst need not be followed by a filename; any filename and its extension are *ignored*. &lt;br&gt;  &lt;br&gt; - Only the ext argument to writeNodeToString determines the type of output produced. The valid values for the ext argument are None (for rst output), '.html', '.pdf', and '.tex'. &lt;br&gt;  &lt;br&gt; - Instead of writing the result to a file, writeNodeToString returns the tuple (p,s), where p is the node whose tree produced the output, and s is the output itself. &lt;br&gt;  &lt;br&gt; - writeNodeToString returns after processing at most one @rst node. &lt;br&gt;  &lt;br&gt; Scripts can easily use writeNodeToString to convert @rst trees into various kinds of output. For example:: &lt;br&gt;  &lt;br&gt;     p,s = c.rstCommands.writeNodeToString(p,ext='html') &lt;br&gt;  &lt;br&gt; Notes: &lt;br&gt;  &lt;br&gt; - This script scans the presently selected tree for @rst nodes. In particular, if the presently selected tree does not contain an @rst node the search continues in parent trees. When an @rst node is found, it converts the node (and descendants) to html and returns p, the found @rst node and s, the html itself. &lt;br&gt;  &lt;br&gt; - Valid values for the ext argument are &quot;.html&quot;, &quot;.tex&quot; or None (specifies rst output) &lt;br&gt;  &lt;br&gt; - There is some support for ext=&quot;.pdf&quot;, but this is experimental code.  Expect crashes. &lt;br&gt; " id="1064" linkTypes="1" links="650" title="Controlling the rst3 command from scripts" />
<node body="The rst3 command supports three different modes. &lt;br&gt;  &lt;br&gt; ``rst mode`` &lt;br&gt;     The default mode, as discussed in the Tutorial. The rst3 command treats body text as rST (or Sphinx) markup. &lt;br&gt;      &lt;br&gt; ``code mode`` &lt;br&gt;     The rst3 command treats body text as computer source code, generating the appropriate rST or Sphinx markup. Code mode is inherently complex. It supports *many* options. &lt;br&gt;      &lt;br&gt; ``doc-only mode`` &lt;br&gt;     The rst3 command outputs only regular doc parts and @ @rst-markup doc parts. Headlines create section in doc_only mode only if: &lt;br&gt;  &lt;br&gt; 1. The node contains a doc part or &lt;br&gt;  &lt;br&gt; 2. The show_organizer_nodes option is in effect. &lt;br&gt;  &lt;br&gt; The code_mode and doc_only_mode options determine the mode as follows: &lt;br&gt;  &lt;br&gt; ``code_mode=False; doc_only_mode=False (the default)`` &lt;br&gt;     Enters rst mode. &lt;br&gt;      &lt;br&gt; ``code_mode=False; doc_only_mode=True`` &lt;br&gt;     Enters doc_only mode. &lt;br&gt;  &lt;br&gt; ``code_mode=True; (doc_only_mode ignored)`` &lt;br&gt;     Enters code mode. &lt;br&gt; " id="1065" linkTypes="1" links="653" title="Modes" />
<node body="The following options have effect only in code mode. &lt;br&gt;  &lt;br&gt; .. glossary:: &lt;br&gt;     :sorted: &lt;br&gt;  &lt;br&gt; ``number_code_lines (default: True)`` &lt;br&gt;     Controls whether to number code lines in code mode. *This option has no effect in rst mode*. &lt;br&gt;  &lt;br&gt; ``show_leo_directives (default: True)`` &lt;br&gt;     True: include Leo directives False: ignore Leo directives. &lt;br&gt;  &lt;br&gt; ``show_markup_doc_parts (default: False)`` &lt;br&gt;     True: include markup doc parts. False: ignore markup doc parts. &lt;br&gt;  &lt;br&gt; ``show_options_doc_parts (default: False)`` &lt;br&gt;     True: include options doc parts. False: ignore options doc parts. &lt;br&gt;  &lt;br&gt; ``show_doc_parts_as_paragraphs (default: False)`` &lt;br&gt;     True: Move doc parts outside of the code-block directive. False: Show doc parts in the code-block directive. &lt;br&gt;      &lt;br&gt;     **Cool**: Any rST markup in doc parts included as the result of this option will be rendered properly. &lt;br&gt;  &lt;br&gt; ``show_options_nodes (default: False)`` &lt;br&gt;     True: show @rst-options nodes. False: Ignore @ &lt;br&gt; " id="1066" linkTypes="1" links="653" title="Code mode options" />
<node body="The following option has effect only in rst mode. &lt;br&gt;  &lt;br&gt; .. glossary:: &lt;br&gt;  &lt;br&gt; ``show_doc_parts_in_rst_mode [True,False or class names] (default: True)`` &lt;br&gt;     This option is most useful for rst documents which are not computer code. It allows you to use doc parts to make comments on the draft document which are either excluded from the output or formatted in a way that highlights their nature as comments rather than content. For example, you're writing a book, and you want to use a doc part at the top of a section to remind yourself &quot;need to explain how Ted got to Sally's&quot;. Note: you may need to add CSS to have them formatted differently. &lt;br&gt;  &lt;br&gt;     The option can be `True`, `False`, or one or more class names. &lt;br&gt;      &lt;br&gt;     **True**: Treat the entire doc part from the opening '@' to the closing '@c &lt;br&gt;     as normal markup. &lt;br&gt;      &lt;br&gt;     **False**: Remove the doc part. &lt;br&gt;  &lt;br&gt;     **class names**: Process the contents of the doc part as it if were in an rst `container` directive. For example:: &lt;br&gt;  &lt;br&gt;          @ @rst-options &lt;br&gt;          show_doc_parts_in_rst_mode = notes literal &lt;br&gt;          @c &lt;br&gt;  &lt;br&gt; This would wrap the doc part contents in the output in a div with classes &quot;container notes literal&quot;. Furthermore, if one of the class names is ``literal``, then the doc part content will be output as a literal block wrapped in a container as described above. This allows you to use text which is not valid rst as rough notes for annotating a draft document. &lt;br&gt; " id="1067" linkTypes="1" links="653" title="Rst mode options" />
<node body="The rst3 command defines a code-block rST directive. The primary purpose of this directive is to show formatted source code. &lt;br&gt;  &lt;br&gt; In rst mode you can insert the code-block directive like any other rST markup. The rst3 command generates code-block directives automatically in code mode. This directive takes one argument, a language name.  Like this:: &lt;br&gt;  &lt;br&gt;     .. code-block:: Python &lt;br&gt;  &lt;br&gt;         import leo.core.leoPlugins as leoPlugins &lt;br&gt;         import leo.core.leoGlobals as g &lt;br&gt;  &lt;br&gt; The output looks like this:: &lt;br&gt;  &lt;br&gt;     import leo.core.leoPlugins as leoPlugins &lt;br&gt;     import leo.core.leoGlobals as g &lt;br&gt;  &lt;br&gt; .. _`Scripting Tutorial`:   tutorial-scripting.html &lt;br&gt;  &lt;br&gt; See the `Scripting Tutorial`_ for many examples of how to use code-blocks. &lt;br&gt; " id="1068" linkTypes="1" links="653" title="The code-block directive" />
<node body="" id="1069" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292" title="Commands &amp; directives" />
<node body="" id="1070" linkTypes="3 3 3 3 3 3 3" links="1293 1294 1295 1296 1297 1298 1299" title="Debugging" />
<node body="" id="1071" linkTypes="3 3 3 3 3 3" links="1300 1301 1302 1303 1304 1305" title="External programs" />
<node body="" id="1072" linkTypes="3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3" links="1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323" title="Files and nodes" />
<node body="" id="1073" linkTypes="3 3 3 3" links="1324 1325 1326 1327" title="Scripting" />
<node body="" id="1074" linkTypes="3 3" links="1328 1329" title="Servers" />
<node body="" id="1075" linkTypes="3 3" links="1330 1331" title="Slideshows and screenshots" />
<node body="" id="1076" linkTypes="3 3 3 3" links="1332 1333 1334 1335" title="Text formatting" />
<node body="" id="1077" linkTypes="3 3 3 3 3 3 3 3 3 3 3" links="1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346" title="User interface" />
<node body="Edits user attributes in a Qt frame. &lt;br&gt;  &lt;br&gt; This plugin creates a frame for editing attributes similar to:: &lt;br&gt;  &lt;br&gt;     Name:   Fred Blogs &lt;br&gt;     Home:   555-555-5555 &lt;br&gt;     Work:   555-555-5556 &lt;br&gt;  &lt;br&gt; ``attrib_edit`` is also intended to provide attribute editing for other plugins, see below. &lt;br&gt;  &lt;br&gt; The attributes can be stored in different ways, three modes are implemented currently: &lt;br&gt;  &lt;br&gt; v.u mode &lt;br&gt;   These attributes are stored in the &quot;unknownAttributes&quot; (uA) data for &lt;br&gt;   each node, accessed via v.u. &lt;br&gt;  &lt;br&gt; Field: &lt;br&gt;   Attributes are lines starting (no whitespace) with &quot;AttributeName:&quot; in &lt;br&gt;   the body text. &lt;br&gt;  &lt;br&gt; @Child &lt;br&gt;   Attributes are the head strings of child nodes when the head string &lt;br&gt;   starts with '@AttributeName' where the first letter (second character) &lt;br&gt;   must be capitalized. &lt;br&gt;  &lt;br&gt; The plugin defines the following commands, available either in the plugin's sub-menu in the Plugins menu, or as ``Alt-X attrib-edit-*``. &lt;br&gt;  &lt;br&gt; attrib-edit-modes &lt;br&gt;     Select which attribute setting / getting modes to use.  More than one mode &lt;br&gt;     can be used at the same time. &lt;br&gt;  &lt;br&gt;     You can also control which modes are active by listing them  &lt;br&gt;     with the @data attrib_edit_active_modes setting.  For example:: &lt;br&gt;  &lt;br&gt;         Field: &lt;br&gt;         @Child &lt;br&gt;         # v.u mode &lt;br&gt;  &lt;br&gt;     would cause only the &quot;Field:&quot; and &quot;@Child&quot; modes to be active be default. &lt;br&gt;  &lt;br&gt; attrib-edit-manage &lt;br&gt;     Select which attributes, from all attributes seen so &lt;br&gt;     far in this outline, to include on the current node. &lt;br&gt;  &lt;br&gt; attrib-edit-scan &lt;br&gt;     Scan the entire outline for attributes so ``attrib-edit-manage`` &lt;br&gt;     has the complete list. &lt;br&gt;  &lt;br&gt; attrib-edit-create &lt;br&gt;     Create a new attribute on the current node.  If Field: or @Child modes &lt;br&gt;     are active, they simply remind you how to create an attribute in the log pane. &lt;br&gt;     If the &quot;v.u mode&quot; mode is active, you're prompted for a path for the attribute. &lt;br&gt;     For example:: &lt;br&gt;  &lt;br&gt;         addressbook First &lt;br&gt;  &lt;br&gt;     to store the attribute in v.u['addressbook']['_edit']['First'] &lt;br&gt;  &lt;br&gt;     As a convenience, entering a path like:: &lt;br&gt;  &lt;br&gt;         todo metadata created|creator|revised &lt;br&gt;  &lt;br&gt;     would create:: &lt;br&gt;  &lt;br&gt;         v.u.['todo']['metadata']['_edit']['created'] &lt;br&gt;         v.u.['todo']['metadata']['_edit']['creator'] &lt;br&gt;         v.u.['todo']['metadata']['_edit']['revised'] &lt;br&gt;  &lt;br&gt;  &lt;br&gt; **Technical details** &lt;br&gt;  &lt;br&gt; See the source for complete documentation for use with other plugins. Here are some points of interest: &lt;br&gt;  &lt;br&gt; - In addition to ``v.u['addressbook']['_edit']['first']``, paths like ``v.u['addressbook']['_edit']['_int']['age']`` may be used to identify type, although currently there's no difference in the edit widget. &lt;br&gt;  &lt;br&gt; - In the future the plugin may allow other plugins to register to provide attribute path information, instead of just scanning for ['_edit'] entries in v.u. &lt;br&gt;  &lt;br&gt; - Currently there's no sorting of the attributes in &quot;v.u mode&quot;, which is a problem for some applications.  It's unclear where the desired order would be stored, without even more repetition in v.u.  When other plugins can register to manipulate the attribute list each plugin could address this, with unordered presentation in the absence of the client plugin. &lt;br&gt;  &lt;br&gt; - There's code to have the editor appear in a tab instead of its own area under the body editor, but (a) this is always being buried by output in the log window, and (b) there's a bug which leaves some (harmless) ghost widgets in the background.  Enable by @setting ``attrib_edit_placement`` to 'tab'. &lt;br&gt; " id="1078" linkTypes="1" links="658" title="attrib_edit.py" />
<node body="Creates a global search window &lt;br&gt;  &lt;br&gt; Use the global-search command to show this window. To restore the original appearance of the window, type help. &lt;br&gt;  &lt;br&gt; Requires the whoosh library ('easy_install whoosh') to do full text searches. &lt;br&gt; " id="1079" linkTypes="1" links="658" title="bigdash.py" />
<node body="Open bookmarks in a list, and show bookmarks in a pane. &lt;br&gt; " id="1080" linkTypes="1" links="658" title="bookmarks.py" />
<node body="Manipulates appearance of individual tree widget items. &lt;br&gt;  &lt;br&gt; This plugin is mostly an example of how to change the appearance of headlines. As such, it does a relatively mundane chore of highlighting @thin, @auto, @shadow nodes in bold. &lt;br&gt; " id="1081" linkTypes="1" links="658" title="colorize_headlines.py" />
<node body="Defines various useful actions for context menus (Qt only). &lt;br&gt;  &lt;br&gt; Examples are: &lt;br&gt;  &lt;br&gt; - Edit in $EDITOR &lt;br&gt; - Edit @thin node in $EDITOR (remember to do &quot;refresh&quot; after this!) &lt;br&gt; - Refresh @thin node from disk (e.g. after editing it in external editor) &lt;br&gt; - Go to clone &lt;br&gt;  &lt;br&gt; Here's an example on how to implement your own context menu items in your plugins:: &lt;br&gt;  &lt;br&gt;     def nextclone_rclick(c,p, menu): &lt;br&gt;         &quot;&quot;&quot; Go to next clone &quot;&quot;&quot; &lt;br&gt;  &lt;br&gt;         # only show the item if you are on a clone &lt;br&gt;         # this is what makes this &quot;context sensitive&quot; &lt;br&gt;         if not p.isCloned(): &lt;br&gt;             return     &lt;br&gt;  &lt;br&gt;         def nextclone_rclick_cb(): &lt;br&gt;             c.goToNextClone() &lt;br&gt;  &lt;br&gt;         # 'menu' is a QMenu instance that was created by Leo  &lt;br&gt;         # in response to right click on tree item &lt;br&gt;  &lt;br&gt;         action = menu.addAction(&quot;Go to clone&quot;) &lt;br&gt;         action.connect(action, QtCore.SIGNAL(&quot;triggered()&quot;), nextclone_rclick_cb) &lt;br&gt;  &lt;br&gt; And call this in your plugin *once*:: &lt;br&gt;  &lt;br&gt;     g.tree_popup_handlers.append(nextclone_rclick) &lt;br&gt; " id="1082" linkTypes="1" links="658" title="contextmenu.py" />
<node body="Adds a graph layout for nodes in a tab. Requires Qt and the backlink.py plugin. &lt;br&gt;  &lt;br&gt; " id="1083" linkTypes="1" links="658" title="graphcanvas.py" />
<node body="By Ville M. Vainio &lt;br&gt; See: http://en.wikipedia.org/wiki/Mylyn &lt;br&gt;  &lt;br&gt; I went on to start a &quot;leo mylyn&quot; plugin to exercise using the childrenModified and contentModified signals. &lt;br&gt;  &lt;br&gt; If you want to play with it, enable leomylyn.py, modify stuff around the tree and do alt-x mylyn-scores. &lt;br&gt;  &lt;br&gt; Of course as it is useless in this state, but becomes useful when it has a proper gui (maybe in Nav pane), where you would then have a list of &quot;most interesting&quot; nodes. &lt;br&gt;  &lt;br&gt; In the future, this could be able to remember the scores through the sessions, degrade the old scores by time, etc. Also, a scoreset would be associated with a &quot;project&quot; (e.g.&quot;own research&quot;, &quot;work project foo&quot;), each of them having their own typical node working set. &lt;br&gt;  &lt;br&gt; Mylyn was a nice boost back in the eclipse days, it could work for Leo too. My main motivation right now was to demonstrate the signals with something that is much simpler than using them in qmlnotebook. &lt;br&gt; " id="1084" linkTypes="1" links="658" title="leomylyn.py" />
<node body="The livecode-show commands shows the live code evaluation pane. Hover on the buttons for helpful tool-tips. &lt;br&gt;  &lt;br&gt; Depends on https://pypi.python.org/pypi/meta which you can install with:: &lt;br&gt;  &lt;br&gt;     pip install meta &lt;br&gt;  &lt;br&gt; The dependency on `meta` is for recursively turning AST node trees back into printable identifiers like &quot;m[m[5]]&quot;.  For example:: &lt;br&gt;  &lt;br&gt;    a = 7 &lt;br&gt;  &lt;br&gt; is easy, but:: &lt;br&gt;  &lt;br&gt;    m[m[5]] = 7 &lt;br&gt;  &lt;br&gt; is not. &lt;br&gt; " id="1085" linkTypes="1" links="658" title="livecode.py" />
<node body="Adds &quot;Back&quot; and &quot;Forward&quot; buttons (Qt only). &lt;br&gt;  &lt;br&gt; Creates &quot;back&quot; and &quot;forward&quot; buttons on button bar. These navigate &lt;br&gt; the node history. &lt;br&gt;  &lt;br&gt; This plugin does not need specific setup. If the plugin is loaded, the buttons  &lt;br&gt; will be available. The buttons use the icon specified in the active Qt style &lt;br&gt;  &lt;br&gt; " id="1086" linkTypes="1" links="658" title="nav_qt.py" />
<node body="Provides node tagging capabilities to Leo &lt;br&gt;  &lt;br&gt; By Jacob M. Peck &lt;br&gt;  &lt;br&gt; " id="1087" linkTypes="3 3 3" links="1347 1348 1349" title="nodetags.py" />
<node body="This plugin supports printing using the Qt GUI. &lt;br&gt; Written by Jacob M. Peck. &lt;br&gt; " id="1088" linkTypes="1" links="658" title="printing.py" />
<node body="Creates a wizard that creates @auto nodes. &lt;br&gt;  &lt;br&gt; Opens a file dialog and recursively creates @auto &amp; @path nodes from the path &lt;br&gt; where the selected file is (the selected file itself doesn't matter.) &lt;br&gt;  &lt;br&gt; " id="1089" linkTypes="1" links="658" title="projectwizard.py" />
<node body="Adds a fast-to-use search widget, like the &quot;Find in files&quot; feature of many editors. &lt;br&gt;  &lt;br&gt; Just load the plugin, activate &quot;Nav&quot; tab, enter search text and press enter. &lt;br&gt;  &lt;br&gt; The pattern to search for is, by default, a case *insensitive* fnmatch pattern &lt;br&gt; (e.g. foo*bar), because they are typically easier to type than regexps. If you &lt;br&gt; want to search for a regexp, use 'r:' prefix, e.g. r:foo.*bar. &lt;br&gt;  &lt;br&gt; Regexp matching is case sensitive; if you want to do a case-insensitive regular &lt;br&gt; expression search (or any kind of case-sensitive search in the first place), do it &lt;br&gt; by searching for &quot;r:(?i)Foo&quot;. (?i) is a standard feature of Python regular expression &lt;br&gt; syntax, as documented in  &lt;br&gt;  &lt;br&gt; http://docs.python.org/library/re.html#regular-expression-syntax &lt;br&gt;  &lt;br&gt; " id="1090" linkTypes="1" links="658" title="quicksearch.py" />
<node body="By Terry Brown. See http://leo-editor.github.io/screen_capture.html &lt;br&gt;  &lt;br&gt; screen_capture now captures an image immediately, screen_capture_5sec waits &lt;br&gt; five seconds, so you can position the pointer, open menus etc. The only &lt;br&gt; feedback is in the console, as messages in the log would be distracting in &lt;br&gt; the captured image." id="1091" linkTypes="1" links="658" title="screen_capture.py" />
<node body="Screencasts promise to be easy to be *much* easier to create than slideshows, while also being more interesting, informative and flashy.  It is *so* much easier to write a screencast script than it is to lay out a slide, take a screenshot, and then manage resulting slide. &lt;br&gt;  &lt;br&gt; In particular, there are few continuity problems with screencasts. Continuity is a *huge* problem with slideshows!  If I change one slide, I am likely to want to change all following slides.  Which means I have to retake all the slides, and file the new versions in the proper places.  In contrast, any changes to screencasts naturally propagate forward.  There might be an effect on following screencasts scenes, but this will happen rarely with a reasonable scene design, and any problems should be easy to fix. &lt;br&gt;  &lt;br&gt; With screencasts, the *movie* script is also the *python* script!  There is no &quot;translation&quot; from one to the other.  Furthermore, all the work to produce a screencast is done (naturally!) within Leo.  No need to create and manage external data.  This is another huge advantage and it make producing screencasts much faster than producing slideshows. &lt;br&gt;  &lt;br&gt; Screencasts may be the long-awaited tools that will allow me to show Leo in action so that other will finally be able to understand it easily. &lt;br&gt; " id="1092" linkTypes="1" links="658" title="screencast.py" />
<node body="Provides a Scrolled Message Dialog service for Qt. &lt;br&gt;  &lt;br&gt; The plugin can display messages supplied as plain text or formatted as html. In &lt;br&gt; addition the plugin can accept messages in rst format and convert them to be &lt;br&gt; displayed as html. &lt;br&gt;  &lt;br&gt; The displayed format can be controlled by the user via check boxes, so rst &lt;br&gt; messages may be viewed either as text or as html. Html messages can also be &lt;br&gt; viewed as raw text, which will be a good debug feature when creating complex &lt;br&gt; dynamically generated html messages. &lt;br&gt;  &lt;br&gt; The user interface is provided by a ScrolledMessage.ui file which is dynamically &lt;br&gt; loaded each time a new dialog is loaded. &lt;br&gt;  &lt;br&gt; The dialog is not modal and many dialogs can exist at one time. Dialogs can be &lt;br&gt; named and output directed to a dialog with a specific name. &lt;br&gt;  &lt;br&gt; The plugin is invoked like this:: &lt;br&gt;  &lt;br&gt;     g.doHook('scrolledMessage', c=c, msg='message', title='title',  ...etc    ) &lt;br&gt;  &lt;br&gt; or:: &lt;br&gt;  &lt;br&gt;     g.app.gui.runScrolledMessageDialog(c=c, ...etc) &lt;br&gt;  &lt;br&gt; All parameters are optional except c. &lt;br&gt;  &lt;br&gt; **Parameters** &lt;br&gt;  &lt;br&gt; msg: &lt;br&gt;     The text to be displayed (html, rst, plain). &lt;br&gt;  &lt;br&gt;     If the text starts with 'rst:' it is assumed to be rst text and &lt;br&gt;     is converted to html for display after the rst: prefix has been removed. &lt;br&gt;     If the text starts with '&lt;' it is assumed to be html. &lt;br&gt;     These auto detection features can be overridden by 'flags'. &lt;br&gt;  &lt;br&gt; label: &lt;br&gt;     The text to appear in a label above the display. If it is '', the label is hidden. &lt;br&gt;  &lt;br&gt; title: &lt;br&gt;     The title to appear on the window or dock. &lt;br&gt;  &lt;br&gt; flags: &lt;br&gt;     Says what kind of message: 'rst', 'text', 'html'. This overrides auto-detection. &lt;br&gt;  &lt;br&gt;     Flags can be combined, for example, 'rst html' causes the message &lt;br&gt;     to be interpreted as rst and displayed as html. &lt;br&gt;  &lt;br&gt; ..  To Do &lt;br&gt; ..  - Add parameters to control position, size, closing, hiding etc. &lt;br&gt; ..  - Save or print files from the dialog. &lt;br&gt; ..  - Add an option to put the dialog in leo's log notebook. &lt;br&gt; ..  - Add @settings to control default behavior &lt;br&gt; ..  - Provide a menu of plugins that allows their docstring to be displayed. &lt;br&gt; ..  - Provide a menu of @rst nodes in the current outline, automatically track changes &lt;br&gt; ..    if it is set to display any of these nodes. &lt;br&gt; " id="1093" linkTypes="1" links="658" title="scrolledmessage.py" />
<node body="Launches the spyder environment with access to Leo instance. &lt;br&gt; See http://packages.python.org/spyder/ &lt;br&gt;  &lt;br&gt; Execute alt-x spyder-launch to start spyder. Execute alt-x spyder-update to pass &lt;br&gt; current c,p,g to spyder interactive session. spyder-update also shows the window &lt;br&gt; if it was closed before. &lt;br&gt;  &lt;br&gt; " id="1094" linkTypes="1" links="658" title="spydershell.py" />
<node body="Adds simple &quot;sticky notes&quot; feature (popout editors) for Qt gui. &lt;br&gt;  &lt;br&gt; Adds the following (``Alt-X``) commands: &lt;br&gt;  &lt;br&gt; ``stickynote`` &lt;br&gt;   pop out current node as a sticky note &lt;br&gt; ``stickynoter`` &lt;br&gt;   pop out current node as a rich text note &lt;br&gt; ``stickynoteenc`` &lt;br&gt;   pop out current node as an encrypted note &lt;br&gt; ``stickynoteenckey`` &lt;br&gt;   enter a new en/decryption key &lt;br&gt; ``tabula`` &lt;br&gt;   add the current node to the stickynotes in the `Tabula` &lt;br&gt;   sticky note dock window, and show the window &lt;br&gt; ``tabula-show`` &lt;br&gt;   show the `Tabula` sticky note dock window &lt;br&gt;   (without adding the current node) &lt;br&gt; ``tabula-marked`` &lt;br&gt;   add all marked nodes to the stickynotes in the `Tabula` &lt;br&gt;   sticky note dock window, and show the window &lt;br&gt;  &lt;br&gt; Sticky notes are synchronized (both ways) with their parent Leo node. &lt;br&gt;  &lt;br&gt; Encrypted mode requires the python-crypto module. &lt;br&gt;  &lt;br&gt; The first time you open a note in encrypted mode you'll be asked for a pass &lt;br&gt; phrase. That phrase will be used for the rest of the session, you can change it &lt;br&gt; with ``Alt-X`` ``stickynoteenckey``, but probably won't need to. &lt;br&gt;  &lt;br&gt; The encrypted note is stored in base64 encoded *encrypted* text in the parent &lt;br&gt; Leo node, if you forget the pass phrase there's no way to un-encrypt it again. &lt;br&gt; Also, you must not edit the text in the Leo node. &lt;br&gt;  &lt;br&gt; When **creating an encrypted note**, you should **start with an empty node**. &lt;br&gt; If you want to encrypt text that already exists in a node, select-all cut it to &lt;br&gt; empty the node, then paste it into the note. &lt;br&gt;  &lt;br&gt; " id="1095" linkTypes="1" links="658" title="stickynotes.py" />
<node body="Provides to-do list and simple task management for leo (Qt only). &lt;br&gt;  &lt;br&gt; This plugin adds time required, progress and priority settings for nodes. With &lt;br&gt; the @project tag a branch can display progress and time required with dynamic &lt;br&gt; hierarchical updates. &lt;br&gt;  &lt;br&gt; For full documentation see: &lt;br&gt;  &lt;br&gt;   - http://leo.zwiki.org/ToDo  &lt;br&gt;   - http://leo.zwiki.org/tododoc.html &lt;br&gt;  &lt;br&gt; " id="1096" linkTypes="1" links="658" title="todo.py" />
<node body="Supports outline-based calculations similar to spreadsheets. &lt;br&gt; " id="1097" linkTypes="1" links="658" title="valuespace.py" />
<node body="Creates a window for *live* rendering of rst, html, etc.  Qt only. &lt;br&gt; Supports @graphics-script, @image, @html, @movie and @svg nodes. &lt;br&gt;  &lt;br&gt; viewrendered.py creates a single ``Alt-X`` style command, ``viewrendered``, &lt;br&gt; which opens a new window where the current body text is rendered as HTML &lt;br&gt; (if it starts with '&lt;'), or otherwise reStructuredText.  reStructuredText &lt;br&gt; errors and warnings may be shown.  For example, both:: &lt;br&gt;  &lt;br&gt;     Heading &lt;br&gt;     ------- &lt;br&gt;  &lt;br&gt;     `This` is **really** a line of text. &lt;br&gt;  &lt;br&gt; and:: &lt;br&gt;  &lt;br&gt;     &lt;h1&gt;Heading&lt;h1&gt; &lt;br&gt;  &lt;br&gt;     &lt;tt&gt;This&lt;/tt&gt; is &lt;b&gt;really&lt;/b&gt; a line of text. &lt;br&gt;  &lt;br&gt; will look something like: &lt;br&gt;  &lt;br&gt; **Heading** &lt;br&gt;  &lt;br&gt; `This` is **really** a line of text. &lt;br&gt;  &lt;br&gt; " id="1098" linkTypes="1" links="658" title="viewrendered.py" />
<node body="https://groups.google.com/d/msg/leo-editor/3dH_NSQ4TsQ/ueVewAn50ZcJ &lt;br&gt;  &lt;br&gt; https://groups.google.com/d/msg/leo-editor/BDzmytlSegw/C0IbSz0US54J &lt;br&gt;  &lt;br&gt; As mentioned in my previous post I'll attempt to elaborate on the plugin &lt;br&gt; I've used to make Leo more useful to me, in case it is useful for others &lt;br&gt; also. Apologies for the very long post, but I wanted get get all its &lt;br&gt; features and warts exposed here to get some feedback on whether others see &lt;br&gt; this as useful or that this is only valuable to me. If it's useful to &lt;br&gt; others then it may be worth polishing up quite a bit. &lt;br&gt; " id="1099" linkTypes="3 3 3 3 3" links="1350 1351 1352 1353 1354" title="viewrendered2.py" />
<node body="When focus is in the outline pane:: &lt;br&gt;  &lt;br&gt;     Right-arrow (expand-and-go-right) &lt;br&gt;     Left-arrow (contract-or-go-left) &lt;br&gt;     Up-arrow (goto-prev-visible)  &lt;br&gt;     Down-arrow (goto-next-visible) &lt;br&gt;      &lt;br&gt; Regardless of focus:: &lt;br&gt;  &lt;br&gt;     Alt-Home (goto-first-visible-node)  &lt;br&gt;     Alt-End (goto-last-visible-node) &lt;br&gt;     Alt-Right-arrow (expand-and-go-right) &lt;br&gt;     Alt-Left-arrow (contract-or-go-left) &lt;br&gt;     Alt-Up-arrow (goto-prev-visible)  &lt;br&gt;     Alt-Down-arrow (goto-next-visible) &lt;br&gt; " id="1100" linkTypes="1" links="659" title="Selecting outline nodes" />
<node body="When focus is in the outline:: &lt;br&gt;  &lt;br&gt;     Shift-Down-arrow (move-outline-down)  &lt;br&gt;     Shift-Left-arrow (move-outline-left)  &lt;br&gt;     Shift-Right-arrow (move-outline-right)  &lt;br&gt;     Shift-Up-arrow (move-outline-up) &lt;br&gt;  &lt;br&gt; Regardless of focus:: &lt;br&gt;  &lt;br&gt;     Alt-Shift-Down-arrow (move-outline-down)  &lt;br&gt;     Alt-Shift-Left-arrow (move-outline-left)  &lt;br&gt;     Alt-Shift-Right-arrow (move-outline-right)  &lt;br&gt;     Alt-Shift-Up-arrow (move-outline-up) &lt;br&gt;     Ctrl-D (move-outline-down) &lt;br&gt;     Ctrl-L (move-outline-left)  &lt;br&gt;     Ctrl-R (move-outline-right) &lt;br&gt;     Ctrl-U (move-outline-up) &lt;br&gt; " id="1101" linkTypes="1" links="659" title="Moving outline nodes" />
<node body="When focus is in any of Leo's text panes (body pane, log pane, headlines):: &lt;br&gt;  &lt;br&gt;     Arrows            move one character &lt;br&gt;     Ctrl-LeftArrow    back one word &lt;br&gt;     Ctrl-RightArrow   forward one word &lt;br&gt;     Home              beginning of line &lt;br&gt;     End               end of line &lt;br&gt;     Ctrl-Home         beginning of the body &lt;br&gt;     Ctrl-End          end of body &lt;br&gt;     PageDown          down one page &lt;br&gt;     PageUp            up one page &lt;br&gt;  &lt;br&gt; **Shift keys**: Adding the Shift key modifier to any of the keys above moves the cursor and extends the selected text. &lt;br&gt;  &lt;br&gt; " id="1102" linkTypes="1" links="659" title="Moving the cursor" />
<node body="``cut-text (Ctrl-X)`` &lt;br&gt;     Cut the selected text and put it to the clipboard. &lt;br&gt; ``copy-text (Ctrl-C)`` &lt;br&gt;     Copy the selected text to the clipboard. &lt;br&gt; ``paste-text (Ctrl-V)`` &lt;br&gt;     Paste test from the clipboard. &lt;br&gt; ``select-all(Ctrl-A)`` &lt;br&gt;     Select all text in the text pane. &lt;br&gt;  &lt;br&gt; These commands work with either headline or body text." id="1103" linkTypes="1" links="662" title="Cutting, pasting and selecting text" />
<node body="``indent-region (Tab)``  &lt;br&gt;     Shift selected lines right one tab position. Inserts one unit of indentation if no text is selected. &lt;br&gt; ``unindent-region (Shift-Tab)`` &lt;br&gt;     Shifts selected lines left one tab position. Deletes one unit of indentation if no text is selected. &lt;br&gt;      &lt;br&gt; **Notes**: &lt;br&gt;  &lt;br&gt; - These commands shift the entire line if any characters in that line are selected. If no text is selected. &lt;br&gt;  &lt;br&gt; - The @tabwidth directive determines which characters these commands insert or delete. &lt;br&gt;  &lt;br&gt; - Leo auto indents unless @nocolor is in effect.  Typing a newline automatically inserts the same leading whitespace present on the previous line. &lt;br&gt;  &lt;br&gt; - If Python is the present language, Leo inserts an additional tab if the previous line ends with a colon.  When the ``smart_auto_indent setting`` is True, Leo uses Emacs-style auto-indentation instead.  This style of auto-indent aligns newly created lines with unmatched ``( [{`` brackets in the previous line. &lt;br&gt; " id="1104" linkTypes="1" links="662" title="Indenting body text" />
<node body="``add-comments (Ctrl-))`` &lt;br&gt;     Adds comments to the selected lines, using single-line comments if possible. &lt;br&gt; ``delete-comments (Ctrl-()`` &lt;br&gt;     Deletes comments in the selected lines. &lt;br&gt; " id="1105" linkTypes="1" links="662" title="Adding and deleting comments in body text" />
<node body="``goto-global-line (Alt-G)`` &lt;br&gt;     Selects the locations in your outlines corresponding to a line in a external file. &lt;br&gt; ``match-brackets`` &lt;br&gt;     Enabled if the cursor is next to one of these characters in the body pane: ``( ) [ ] { } &lt; &gt;`` The command looks for the matching character, searching backwards through the body text if the cursor is next to ``)`` ``]`` ``}`` or ``&gt;`` and searching forward through the text otherwise. If the cursor is between two brackets the search is made for the bracket matching the leftmost bracket. If a match is found, the entire range of characters delimited by the brackets is highlighted and the cursor is placed just to the left of the matching characters. Thus, executing this command twice highlights the range of matched characters without changing the cursor. &lt;br&gt; " id="1106" linkTypes="1" links="662" title="Moving the cursor" />
<node body=".. _`Python's time module`: http://www.python.org/doc/current/lib/module-time.html &lt;br&gt;  &lt;br&gt; ``clean-lines`` &lt;br&gt;     Removes trailing whitespace from all lines, preserving newlines. &lt;br&gt; ``clear-selected-text`` &lt;br&gt;     Delete the selected text. &lt;br&gt; ``convert-tabs`` &lt;br&gt;     Converts leading tabs to blanks in a single node. &lt;br&gt; ``convert-blanks`` &lt;br&gt;     Converts blanks to tabs in a single node. &lt;br&gt; ``convert-all-tabs`` &lt;br&gt;     Converts leading tabs to blanks throughout the selected tree. &lt;br&gt; ``convert-all-blanks`` &lt;br&gt;     Converts leading blanks to tabs throughout the selected tree. &lt;br&gt;      &lt;br&gt; **@tabwidth**: The ``convert-*`` commands convert between tabs and blanks using the @tabwidth setting presently in effect. &lt;br&gt;  &lt;br&gt; ``flush-lines`` &lt;br&gt;     Deletes each line that contains a match for regexp, operating on the text after point. &lt;br&gt;     In Transient Mark mode, if the region is active, the command operates on the region instead. &lt;br&gt;  &lt;br&gt; ``insert-body-time`` and ``insert-headline-time`` &lt;br&gt;     Insert formatted time and date into body or headline text. You must be editing a headline to be able to insert the time/date into the headline. The body_time_format_string and headline_time_format_string settings specify the format of the inserted text. These settings are the format string passed to time.strftime. &lt;br&gt;      &lt;br&gt; **Time format**: For format options see `Python's time module`_. By default, the commands use ``%m/%d/%Y %H:%M:%S``, giving timestamps like ``1/30/2003 8:31:55``. &lt;br&gt;  &lt;br&gt; ``keep-lines`` &lt;br&gt;     Deletes each line that does not contain a match for regexp, operating on the text after point. In Transient Mark mode, if the region is active, the command operates on the region instead.  &lt;br&gt;  &lt;br&gt; ``pretty-print-python-code`` and ``pretty-print-all-python-code`` &lt;br&gt;     Pretty prints body text. You can customize this code by overriding the following methods of class prettyPrinter in leoCommands.py:: &lt;br&gt;  &lt;br&gt;         putOperator:      puts whitespace around operators. &lt;br&gt;         putNormalToken:   puts whitespace around everything else. &lt;br&gt;  &lt;br&gt; ``reformat-paragraph (Ctrl-Shift-P)`` &lt;br&gt;     Rearranges the words in a text paragraph to fill each line as full as possible, up to the @pagewidth setting. A paragraph is delimited by blank lines, Leo directives, and (of course) start and end of text in a node. The width of the line used by the reformatting operation is governed by @pagewidth and the indentation that would be applied to the node when Leo writes the file. &lt;br&gt;  &lt;br&gt; The command operates on the paragraph containing the insert cursor. If the insert cursor is on a blank line or directive, nothing happens. If the cursor is on a line containing text, then the paragraph containing that text line is reformatted and the insert cursor is moved to the next paragraph. &lt;br&gt;  &lt;br&gt; **Note**: Hanging indentation is preserved. This is most useful for bulleted or numbered lists, such as:: &lt;br&gt;  &lt;br&gt;   1. This is the first paragraph, &lt;br&gt;      and it has a hanging indentation. &lt;br&gt;  &lt;br&gt;   2. This is the second paragraph, &lt;br&gt;      and it too has a hanging indentation. &lt;br&gt;       &lt;br&gt; ``replace-current-character`` &lt;br&gt;      Replace the selected character with the next character typed. &lt;br&gt; ``toggle-angle-brackets`` &lt;br&gt;     Adds or removes double angle brackets from the headline of the selected node. &lt;br&gt; ``unformat-paragraph (Ctrl-Shift-U)`` &lt;br&gt;     Removes all extra whitespace from a paragraph, including leading whitespace.  This command is useful when @wrap is in effect. &lt;br&gt; " id="1107" linkTypes="1" links="662" title="Text formatting commands" />
<node body="``extract (Ctrl-Shift-D)`` &lt;br&gt;     Creates a new node whose headline is the first line of selected body text and whose body is all other lines of selected text. Previously selected text is deleted from the original body text. &lt;br&gt; ``extract-names (Ctrl-Shift-N)`` &lt;br&gt;     Creates one or more child nodes, one for each section name in the selected body text. The headline of each created node is the section name. &lt;br&gt; " id="1108" linkTypes="1" links="662" title="Creating nodes from body text" />
<node body="``execute-script (Ctrl-B)`` &lt;br&gt;     Executes body text as a Python script. Leo execute the selected text, or the entire body text if no text is selected. The Execute Script command pre-defines the values c, g and p as follows: &lt;br&gt;  &lt;br&gt; - c is the commander of the outline containing the script. &lt;br&gt; - g is the leoGlobals modules. &lt;br&gt; - p is c.p, that is, c.currentPosition(). &lt;br&gt;  &lt;br&gt; **Important**: Body text may contain Leo directives and section references. You can use all of Leo's features to organize scripts that you execute interactively. Section definitions must appear in the node containing the script or in descendant nodes. &lt;br&gt;  &lt;br&gt; Leo preprocesses all scripts by simulating the writing of a external file to a string. The ``execute-script`` command sets app.scriptDict[&quot;script1&quot;] to the value of the script before preprocessing, and sets app.scriptDict[&quot;script2&quot;] to the value of the script after preprocessing. Scripts may examine and change app.scriptDict as they please. &lt;br&gt; " id="1109" linkTypes="1" links="662" title="Executing Python scripts in body text" />
<node body="``add-editor`` &lt;br&gt;     Adds a new editor in the body pane and gives it the body editor focus. &lt;br&gt; ``delete-editor`` &lt;br&gt;     Deletes the editor with body editor focus. &lt;br&gt; ``cycle-editor-focus`` &lt;br&gt;     Cycles body editor focus between editors in the body text. The editor that has focus shows the content of the selected outline node; the other body editors continue to show the node contents they last had when they had the body editor focus. &lt;br&gt; " id="1110" linkTypes="1" links="662" title="Multiple body editors" />
<node body="Leo supports unlimited undo and redo with the ``undo`` (Ctrl-Z) and ``redo`` (Ctrl-Shift-Z) commands. Think of actions that may be undone or redone as a string of beads. A &quot;bead pointer&quot; points to the present bead. Performing an operation creates a new bead after the present bead and removes all following beads. Undoing an operation moves the bead pointer backwards; redoing an operation moves the bead pointer forwards. The ``undo`` command is disabled when the bead pointer moves in front of the first bead; the ``redo`` command is disabled when the bead pointer points to the last bead. &lt;br&gt;  &lt;br&gt; The @string undo_granularity setting controls the granularity of undo. There are four possible values: &lt;br&gt;  &lt;br&gt; ``node`` &lt;br&gt;     Starts a new undo unit when typing moves to a new node. &lt;br&gt;  &lt;br&gt; ``line (default)`` &lt;br&gt;     Starts a new undo unit when typing moves to new line. &lt;br&gt;  &lt;br&gt; ``word`` &lt;br&gt;     Starts a new undo unit when typing starts a new word. &lt;br&gt;  &lt;br&gt; ``char`` (not recommended) &lt;br&gt;     Starts a new undo unit for each character typed. &lt;br&gt;     This wastes lots of computer memory. &lt;br&gt; " id="1111" linkTypes="1" links="662" title="Undoing changes" />
<node body="**Important**: The following describes Leo's new abbreviation scheme.  Such abbreviations *fire immediately* whenever they are completed. You do *not* have to execute a command!  By convention, abbreviations end with ``;;``, something you are not likely to type by accident, but you can pick any abbreviation you like. &lt;br&gt;  &lt;br&gt; **Note**: &lt;br&gt;  &lt;br&gt; 1. The @data abbreviations-subst-env node contains a script defining the environment in which all abbreviations execute. This allows helper functions to be defined. Very handy. &lt;br&gt;     &lt;br&gt; 2. Scripts may span multiple lines. Line starting with &quot;\:&quot; (2 characters) continue a script. This allows abbreviations to define multi-line templates.  Helpers defined in @data abbreviations-subst-env can fill in templates with *calculated* (not predefined) data. &lt;br&gt;     &lt;br&gt; 3. Templates may contain placeholders that the user can fill in.  By default, the double comma binding selects the next placeholder. &lt;br&gt;  &lt;br&gt; 4. Added a new setting: @bool scripting-abbreviations, default False. Scripting abbreviations will be enabled if *either* of the following is True:: &lt;br&gt;  &lt;br&gt;     @bool scripting-abbreviations &lt;br&gt;     @bool scripting-at-script-nodes &lt;br&gt;      &lt;br&gt; This is a safety feature: it allows scripting abbreviations to be enabled *without* enabling the (very dangerous in general) scripting-at-script-nodes setting. &lt;br&gt;  &lt;br&gt; 5. Added a new example node: @@data abbreviations examples.  This contains &lt;br&gt;    several extremely useful scripts. &lt;br&gt;     &lt;br&gt; .. _`Emacs-like abbreviation commands`: http://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html#Abbrevs &lt;br&gt;  &lt;br&gt; Leo also supports `Emacs-like abbreviation commands`_, but they are seldom used:: &lt;br&gt;  &lt;br&gt;     abbrev-add-global &lt;br&gt;     abbrev-inverse-add-global &lt;br&gt;     abbrev-kill-all &lt;br&gt;     abbrev-list &lt;br&gt;     abbrev-read &lt;br&gt;     abbrev-write &lt;br&gt;     dabbrev-completion &lt;br&gt;     dabbrev-expands &lt;br&gt;  &lt;br&gt; " id="1112" linkTypes="1" links="663" title="Abbreviation commands" />
<node body=".. _`Emacs buffer commands`: http://www.gnu.org/software/emacs/manual/html_node/emacs/Buffers.html#Buffers &lt;br&gt;  &lt;br&gt; The following work like some of the many `Emacs buffer commands`_.  A **buffer** in Leo is simply a Leo node:: &lt;br&gt;  &lt;br&gt;     buffer-append-to &lt;br&gt;     buffer-kill &lt;br&gt;     buffer-prepend-to &lt;br&gt;     buffer-switch-to &lt;br&gt;     buffers-list &lt;br&gt;     buffers-list-alphabetically &lt;br&gt; " id="1113" linkTypes="1" links="663" title="Buffer commands" />
<node body=".. _`Emacs cursor commands`: http://www.gnu.org/software/emacs/manual/html_node/emacs/Moving-Point.html#Moving-Point &lt;br&gt;  &lt;br&gt; **Smart cursor moves**: Many editors allow you to jump over, select and delete words, especially those containing or surrounded by special characters, in a smarter way than just &quot;going to the beginning of the word before&quot; (back-word) or &quot;going to the end of the next word&quot; (forward-word):: &lt;br&gt;  &lt;br&gt;     back-word-smart &lt;br&gt;     back-word-smart-extend-selection &lt;br&gt;     forward-word-smart &lt;br&gt;     forward-word-smart-extend-selection &lt;br&gt;     delete-word-smart &lt;br&gt;     backward-delete-word-smart &lt;br&gt;      &lt;br&gt; The following commands work much like the `Emacs cursor commands`_:: &lt;br&gt;  &lt;br&gt;     back-char &lt;br&gt;     back-char-extend-selection &lt;br&gt;     back-page &lt;br&gt;     back-page-extend-selection &lt;br&gt;     back-paragraph &lt;br&gt;     back-paragraph-extend-selection &lt;br&gt;     back-sentence &lt;br&gt;     back-sentence-extend-selection &lt;br&gt;     back-to-home &lt;br&gt;     back-to-home-extend-selection &lt;br&gt;     back-to-indentation &lt;br&gt;     back-word-extend-selection &lt;br&gt;     backward-delete-char &lt;br&gt;     backward-find-character &lt;br&gt;     backward-find-character-extend-selection &lt;br&gt;     backward-kill-paragraph &lt;br&gt;     backward-kill-sentence &lt;br&gt;     backward-kill-word &lt;br&gt;     beginning-of-buffer &lt;br&gt;     beginning-of-buffer-extend-selection &lt;br&gt;     beginning-of-line &lt;br&gt;     beginning-of-line-extend-selection &lt;br&gt;     end-of-buffer &lt;br&gt;     end-of-buffer-extend-selection &lt;br&gt;     end-of-line &lt;br&gt;     end-of-line-extend-selection &lt;br&gt;     find-character &lt;br&gt;     find-character-extend-selection &lt;br&gt;     find-word-in-line &lt;br&gt;     forward-char &lt;br&gt;     forward-char-extend-selection &lt;br&gt;     forward-end-word &lt;br&gt;     forward-end-word-extend-selection &lt;br&gt;     forward-page &lt;br&gt;     forward-page-extend-selection &lt;br&gt;     forward-paragraph &lt;br&gt;     forward-paragraph-extend-selection &lt;br&gt;     forward-sentence &lt;br&gt;     forward-sentence-extend-selection &lt;br&gt;     forward-word-extend-selection &lt;br&gt;     move-past-close &lt;br&gt;     move-past-close-extend-selection &lt;br&gt;     next-line &lt;br&gt;     next-line-extend-selection &lt;br&gt;     previous-line &lt;br&gt;     previous-line-extend-selection &lt;br&gt; " id="1114" linkTypes="1" links="663" title="Cursor movement commands" />
<node body="The following commands typically work like the corresponding Emacs command. For details about any command use ``F11 (help-for-command)``:: &lt;br&gt;  &lt;br&gt;     add-space-to-lines &lt;br&gt;     add-tab-to-lines &lt;br&gt;     align-eq-signs &lt;br&gt;     auto-complete &lt;br&gt;     auto-complete-force &lt;br&gt;     capitalize-word &lt;br&gt;     center-line &lt;br&gt;     center-region &lt;br&gt;     clear-kill-ring &lt;br&gt;     count-pages &lt;br&gt;     count-region &lt;br&gt;     delete-char &lt;br&gt;     delete-indentation &lt;br&gt;     delete-spaces &lt;br&gt;     downcase-region &lt;br&gt;     downcase-word &lt;br&gt;     exchange-point-mark &lt;br&gt;     extend-to-line &lt;br&gt;     extend-to-paragraph &lt;br&gt;     extend-to-sentence &lt;br&gt;     extend-to-word &lt;br&gt;     fill-paragraph &lt;br&gt;     fill-region &lt;br&gt;     fill-region-as-paragraph &lt;br&gt;     hide-invisibles &lt;br&gt;     how-many &lt;br&gt;     indent-relative &lt;br&gt;     indent-rigidly &lt;br&gt;     indent-to-comment-column &lt;br&gt;     insert-child &lt;br&gt;     insert-file-name &lt;br&gt;     insert-file-name &lt;br&gt;     insert-hard-tab &lt;br&gt;     insert-newline &lt;br&gt;     insert-parentheses &lt;br&gt;     insert-soft-tab &lt;br&gt;     join-node-above &lt;br&gt;     join-node-below &lt;br&gt;     join-selection-to-node-below &lt;br&gt;     line-number &lt;br&gt;     move-lines-down &lt;br&gt;     move-lines-up &lt;br&gt;     newline-and-indent &lt;br&gt;     open-url &lt;br&gt;     open-url-under-cursor &lt;br&gt;     remove-blank-lines &lt;br&gt;     remove-newlines &lt;br&gt;     remove-space-from-lines &lt;br&gt;     remove-tab-from-lines &lt;br&gt;     reverse-region &lt;br&gt;     reverse-sort-lines &lt;br&gt;     reverse-sort-lines-ignoring-case &lt;br&gt;     select-to-matching-bracket &lt;br&gt;     set-fill-column &lt;br&gt;     set-fill-prefix &lt;br&gt;     shell-command &lt;br&gt;     shell-command-on-region &lt;br&gt;     show-invisibles &lt;br&gt;     set-comment-column &lt;br&gt;     sort-columns &lt;br&gt;     sort-fields &lt;br&gt;     sort-lines &lt;br&gt;     sort-lines-ignoring-case &lt;br&gt;     split-line &lt;br&gt;     tabify &lt;br&gt;     transpose-chars &lt;br&gt;     transpose-lines &lt;br&gt;     transpose-words &lt;br&gt;     untabify &lt;br&gt;     upcase-region &lt;br&gt;     upcase-word &lt;br&gt;     view-lossage &lt;br&gt;     what-line &lt;br&gt; " id="1115" linkTypes="1" links="663" title="Emacs text formatting" />
<node body=".. _`Emacs macro commands`: http://www.gnu.org/software/emacs/manual/html_node/emacs/Keyboard-Macros.html#Keyboard-Macros &lt;br&gt;  &lt;br&gt; The following commands emulate the `Emacs macro commands`_:: &lt;br&gt;  &lt;br&gt;     macro-call &lt;br&gt;     macro-call-last &lt;br&gt;     macro-end-recording &lt;br&gt;     macro-load-all &lt;br&gt;     macro-name-last &lt;br&gt;     macro-print-all &lt;br&gt;     macro-print-last &lt;br&gt;     macro-save-all &lt;br&gt;     macro-start-recording &lt;br&gt; " id="1116" linkTypes="1" links="663" title="Macro commands" />
<node body=".. _`Emacs rectangle commands`: http://www.gnu.org/software/emacs/manual/html_node/emacs/Rectangles.html &lt;br&gt;  &lt;br&gt; The following commands emulate the `Emacs rectangle commands`_:: &lt;br&gt;  &lt;br&gt;     rectangle-clear &lt;br&gt;     rectangle-close &lt;br&gt;     rectangle-delete &lt;br&gt;     rectangle-kill &lt;br&gt;     rectangle-open &lt;br&gt;     rectangle-string &lt;br&gt;     rectangle-yank &lt;br&gt;  &lt;br&gt; Given:: &lt;br&gt;  &lt;br&gt;     I'm really glad the docs are being updated. I know that's a &lt;br&gt;     monumental task. I only use a fraction of Leo's commands, mostly &lt;br&gt;     because I don't even know what they're supposed to accomplish. A few &lt;br&gt;     examples: &lt;br&gt;  &lt;br&gt; Placing the cursor immediately before the first &quot;I&quot;, holding shift and moving it to immediately before the word``examples`` selects a zero width rectangle from the beginning to the end of the selection (zero width because the selection starts and ends in the same column.  Then running ``rectangle-string [largo]&lt;space&gt;&lt;enter&gt;`` yields:: &lt;br&gt;  &lt;br&gt;   [largo] I'm really glad the docs are being updated. I know that's a &lt;br&gt;   [largo] monumental task. I only use a fraction of Leo's commands, mostly &lt;br&gt;   [largo] because I don't even know what they're supposed to accomplish. A few &lt;br&gt;   [largo] examples: &lt;br&gt; " id="1117" linkTypes="1" links="663" title="Rectangle commands" />
<node body=".. _`Emacs register commands`: http://www.gnu.org/software/emacs/manual/html_node/emacs/Registers.html#Registers &lt;br&gt;  &lt;br&gt; The following commands emulate `Emacs register commands`_:: &lt;br&gt;  &lt;br&gt;     register-append-to &lt;br&gt;     register-copy-rectangle-to &lt;br&gt;     register-copy-to &lt;br&gt;     register-increment &lt;br&gt;     register-insert &lt;br&gt;     register-jump-to &lt;br&gt;     register-point-to &lt;br&gt;     register-prepend-to &lt;br&gt;     register-view &lt;br&gt; " id="1118" linkTypes="1" links="663" title="Register commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     scroll-down &lt;br&gt;     scroll-down-extend-selection &lt;br&gt;     scroll-up &lt;br&gt;     scroll-up-extend-selection &lt;br&gt;  &lt;br&gt;     scroll-down-half-page &lt;br&gt;     scroll-down-line &lt;br&gt;     scroll-down-page &lt;br&gt;     scroll-up-half-page &lt;br&gt;     scroll-up-line &lt;br&gt;     scroll-up-page &lt;br&gt;  &lt;br&gt;     scroll-outline-down-line        &lt;br&gt;     scroll-outline-down-page        &lt;br&gt;     scroll-outline-up-line        &lt;br&gt;     scroll-outline-up-page &lt;br&gt;     scroll-outline-left &lt;br&gt;     scroll-outline-right &lt;br&gt;  &lt;br&gt; " id="1119" linkTypes="1" links="663" title="Scrolling the outline pane" />
<node body="The following commands typically work like the corresponding Emacs command. For details about any command use ``F11 (help-for-command)``:: &lt;br&gt;  &lt;br&gt;     backward-delete-char &lt;br&gt;     backward-find-character &lt;br&gt;     backward-find-character-extend-selection &lt;br&gt;     backward-kill-paragraph &lt;br&gt;     backward-kill-sentence &lt;br&gt;     backward-kill-word &lt;br&gt;     kill-line &lt;br&gt;     kill-paragraph &lt;br&gt;     kill-region &lt;br&gt;     kill-region-save &lt;br&gt;     kill-sentence &lt;br&gt;     kill-to-end-of-line &lt;br&gt;     kill-word &lt;br&gt;     kill-ws &lt;br&gt;     yank &lt;br&gt;     yank-pop &lt;br&gt;     zap-to-character &lt;br&gt; " id="1120" linkTypes="1" links="663" title="Yank, kill &amp; delete commands" />
<node body="``file-open-by-name`` &lt;br&gt;     Gets the name of a Leo outline from the minibuffer and opens it. File name completion is supported. &lt;br&gt; ``new (Ctrl-N)`` &lt;br&gt;     Creates a new Leo main window. &lt;br&gt; ``open-outline (Ctrl-O)`` &lt;br&gt;     Opens an existing .leo file. Selecting a non-.leo file loads the file into an @edit node in the present outline. &lt;br&gt; ``open-outline-by-name`` &lt;br&gt;     Opens the file given by typing the filename in the minibuffer. Supports filename completion. &lt;br&gt; ``read-outline-only`` &lt;br&gt;     Reads only the .leo file, not any external files. &lt;br&gt; ``revert`` &lt;br&gt;     Reloads the outline, discarding any changes made since it was last saved. &lt;br&gt; ``save-all`` &lt;br&gt;     Saves all open tabs windows/tabs.  &lt;br&gt; ``save-buffers-kill-leo`` &lt;br&gt;     Quits Leo, prompting to save any unsaved files first.  &lt;br&gt; ``save-file or file-save (Ctrl-S)`` &lt;br&gt;     Saves the Leo window to a file. &lt;br&gt; ``save-file-as`` &lt;br&gt;     Saves a copy of the Leo outline, changing outline's file name. &lt;br&gt; ``save-file-to`` &lt;br&gt;     Saves a copy of the Leo outline, without changing the outline's file name &lt;br&gt; ``save-file-as-zipped`` &lt;br&gt;     Same as ``save-file-as``, compressing the .leo file with Python's zipfile module. &lt;br&gt; ``save-file-as-unzipped`` &lt;br&gt;     Same as ``save-as``, suppressing compression. &lt;br&gt;  &lt;br&gt;  &lt;br&gt; **About compression**: The ``save-file``, ``save-file-as`` and ``save-file-to`` commands compress the file if it was originally compressed. Leo always uses the .leo extension, regardless of whether the file is zipped. Zipped .leo files contain a single archive, whose name is the same as the .leo file itself. Outside of Leo you can change the extension to .leo.zip and use stuffit or other program to expand the .leo file contained within. &lt;br&gt;  &lt;br&gt; **Opening specific files**: &lt;br&gt;  &lt;br&gt; ``open-cheat-sheet-leo`` &lt;br&gt;     Opens CheatSheet.leo in a new tab or window. &lt;br&gt; ``open-leoDocs-leo`` &lt;br&gt;     Opens LeoDocs.leo in a new tab or window. &lt;br&gt; ``open-leoPlugins-leo`` &lt;br&gt;     Opens LeoPlugins.leo in a new tab or window. &lt;br&gt; ``open-scripts-leo`` &lt;br&gt;     Opens scripts.leo in a new tab or window. &lt;br&gt; ``open-leoSettings-leo`` &lt;br&gt;     Opens LeoSettings.leo in a new tab or window. &lt;br&gt;      &lt;br&gt; **Writing external files without saving the outline**: &lt;br&gt;  &lt;br&gt; ``write-at-auto-nodes`` &lt;br&gt;     Writes all @auto nodes in the selected tree. &lt;br&gt; ``write-outline-only`` &lt;br&gt;     Saves the outline without writing any @&lt;file&gt; trees. &lt;br&gt; ``write-at-file-nodes`` &lt;br&gt;     Writes all @&lt;file&gt; trees. &lt;br&gt; ``write-at-shadow-nodes`` &lt;br&gt;     Writes all @shadow nodes in the selected tree. &lt;br&gt; ``write-dirty-at-file-nodes`` &lt;br&gt;     Writes all modified @&lt;file&gt; trees. &lt;br&gt; ``write-dirty-at-shadow-nodes`` &lt;br&gt;     Writes all modified @shadow trees. &lt;br&gt; ``write-missing-at-file-nodes`` &lt;br&gt;     Write all @&lt;file&gt; nodes for which the corresponding external file does not exist. &lt;br&gt; " id="1121" linkTypes="1" links="664" title="Loading, saving &amp; reverting files" />
<node body="``close-others`` &lt;br&gt;     Closes all windows except the present window. &lt;br&gt; ``close-window (Ctrl-F4)`` &lt;br&gt;     Closes the selected Leo window, prompting you to save your work if necessary. &lt;br&gt; ``exit-leo (Ctrl-Q or Alt-F4)`` &lt;br&gt;     Exits Leo, prompting you to save any changed outline. Closing the last outline tab also exits Leo. &lt;br&gt; " id="1122" linkTypes="1" links="664" title="Closing outlines &amp; quitting Leo" />
<node body=".. _CWEB:   http://www-cs-faculty.stanford.edu/~knuth/cweb.html &lt;br&gt; .. _noweb:  http://www.eecs.harvard.edu/~nr/noweb/ &lt;br&gt;  &lt;br&gt; ``export-headlines`` &lt;br&gt;     Exports all headlines to an external file. &lt;br&gt; ``file-insert`` &lt;br&gt;     Prompts for the name of a file and put the selected text into it. &lt;br&gt; ``flatten-outline`` &lt;br&gt;     Creates a text file in MORE format from the selected outline. &lt;br&gt; ``import-file`` &lt;br&gt;     Import a file into an @file node. This command handles files regardless of whether they contain sentinels. This command can also read files in MORE outline format. &lt;br&gt; ``import-zim-folder`` &lt;br&gt;     Imports a zim folder, http://zim-wiki.org/, as the last top-level node of the outline. This command uses the following Leo settings:: &lt;br&gt;      &lt;br&gt;         @int rst_level = 0 &lt;br&gt;         @string rst_type &lt;br&gt;         @string zim_node_name &lt;br&gt;         @string path_to_zim &lt;br&gt;  &lt;br&gt; ``outline-to-cweb`` &lt;br&gt;     Creates a `CWEB`_ file from the selected outline. &lt;br&gt; ``outline-to-noweb`` &lt;br&gt;     Creates a `noweb`_ file from the selected outline. &lt;br&gt; ``read-at-auto-nodes`` &lt;br&gt;     Reads all @auto nodes in the presently selected outline.  &lt;br&gt; ``read-at-shadow-nodes`` &lt;br&gt;     Reads all @shadow nodes in the presently selected outline. &lt;br&gt; ``read-at-file-nodes`` &lt;br&gt;     Updates all @&lt;file&gt; nodes in an outline. &lt;br&gt; ``read-file-into-node`` &lt;br&gt;     Prompts for a filename, creates a new node and puts the contents of the file into its body text. &lt;br&gt; ``refresh-from-disk`` &lt;br&gt;     Refreshes an @&lt;file&gt; node from disk.  &lt;br&gt; ``remove-sentinels`` &lt;br&gt;     Removes all sentinel lines from a file derived from an @file node. &lt;br&gt; ``weave`` &lt;br&gt;     Formats the selected text and writes it to a file.  &lt;br&gt; ``write-file-from-node`` &lt;br&gt;     Writes the body text of the selected node to a file. The command prompts for a file name if the node is not an @&lt;file&gt; node. &lt;br&gt; " id="1123" linkTypes="1" links="664" title="Importing &amp; exporting files" />
<node body="``session-clear`` &lt;br&gt;     Closes all tabs except the presently selected tab.  &lt;br&gt; ``session-create`` &lt;br&gt;     Creates a new @session node.  &lt;br&gt; ``session-refresh`` &lt;br&gt;     Refreshes the current @session node.  &lt;br&gt; ``session-restore`` &lt;br&gt;     Opens a tab for each item the selected @session node. &lt;br&gt; ``session-snapshot-load`` &lt;br&gt;     Loads a snapshot of a session from the leo.session file.  &lt;br&gt; ``session-snapshot-save`` &lt;br&gt;     Saves a snapshot of the present session to the leo.session file. &lt;br&gt;  &lt;br&gt; **About sessions**: An @session node specifies a list of tabs (.leo files) that Leo opens automatically when Leo first starts. The ``--session-save`` and ``--session-restore`` command-line options write and read @session nodes from the leo.session file. The next time Leo is started with those options, the files will be open, and the nodes focused as when the previous session ended. &lt;br&gt; " id="1124" linkTypes="1" links="664" title="Using sessions" />
<node body=".. _`Idle`: http://en.wikipedia.org/wiki/IDLE_%28Python%29 &lt;br&gt; .. _`Open Office`: https://www.openoffice.org/ &lt;br&gt; .. _`SciTe`: http://www.scintilla.org/SciTE.html &lt;br&gt;  &lt;br&gt; ``cm-external-editor`` &lt;br&gt;     Open the selected node in the external editor specified by the ``LEO_EDITOR/EDITOR`` environment variable. &lt;br&gt; ``open-with-idle`` &lt;br&gt;     Open the selected node in `Idle`_. &lt;br&gt; ``open-with-open office`` &lt;br&gt;     Open the selected node in `Open Office`_. &lt;br&gt; ``open-with-scite`` &lt;br&gt;     Open the selected node in `SciTe`_. &lt;br&gt; ``open-with-word`` &lt;br&gt;     Open the selected node in Word. &lt;br&gt;  &lt;br&gt; **About open-with**: &lt;br&gt;  &lt;br&gt; 1. Leo creates a temporary file and invokes an external program. Leo periodically checks whether this temporary file has changed; Leo changes the corresponding node in the outline if so. You must create the entries using an @openwith node in myLeoSettings.leo. See the documentation there. &lt;br&gt;  &lt;br&gt; 2. All open-with commands require that the corresponding @openwith node correctly specifies an editor." id="1125" linkTypes="1" links="664" title="Communicating with external editors " />
<node body="``directory-make`` &lt;br&gt;     Prompts for the name of a directory and creates it. &lt;br&gt; ``directory-remove`` &lt;br&gt;     Prompts for the name of a directory and deletes it. &lt;br&gt; ``file-delete`` &lt;br&gt;     Prompts for the name of a file and delete it.  &lt;br&gt; " id="1126" linkTypes="1" links="664" title="Creating &amp; deleting directories &amp; files" />
<node body="``clean-recent-files`` &lt;br&gt;     Removes duplicate entries from entries in the Recent Files menu. &lt;br&gt; ``clear-recent-files`` &lt;br&gt;     Deletes all entries in the Recent Files except the most recent file. The files themselves are not affected. &lt;br&gt; ``sort-recent-files`` &lt;br&gt;     Sorts the recent files list in the File menu. &lt;br&gt; " id="1127" linkTypes="1" links="664" title="Managing recent files" />
<node body="The following commands trigger event hooks:: &lt;br&gt;  &lt;br&gt;     click-click-box &lt;br&gt;     click-headline &lt;br&gt;     click-icon-box &lt;br&gt;     ctrl-click-at-cursor &lt;br&gt;     ctrl-click-icon     &lt;br&gt;     double-click-headline &lt;br&gt;     double-click-icon-box # Invokes vim or xemacs plugin if enabled. &lt;br&gt;     simulate-begin-drag &lt;br&gt;     simulate-end-drag &lt;br&gt; " id="1128" linkTypes="1" links="669" title="Event simulation commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     activate-cmds-menu &lt;br&gt;     activate-edit-menu &lt;br&gt;     activate-file-menu &lt;br&gt;     activate-help-menu &lt;br&gt;     activate-outline-menu &lt;br&gt;     activate-plugins-menu &lt;br&gt;     activate-window-menu &lt;br&gt;     cycle-focus &lt;br&gt;     cycle-log-focus &lt;br&gt;     focus-to-body &lt;br&gt;     focus-to-find &lt;br&gt;     focus-to-log &lt;br&gt;     focus-to-minibuffer &lt;br&gt;     focus-to-nav &lt;br&gt;     focus-to-tree &lt;br&gt;     gui-all-hide &lt;br&gt;     gui-all-show &lt;br&gt;     gui-all-toggle &lt;br&gt;     gui-iconbar-hide &lt;br&gt;     gui-iconbar-show &lt;br&gt;     gui-iconbar-toggle &lt;br&gt;     gui-menu-hide &lt;br&gt;     gui-menu-show &lt;br&gt;     gui-menu-toggle &lt;br&gt;     gui-minibuffer-hide &lt;br&gt;     gui-minibuffer-show &lt;br&gt;     gui-minibuffer-toggle &lt;br&gt;     gui-statusbar-hide &lt;br&gt;     gui-statusbar-show &lt;br&gt;     gui-statusbar-toggle &lt;br&gt;     gui-tabbar-hide &lt;br&gt;     gui-tabbar-show &lt;br&gt;     gui-tabbar-toggle &lt;br&gt;     tab-cycle-next &lt;br&gt;     tab-cycle-previous &lt;br&gt;     toggle-active-pane &lt;br&gt; " id="1129" linkTypes="1" links="669" title="Focus commands" />
<node body=":: &lt;br&gt;  &lt;br&gt;     contract-body-pane &lt;br&gt;     contract-log-pane &lt;br&gt;     contract-outline-pane &lt;br&gt;     contract-pane &lt;br&gt;     delete-script-button-button &lt;br&gt;     detach-editor-toggle &lt;br&gt;     detach-editor-toggle-max &lt;br&gt;     equal-sized-panes &lt;br&gt;     expand-body-pane &lt;br&gt;     expand-log-pane &lt;br&gt;     expand-outline-pane &lt;br&gt;     expand-pane &lt;br&gt;     fully-expand-body-pane &lt;br&gt;     fully-expand-log-pane &lt;br&gt;     fully-expand-outline-pane &lt;br&gt;     fully-expand-pane &lt;br&gt;     hide-body-pane &lt;br&gt;     hide-log-pane &lt;br&gt;     hide-outline-pane &lt;br&gt;     hide-pane &lt;br&gt;     iconify-frame  &lt;br&gt;     resize-to-screen &lt;br&gt;     tab-detach &lt;br&gt; " id="1130" linkTypes="1" links="669" title="Pane commands" />
<node body="``clone-node (Ctrl-\`)`` (Grave accent, not a single quote) &lt;br&gt;     Creates a clone as the immediate sibling of a selected node. &lt;br&gt; ``clone-node-to-last-node`` &lt;br&gt;     Creates a clone as the last top-level node of the outline. &lt;br&gt; ``insert-node (Ctrl-I or Insert)`` &lt;br&gt;     Inserts a new node into the outline.  The new node becomes the first child of the present node if the present node is expanded.  Otherwise, the new node becomes the next sibling of the present node. &lt;br&gt; ``insert-node-before`` &lt;br&gt;     Inserts a node before the presently selected node. &lt;br&gt; ``delete-node`` &lt;br&gt;     Deletes a node and all its descendants. &lt;br&gt; " id="1131" linkTypes="1" links="670" title="Creating, cloning &amp; destroying nodes" />
<node body="``contract-all (Alt-hyphen)`` &lt;br&gt;     Contracts every node in the outline. &lt;br&gt; ``contract-all-other-nodes`` &lt;br&gt;     Contract all nodes except the parents of the selected node. &lt;br&gt; ``contract-node`` &lt;br&gt;     Contracts a node. &lt;br&gt; ``contract-or-go-left (Alt-Left)`` &lt;br&gt;     Contract the node if it is expanded.  Otherwise, select the node's parent. &lt;br&gt; ``contract-parent`` &lt;br&gt;     Select the parent of the selected node and contract it. &lt;br&gt; ``expand-all`` &lt;br&gt;     Expands every node in the outline. &lt;br&gt; ``expand-node`` &lt;br&gt;     Expands a node. &lt;br&gt; ``expand-and-go-right (Alt-Right)`` &lt;br&gt;     Expands a node if not expanded.  Otherwise, selects the first child if there is one. &lt;br&gt; ``expand-all-subheads`` &lt;br&gt;     Expand all the direct children of the selected node. &lt;br&gt; ``expand-ancestors-only`` &lt;br&gt;     Expand all the ancestors of the selected node. &lt;br&gt;  &lt;br&gt; These commands expand all descendants of the selected nodes:: &lt;br&gt;  &lt;br&gt;     expand-next-level &lt;br&gt;     expand-prev-level (reverses expand-next-level) &lt;br&gt;     expand-to-level-1 &lt;br&gt;     expand-to-level-2 &lt;br&gt;     expand-to-level-3 &lt;br&gt;     expand-to-level-4 &lt;br&gt;     expand-to-level-5 &lt;br&gt;     expand-to-level-6 &lt;br&gt;     expand-to-level-7 &lt;br&gt;     expand-to-level-8 &lt;br&gt;     expand-to-level-9 &lt;br&gt; " id="1132" linkTypes="1" links="670" title="Expanding &amp; contracting nodes" />
<node body="``abort-edit-headline`` &lt;br&gt;     Ends editing of the headline, discarding any changes. &lt;br&gt; ``edit-headline`` &lt;br&gt;     Begins editing of the headline of the presently-selected node. &lt;br&gt; ``end-edit-headline`` &lt;br&gt;     Ends editing of the headline. &lt;br&gt; " id="1133" linkTypes="1" links="670" title="Editing headlines" />
<node body="**Arrow keys**: When focus is in the outline pane, you can move about the outline using *plain* arrow keys. Regardless of focus, Alt-Arrow keys select nodes in the outline pane. &lt;br&gt;  &lt;br&gt; ``goto-first-sibling`` &lt;br&gt;     Select the first sibling of the selected node. &lt;br&gt; ``goto-last-sibling`` &lt;br&gt;     Select the last sibling of the selected node. &lt;br&gt;  &lt;br&gt; Similarly, these commands select various nodes in the outline:: &lt;br&gt;  &lt;br&gt;     go-back &lt;br&gt;     go-forward &lt;br&gt;     goto-char &lt;br&gt;     goto-first-node &lt;br&gt;     goto-first-visible-node &lt;br&gt;     goto-last-node &lt;br&gt;     goto-last-visible-node &lt;br&gt;     goto-line &lt;br&gt;     goto-next-changed &lt;br&gt;     goto-next-clone &lt;br&gt;     goto-next-history-node &lt;br&gt;     goto-next-node &lt;br&gt;     goto-next-sibling &lt;br&gt;     goto-next-visible &lt;br&gt;     goto-parent &lt;br&gt;     goto-prev-history-node &lt;br&gt;     goto-prev-node &lt;br&gt;     goto-prev-sibling &lt;br&gt;     goto-prev-visible &lt;br&gt;      &lt;br&gt; ``leoscreen-jump-to-error`` (Unix only) &lt;br&gt;     Jumps to the python error reported in the shell window, if the &lt;br&gt;     file's loaded in the current Leo session. Just looks for a line:: &lt;br&gt;  &lt;br&gt;         File &quot;somefile.py&quot;, line NNN, in xxx &lt;br&gt;  &lt;br&gt;     and looks for a node starting with &quot;@&quot; and ending with &quot;somefile.py&quot;, &lt;br&gt;     then jumps to line NNN in that file. &lt;br&gt; " id="1134" linkTypes="1" links="670" title="Selecting nodes" />
<node body="``copy-node (Ctrl-Shift-C)`` &lt;br&gt;     Copies a node and all its descendants to the clipboard &lt;br&gt; ``cut-node (Ctrl-Shift-X)`` &lt;br&gt;     Copies a node and all its descendants to the clipboard and then delete them. &lt;br&gt; ``delete-node`` &lt;br&gt;     Deletes a node and all its descendants. &lt;br&gt; ``paste-node (Ctrl-Shift-V)`` &lt;br&gt;     Pastes a node and its descendants from the outline. This commands creates *copies* of nodes, not clones. &lt;br&gt; ``past-retaining-clones`` &lt;br&gt;     Pastes a node and its descendants from the outline.  This command preserves the identify (gnx's) of the pasted nodes, thereby preserving any clone links. This command ensures that no newly-pasted node is an ancestor of itself. &lt;br&gt;  &lt;br&gt; **Outline representation**: When cutting or copying an outline to the clipboard, Leo writes the outline in the same xml (text) format used in .leo files. You may copy this text representation into a body pane (or into any other text editor) using ``Ctrl-V``. &lt;br&gt; " id="1135" linkTypes="1" links="670" title="Cutting, pasting &amp; deleting nodes" />
<node body="``move-outline-down (Ctrl-D or Shift-Down or Alt-Shift-Down)`` &lt;br&gt;     Move the selected node down, if possible. &lt;br&gt; ``move-outline-left (Ctrl-L or Shift-Left or Alt-Shift-Left)`` &lt;br&gt;     Move the selected node left, if possible. &lt;br&gt; ``move-outline-right (Ctrl-R or Shift-Right or Alt-Shift-Right)``  &lt;br&gt;     Move the selected node right, if possible. &lt;br&gt; ``move-outline-up (Ctrl-U or Shift-Up Alt-Shift-Up)`` &lt;br&gt;     Move the selected node up, if possible. &lt;br&gt;  &lt;br&gt; **Alt Modifiers not needed in the outline pane**: When focus is in the outline pane, you can move nodes without adding the Alt modifier. Shift-Up moves the select node up, etc. &lt;br&gt;  &lt;br&gt; **Important**: The following commands reorganize groups of nodes: &lt;br&gt;  &lt;br&gt; ``de-hoist`` &lt;br&gt;     Undoes the effect of the previous ``hoist`` command. &lt;br&gt; ``demote (Ctrl-])`` &lt;br&gt;     Makes all following siblings of a node children of the node. &lt;br&gt; ``hoist`` &lt;br&gt;     Redraws the screen so presently selected tree becomes the only visible part of the outline. You may hoist an outline as many times as you wish. &lt;br&gt; ``promote (Ctrl-[)`` &lt;br&gt;     Makes all the children of a node siblings of the node. &lt;br&gt; ``sort-children`` &lt;br&gt;     Sort all children of the children of the present node by their headlines. &lt;br&gt; ``sort-siblings (Alt-A)`` &lt;br&gt;     Sort the present node and all its siblings by their headlines. &lt;br&gt; " id="1136" linkTypes="1" links="670" title="Moving &amp; reorganizing nodes" />
<node body="``code-to-rst`` &lt;br&gt;     Format the presently selected node as computer code. &lt;br&gt; ``flatten-outline-to-node`` &lt;br&gt;     Appends the headline and body text of all descendants of the selected node to the body text of the selected node. &lt;br&gt; ``head-to-prev-node`` &lt;br&gt;     Moves non-empty text preceding a class, method or function definition to the end of the previous sibling node. &lt;br&gt; ``parse-body`` &lt;br&gt;     Parse p.b as source code, creating a tree of descendant nodes. &lt;br&gt;     This is essentially an import of p.b. &lt;br&gt; ``tail-to-next-node`` &lt;br&gt;     Moves non-empty text following a class, method or function definition to the start of the next sibling node. &lt;br&gt; " id="1137" linkTypes="1" links="670" title="Converting between outlines and text" />
<node body="You may drag a node (including all its descendants) from one place to another in an outline. To start a drag, press the main (left) mouse button while the cursor is over the icon for a node. The cursor will change to a hand icon. If you release the mouse button while the hand cursor is above another node, Leo will move the dragged node after that node. If you release the mouse button when the hand cursor is not over a node, Leo will leave the outline pane as it is. Leo scrolls the outline pane as the result of mouse-moved events, so to continue scrolling you must keep moving the mouse. &lt;br&gt;  &lt;br&gt; If the recipient node has children and is expanded, the dropped node will be inserted as the first child of the recipient node, otherwise the dropped node will be inserted after the recipient node. &lt;br&gt;  &lt;br&gt; Holding down Alt before releasing the node will force insertion as a child of the recipient node, even if the recipient node is not expanded. Holding down Control before releasing the node will cause a clone to be dropped, leaving the original where it was. &lt;br&gt; " id="1138" linkTypes="1" links="670" title="Dragging nodes" />
<node body="``goto-next-marked`` &lt;br&gt;     Selects the next marked node. &lt;br&gt; ``mark (Ctrl-M)`` &lt;br&gt;     Marks node if it is unmarked, and unmarks the node if it is already marked. &lt;br&gt; ``mark-changed-items`` &lt;br&gt;     Marks all nodes whose headline or body text has been changed since the file was last saved. &lt;br&gt; ``mark-subheads`` &lt;br&gt;     Marks all children of the presently selected node. &lt;br&gt; ``marked-list`` &lt;br&gt;     Lists all marked nodes in the Nav pane. &lt;br&gt; ``unmark-all`` &lt;br&gt;     Unmarks all marked nodes in the outline. &lt;br&gt;  &lt;br&gt; **Marking groups of nodes**: Leo's find and change commands mark nodes if the &quot;Mark Changes&quot; and &quot;Mark Finds&quot; checkboxes are checked. You can change these checkboxes with the ``toggle-find-mark-changes-option`` and ``toggle-find-mark-finds-option`` commands. &lt;br&gt; " id="1139" linkTypes="1" links="670" title="Marking nodes" />
<node body="``clone-marked-nodes`` &lt;br&gt;     Makes clones of all marked nodes and moves them to be children of the present position. &lt;br&gt; ``delete-marked-nodes`` &lt;br&gt;     Deletes all marked nodes. &lt;br&gt; ``move-marked-nodes`` &lt;br&gt;     Moves all nodes to be children of the present position. &lt;br&gt; " id="1140" linkTypes="1" links="670" title="Operations on marked nodes" />
<node body="``file-compare-leo-files`` &lt;br&gt;     Prompts for another (presumably similar) .leo file that will be compared with the presently selected outline file (main window). It then creates clones of all inserted, deleted and changed nodes. &lt;br&gt; ``file-diff-files`` &lt;br&gt;     Creates a node and puts the diff between 2 files into it.  &lt;br&gt; " id="1141" linkTypes="1" links="670" title="Comparing outlines" />
<node body="Chapters are sub-outlines rooted in an @chapter node. Selecting a chapter makes only those nodes in the chapter visible, much like a hoist. The ``main`` chapter represents the entire outline. Selecting the ``main`` chapter shows all outline nodes. &lt;br&gt;  &lt;br&gt; ``chapter-select-main`` &lt;br&gt;     Selects the main chapter. &lt;br&gt;      &lt;br&gt; ``chapter-select-&lt;chapter-name&gt;`` &lt;br&gt;     Each @chapter node in the outline creates a corresponding chapter-select command. &lt;br&gt;  &lt;br&gt; Associated settings: &lt;br&gt;  &lt;br&gt; ``@bool use_chapters`` &lt;br&gt;     True: chapters are enabled. &lt;br&gt;  &lt;br&gt; ..  ``@bool use_chapter_tabs`` &lt;br&gt; ..    True: chapters pop-up menu appears in the icon area. &lt;br&gt; " id="1142" linkTypes="1" links="670" title="Using Chapters" />
<node body="Basic searches: &lt;br&gt;  &lt;br&gt; ``start-search (Ctrl-F)`` &lt;br&gt;     Prompts for a search string. Typing the ``Return`` key puts the search string in the Find tab and executes a search based on all the settings in the Find tab. Type ``Tab`` to enter replacement text. &lt;br&gt; ``find-next (F3)`` &lt;br&gt;     Continues a search started with ``Ctrl-F``. &lt;br&gt; ``find-previous (F2)`` &lt;br&gt;     Searches backwards using the present search options. &lt;br&gt; ``replace (Ctrl-=)`` &lt;br&gt;     Replaces the selected text with the 'change' text in the Find tab. &lt;br&gt; ``replace-then-find (Ctrl--)`` &lt;br&gt;     Replaces the selected text with the 'change' text in the Find tab, then executes the find command again. &lt;br&gt;      &lt;br&gt; Batch searches: &lt;br&gt;  &lt;br&gt; ``find-all`` &lt;br&gt;     Prints all matches in the log pane. &lt;br&gt; ``replace-all`` &lt;br&gt;     Changes all occurrences of the 'find' text with the 'change' text. &lt;br&gt;      &lt;br&gt; Searches creating clones: &lt;br&gt;  &lt;br&gt; ``clone-find-all-flattened`` &lt;br&gt;     Prompts for a find, then creates clones of all found nodes in an organizer node. &lt;br&gt; ``clone-find-all`` &lt;br&gt;     Same as ``clone-find-all-flattened``, but does not create duplicate cloned nodes. If a node is a descendant of another found node, no duplicate top-level node (in the organizer) is created. &lt;br&gt; ``clone-find-parents`` &lt;br&gt;     Creates an organizer node containing clones of all the parents of the selected node. &lt;br&gt; " id="1143" linkTypes="1" links="672" title="Basic searches" />
<node body="Incremental find commands move through the text as you type individual characters. Typing ``BackSpace`` backtracks the search. To repeat an incremental search, type the shortcut for that command again. Here are Leo's incremental find commands:: &lt;br&gt;  &lt;br&gt;     Alt+R isearch-backward &lt;br&gt;           isearch-backward-regexp &lt;br&gt;     Alt+S isearch-forward &lt;br&gt;           isearch-forward-regexp &lt;br&gt;           isearch-with-present-options &lt;br&gt; " id="1144" linkTypes="1" links="672" title="Incremental find commands" />
<node body="The following commands work like ``F3 (start-search)`` with various options set: &lt;br&gt;  &lt;br&gt; ``search-backward`` &lt;br&gt;     Searches in the reverse direction. &lt;br&gt; ``word-search-backward`` and ``word-search-forward`` &lt;br&gt;     Sets 'Whole Word' checkbox to True. &lt;br&gt; ``re-search-forward`` and ``re-search-backward`` &lt;br&gt;     Set the 'Regexp' checkbox to True. &lt;br&gt; " id="1145" linkTypes="1" links="672" title="Word search and regex search commands" />
<node body="The following check boxes options appear in the Find pane: &lt;br&gt;  &lt;br&gt; ``Ignore Case`` &lt;br&gt;     When checked, the Find and Change commands ignore the case of alphabetic characters when determining matches. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+I (toggle-find-ignore-case-option)`` toggles this checkbox. &lt;br&gt;  &lt;br&gt; ``Mark Changes`` &lt;br&gt;     When checked, the Change command marks all headlines whose headline or body text are changed by the command. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+C (toggle-find-mark-changes-option)`` toggles this checkbox. &lt;br&gt;  &lt;br&gt; ``Mark Matches`` &lt;br&gt;     When checked, the Find and Change commands mark all headlines in which a match is found with the pattern. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+F (toggle-find-mark-finds-option)`` toggles this checkbox. &lt;br&gt;  &lt;br&gt; ``Pattern Match`` &lt;br&gt;     When checked, the Find and Change commands treat several characters specially in the find pattern. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+X (toggle-find-regex-option)`` toggles this checkbox. &lt;br&gt;      &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     '*'  matches any sequence of zero or more characters. &lt;br&gt;     '.'  matches any single character. &lt;br&gt;     '^'  matches a newline at the start of a pattern. &lt;br&gt;     '$'  matches a newline at the end of a pattern. &lt;br&gt;  &lt;br&gt;     Examples:: &lt;br&gt;  &lt;br&gt;     &quot;^abc$&quot; matches lines that only contain &quot;abc&quot;. &lt;br&gt;     &quot;^a&quot; matches any line starting with &quot;A&quot;. &lt;br&gt;     &quot;a$&quot; matches any line ending with &quot;a&quot;. &lt;br&gt;     &quot;^*$&quot; matches any line at all. &lt;br&gt;  &lt;br&gt; ``Search Body Text`` &lt;br&gt;     When checked, the Find and Change commands search body text. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+B (toggle-find-in-body-option)`` toggles this checkbox. &lt;br&gt;  &lt;br&gt; ``Search Headline Text`` &lt;br&gt;     When checked, the Find and Change commands search headline text. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+H (toggle-find-in-headline-option)`` toggles this checkbox. &lt;br&gt;  &lt;br&gt; ``Whole Word`` &lt;br&gt;     When selected, the find pattern must match an entire word. Words consist of an alphabetic character or underscore, followed by zero or more alphabetic characters, numbers or underscores. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+W (toggle-find-word-option)`` toggles this checkbox. &lt;br&gt;  &lt;br&gt; ``Wrap Around`` &lt;br&gt;     When checked, the Find and Change commands continues at the top of the file when the command reaches the bottom of the file. For reverse searches, the find or change command continues at the bottom of the file when the command reaches the top of the file. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+A (toggle-find-wrap-around-option)`` toggles this checkbox. &lt;br&gt; " id="1146" linkTypes="1" links="672" title="Check boxes and their commands" />
<node body="The following radio buttons appear in the Find pane: &lt;br&gt;  &lt;br&gt; ``Entire Outline`` &lt;br&gt;     When selected, Find commands search the entire outline. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+E (set-find-everywhere)`` sets this radio button. &lt;br&gt;  &lt;br&gt; ``Node Only`` &lt;br&gt;     When selected, Find commands search only the selected node. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+N (set-find-node-only)`` sets this radio button &lt;br&gt;      &lt;br&gt; ``Suboutline Only`` &lt;br&gt;     When selected, the Find and Change commands search only the currently &lt;br&gt;     selected headline and its offspring. &lt;br&gt;      &lt;br&gt;     ``Alt+Ctrl+S (set-find-suboutline-only)`` sets this radio button. &lt;br&gt; " id="1147" linkTypes="1" links="672" title="Radio buttons and their commands " />
<node body="The following commands refer to spell-as-you-type mode: &lt;br&gt;  &lt;br&gt; ``spell-as-you-type-next`` &lt;br&gt;     Cycle the word behind (left of, for ltr languages) the cursor through the full list of suggestions. &lt;br&gt; ``spell-as-you-type-toggle`` &lt;br&gt;     Toggle spell as you type mode.  When enabled, word ending keystrokes will put a short list of suggestions in the log window, if the word is unknown to the speller.  Only shows the first 5 suggestions, even if there are more. &lt;br&gt; ``spell-as-you-type-undo`` &lt;br&gt;     Undo the last spelling correction. &lt;br&gt; ``spell-as-you-type-wrap`` &lt;br&gt;     Toggle wrapping in spell-as-you-type mode. &lt;br&gt;      &lt;br&gt; The following commands refer to the Spell Tab: &lt;br&gt;  &lt;br&gt; ``focus-to-spell-tab`` &lt;br&gt;     Put focus in the Spell tab. &lt;br&gt; ``spell-change`` &lt;br&gt;     Same as clicking the &quot;Change&quot; button in the Spell Tab. &lt;br&gt; ``spell-change-then-find`` &lt;br&gt;     Same as clicking the &quot;Change, Find&quot; button in the Spell Tab. &lt;br&gt; ``spell-find`` &lt;br&gt;     Same as clicking the &quot;Find&quot; button in the Spell Tab. &lt;br&gt; ``spell-ignore`` &lt;br&gt;     Same as clicking the &quot;Ignore&quot; button in the Spell Tab. &lt;br&gt; ``spell-tab-hide`` &lt;br&gt;     Hide the Spell tab. &lt;br&gt; ``spell-tab-open`` &lt;br&gt;     Show the Spell tab. &lt;br&gt; " id="1148" linkTypes="1" links="672" title="Spell commands" />
<node body=".. _`Pep 8 recommendations for whitespace`: https://www.python.org/dev/peps/pep-0008/#whitespace-in-expressions-and-statements &lt;br&gt; .. _`pep 8 recommendations for blank lines`: https://www.python.org/dev/peps/pep-0008/#blank-lines &lt;br&gt;  &lt;br&gt; The beautifier will *just work* for most people.  &lt;br&gt;  &lt;br&gt; The beautifier follows the `Pep 8 recommendations for whitespace`_. It ensures that names, operators, strings and comments are separated by zero or one blanks:: &lt;br&gt;  &lt;br&gt;     def spam(a, b, c=5, *args, **keys): &lt;br&gt;         foo(a, 25, b=2) &lt;br&gt;         a = b + c - 5 &lt;br&gt;         b = -d &lt;br&gt;         if 0 &lt; b &lt; 26: &lt;br&gt;             ... &lt;br&gt;  &lt;br&gt; Leo follows the `pep 8 recommendations for blank lines`_ *between* classes and defs, with minor variations due to Leo's node structure. &lt;br&gt;  &lt;br&gt; Optionally, the beautifier can remove blank lines *within* classes and defs, controlled by the setting *@bool tidy-keep-blank-lines*. &lt;br&gt; " id="1149" linkTypes="1" links="674" title="What the Python beautifier does" />
<node body="The Python beautifier never creates new lines! The beautifier never adds or changes: &lt;br&gt;  &lt;br&gt; - Line breaks for &quot;long&quot; lines. &lt;br&gt; - Line breaks in function argument lists. &lt;br&gt; - Leading whitespace in continued argument lines. &lt;br&gt; - Line breaks call arguments. &lt;br&gt; - Leading whitespace in continue function call arguments. &lt;br&gt; - Whitespace (including line breaks) within statements. &lt;br&gt;  &lt;br&gt; Pep 8 allows considerable flexibility regarding continued lines. The beautifier will leave all of the following unchanged, whether or not they conform to the pep 8 recommendation:: &lt;br&gt;  &lt;br&gt;     def function1 (a, b, c): &lt;br&gt;         pass &lt;br&gt;      &lt;br&gt;     def function2 ( &lt;br&gt;     a = 2, # a comment &lt;br&gt;     b = 3, # another comment &lt;br&gt;     ): &lt;br&gt;         pass &lt;br&gt;      &lt;br&gt;     def function3 ( &lt;br&gt;         a = 2, # a comment &lt;br&gt;         b = 3, # another comment &lt;br&gt;     ): &lt;br&gt;         pass &lt;br&gt;      &lt;br&gt;     def function4( &lt;br&gt;                   a = 2, # a comment &lt;br&gt;                   b = 3, # another comment &lt;br&gt;                  ): &lt;br&gt;         pass &lt;br&gt;  &lt;br&gt; Similarly, the beautifier will not touch arguments in function calls. &lt;br&gt; " id="1150" linkTypes="1" links="674" title="What the Python beautifier doesn't do" />
<node body="``@killbeautify`` &lt;br&gt;     This directive completely disables beautification for an entire tree. This is typically required for files containing ``@all``. &lt;br&gt;  &lt;br&gt; ``@beautify`` and ``@nobeautify`` &lt;br&gt;     These directives apply to a node and its descendants, until overridden later in a descendants. Both these directives may appear in the same node.  Such **ambiguous directives** do not affect the beautification of descendant nodes.  If both ``@beautify`` and ``@nobeautify`` appear in a node, the first directive determines whether the node will be beautified. &lt;br&gt;      &lt;br&gt; For example:: &lt;br&gt;  &lt;br&gt;     @beautify &lt;br&gt;     ... &lt;br&gt;     @nobeautify &lt;br&gt;  &lt;br&gt; beautifies the entire node.  Otoh:: &lt;br&gt;  &lt;br&gt;     @nobeautify &lt;br&gt;     ... &lt;br&gt;     @beautify &lt;br&gt;  &lt;br&gt; skips beautification of the entire node. Yes, this is less precise than one could imagine, but it's good enough for now. &lt;br&gt; " id="1151" linkTypes="1" links="674" title="Beautifier directives" />
<node body="``@bool tidy-autobeautify = False`` &lt;br&gt;     When True, Leo beautifies all changed files when saving an outline. The default must always be False in leoSettings.leo and in unitTest.leo. &lt;br&gt;  &lt;br&gt; ``@bool tidy-keep-blank-lines = False`` &lt;br&gt;     When True, the beautifier retains blank lines within classes, functions and methods. &lt;br&gt; " id="1152" linkTypes="1" links="674" title="Beautifier settings" />
<node body="The following 5 problems are relatively minor.  They apply only to the Python beautifier. The workaround in most cases is to use ``@nobeautify``. &lt;br&gt;  &lt;br&gt; **1. Syntax Errors** &lt;br&gt;  &lt;br&gt; The pass hack converts:: &lt;br&gt;  &lt;br&gt;     if 1: &lt;br&gt;         &lt;&lt; a section &gt;&gt; &lt;br&gt;  &lt;br&gt; to:: &lt;br&gt;  &lt;br&gt;     if 1: &lt;br&gt;         #!!!!! &lt;&lt; a section &gt;&gt; &lt;br&gt;         pass &lt;br&gt;  &lt;br&gt; which is usually, but not always, syntactically correct Python. Here is an example from Leo's core:: &lt;br&gt;  &lt;br&gt;     patterns = [ &lt;br&gt;         &lt;&lt; Sherlock patterns for pylint &gt;&gt; &lt;br&gt;     ] &lt;br&gt;  &lt;br&gt; The pass hack produces syntactically incorrect code:: &lt;br&gt;  &lt;br&gt;     patterns = [ &lt;br&gt;         #!!!!! &lt;&lt; Sherlock patterns for pylint &gt;&gt; &lt;br&gt;         pass &lt;br&gt;     ] &lt;br&gt;  &lt;br&gt; **2. Alignment** &lt;br&gt;  &lt;br&gt; The beautifier eliminates blanks used to align code.  For example:: &lt;br&gt;  &lt;br&gt;     d = { &lt;br&gt;         key1:     value1, &lt;br&gt;         longKey2: value2, &lt;br&gt;     } &lt;br&gt;  &lt;br&gt; The beautifier might preserve such lines, but there are no plans at present to do so. &lt;br&gt;  &lt;br&gt; The regular expression: ``=([ ])*\{([^}])*$`` will discover complex dictionaries that you may want to protect with ``@nobeautify``. &lt;br&gt;  &lt;br&gt; **3. Operator priority** &lt;br&gt;  &lt;br&gt; Pep 8 suggests considering eliminating blanks around higher-priority operators.  The beautifier puts blank lines about all operators, except unary operators. &lt;br&gt;  &lt;br&gt; This is a difficult problem of style, for which no approach works in all cases.  Surprisingly, retaining blanks around ``*`` usually looks best in Leo's own code. &lt;br&gt;  &lt;br&gt; **4. @clean &amp; @auto** &lt;br&gt;  &lt;br&gt; Consider adding @nobeautify for all ``@auto`` and ``@clean`` nodes, on the theory that such nodes are not primarily your responsibility.  But adding ``@nobeautify`` is completely up to you. &lt;br&gt;  &lt;br&gt; **5. Extra blank lines** &lt;br&gt;  &lt;br&gt; The beautifier will sometimes insert extra spaces between class/def lines and preceding comments. &lt;br&gt; " id="1153" linkTypes="1" links="674" title="Beautifier rough edges" />
<node body="You may invoke a *lightly tested* stand-alone version the Python beautifier from the command line. &lt;br&gt;  &lt;br&gt; You can run leoBeautify.py from any directory, provided that a copy of leoGlobals.py exists in the same directory. &lt;br&gt;  &lt;br&gt; Run the stand-alone beautifier as follows:: &lt;br&gt;  &lt;br&gt;     python -m leoBeautify file1, file2, ... &lt;br&gt;  &lt;br&gt; To get a usage message, do:: &lt;br&gt;  &lt;br&gt;     python -m leoBeautify -h &lt;br&gt;  &lt;br&gt; This produces:: &lt;br&gt;  &lt;br&gt;     Usage: python leoBeautify -m file1, file2, ... &lt;br&gt;      &lt;br&gt;     Options: &lt;br&gt;       -h, --help             show this help message and exit &lt;br&gt;       -d, --debug            print the list of files and exit &lt;br&gt;       -k, --keep-blank-lines keep-blank-lines &lt;br&gt;  &lt;br&gt; " id="1154" linkTypes="1" links="674" title="Stand-alone beautifier" />
<node body="The following could be done only at the cost of more settings and debates about what the default settings should be. &lt;br&gt;  &lt;br&gt; - Splitting long lines. &lt;br&gt; - Improving spacing around operators. &lt;br&gt; - Moving or indenting comment lines. &lt;br&gt;  &lt;br&gt; All these involve significant personal judgments and preferences. Pep 8 explicitly allows various approaches. &lt;br&gt; " id="1155" linkTypes="1" links="674" title="Enough is enough" />
<node body="Except for dictionary definitions, the beautifier does what is expected, leaving difficult or idiosyncratic cases completely at the user's discretion. &lt;br&gt;  &lt;br&gt; - For the first time ever, Leo's beautify commands work properly with Leonine syntax. &lt;br&gt; - All files in leoPy.leo can now be beautified without fuss. &lt;br&gt; - Except for spacing around operators, the beautifier mostly leaves your code **as it is**. &lt;br&gt; - The beautifier makes no difficult choices. It preserves your choices. &lt;br&gt; " id="1156" linkTypes="1" links="674" title="Summary of the beautifier" />
<node body="Within @path and @&lt;file&gt; paths, Leo evaluates ``{{exp}}`` with the the following symbols defined: ``c``, ``g``, ``p``, ``os`` and ``sys``.  For example:: &lt;br&gt;  &lt;br&gt;     @file {{os.path.abspath(os.curdir)}}/abc.py &lt;br&gt;      &lt;br&gt; refers to the file abc.py in (absolute path of) the current directory. &lt;br&gt; " id="1157" linkTypes="1" links="678" title="Path expressions" />
<node body=".. index:: &lt;br&gt;     pair: @asis; Reference &lt;br&gt;  &lt;br&gt; The @asis directive creates an external file without sentinels and without any expansions. &lt;br&gt;  &lt;br&gt; Use this directive only when you must have complete control over every character of the external file. When writing @asis nodes, writes the body text of all nodes in outline order. Leo writes the body text *as is*, without recognizing section definitions, without expanding section references, and without treating directives specially in any way. In particular, Leo copies all directives, including @ or @c directives, to the external file as text. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @@ convention in @asis trees; Reference &lt;br&gt;  &lt;br&gt; **The @@ convention**: Within @asis trees only, if a headline starts with @@, Leo writes everything in the headline following the @@ just before the corresponding body text. &lt;br&gt;  &lt;br&gt; Files created from @asis trees contain *nothing* not contained in body text (or &lt;br&gt; @@ headlines). In particular, if body text does not end in a newline, the first &lt;br&gt; line from the next node will concatenated to the last line of the preceding node. &lt;br&gt;  &lt;br&gt; Within @asis trees, Leo writes no sentinels to the external file, so Leo can not update the outline using changes to the external file. When reading .leo files, Leo does *not* read external files created from @asis nodes. Instead, all data in an @asis tree is stored in the .leo file. &lt;br&gt;  &lt;br&gt; Within @asis trees, Leo recognizes the @ignore directive only in the *ancestors* of @asis nodes. This allows you to use the @ignore directive to prevent Leo from writing @asis trees. &lt;br&gt;  &lt;br&gt; **Note**: @file-asis and @silent are deprecated synonyms for @asis. &lt;br&gt; " id="1158" linkTypes="1" links="678" title="\@asis &lt;path&gt;" />
<node body=".. index:: &lt;br&gt;     pair: @auto; Reference &lt;br&gt;  &lt;br&gt; The @auto directive imports an external file into a tree of nodes. &lt;br&gt;  &lt;br&gt; @auto trees allow people to use Leo in collaborative environments without using sentinels in external files. Even without sentinels, @auto trees can change when the corresponding external file changes outside of Leo. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Importer; Reference &lt;br&gt;  &lt;br&gt; \@auto nodes read files using language-specific importers. &lt;br&gt; By default, the file's extension determines the importer:: &lt;br&gt;  &lt;br&gt;     Extensions                  Importer &lt;br&gt;     ----------                  -------- &lt;br&gt;     .c, .cc, .c++, .cpp,.cxx    C &lt;br&gt;     .cs', .c#'                  C Sharp &lt;br&gt;     .el                         Elisp &lt;br&gt;     .h, .h++                    C &lt;br&gt;     .html, .htm                 HTML &lt;br&gt;     .ini                        Config file &lt;br&gt;     .ipynb                      Jupyter notebook &lt;br&gt;     .java                       Java &lt;br&gt;     .js                         JavaScript &lt;br&gt;     .md                         Markdown &lt;br&gt;     .org                        Org Mode &lt;br&gt;     .otl                        Vim outline &lt;br&gt;     .pas                        Pascal &lt;br&gt;     .php                        PHP &lt;br&gt;     .py, .pyi, .pyw             Python &lt;br&gt;     .rest, .rst                 reStructuredText &lt;br&gt;     .ts                         TypeScript &lt;br&gt;     .xml                        XML &lt;br&gt;      &lt;br&gt; You can also specify importers *explicitly* as follows:: &lt;br&gt;  &lt;br&gt;     @auto-xxx           Importer            Notes &lt;br&gt;     ---------           --------            ----- &lt;br&gt;     @auto-ctext         ctext            &lt;br&gt;     @auto-markdown      markdown            1, 2 &lt;br&gt;     @auto-md            markdown            1, 2 &lt;br&gt;     @auto-org           org-mode            1, 3 &lt;br&gt;     @auto-org-mode      org-mode            1, 3 &lt;br&gt;     @auto-otl           vimoutline          1, 4 &lt;br&gt;     @auto-vim-outline   vimoutline          1, 4       &lt;br&gt;     @auto-rst           reStructuredText    1, 5 &lt;br&gt;      &lt;br&gt; .. _`org-mode`: http://en.wikipedia.org/wiki/Org-mode &lt;br&gt; .. _`Emacs`:    http://leoeditor.com/emacs.html#using-org-mode-org-files-in-leo &lt;br&gt; .. _`markdown`:  http://en.wikipedia.org/wiki/Markdown &lt;br&gt; .. _`reStructuredText`:     http://docutils.sourceforge.net/rst.html &lt;br&gt; .. _`vim outline`:  http://www.vim.org/scripts/script.php?script_id=3515 &lt;br&gt; .. _`vim`:          http://leoeditor.com/vimBindings.html#using-vimoutline-otl-files-in-leo &lt;br&gt;  &lt;br&gt; **Note 1**: The importers/exporters for markdown, org-mode, reStructuredText and vimoutline files automatically generate section heading of the appropriate level. Body text of the top-level @auto node is ignored. &lt;br&gt;  &lt;br&gt; **Note 2**: See the official `Markdown`_ documentation. &lt;br&gt;  &lt;br&gt; **Note 3**: See Leo's `Emacs`_ documentation and Emacs's `org-mode`_ documentation. &lt;br&gt;  &lt;br&gt; **Note 4**: See Leo's `vim`_ documentation and Vim's `vim outline`_ documentation. &lt;br&gt;  &lt;br&gt; **Note 5**: See the `reStructuredText`_ documentation. &lt;br&gt; " id="1159" linkTypes="3" links="1355" title="\@auto &lt;path&gt;" />
<node body=".. _`Mulder/Ream update algorithm`: http://leoeditor.com/appendices.html#the-mulder-ream-update-algorithm &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: @clean; Reference &lt;br&gt;  &lt;br&gt; The @clean &lt;filename&gt; creates an external file without sentinel lines. &lt;br&gt; @clean trees will probably be the most convenient way of creating and &lt;br&gt; accessing external files for most people. &lt;br&gt;  &lt;br&gt; When writing an @clean tree, Leo expands section references, @all and &lt;br&gt; @others directives, but Leo writes no sentinels to the external file. &lt;br&gt;  &lt;br&gt;  &lt;br&gt; When reading an @clean tree, Leo propagates changes from the external file &lt;br&gt; to the @clean tree using the `Mulder/Ream update algorithm`_. &lt;br&gt;  &lt;br&gt; **Note**: The @bool force_newlines_in_at_nosent_bodies setting controls whether &lt;br&gt; Leo writes a trailing newline if non-empty body text does not end in a newline. &lt;br&gt; The default is True. &lt;br&gt; " id="1160" linkTypes="1" links="678" title="\@clean &lt;path&gt;" />
<node body=".. index:: &lt;br&gt;     pair: @edit; Reference &lt;br&gt;  &lt;br&gt; The @edit directive imports an external file into a single node. &lt;br&gt;  &lt;br&gt; When reading @edit nodes, Leo reads the entire file into the @edit node. Lines &lt;br&gt; that look like sentinels will be read just as they are. &lt;br&gt;  &lt;br&gt; When writing @edit nodes, @edit nodes must not have children and section &lt;br&gt; references and @others are not allowed. &lt;br&gt; " id="1161" linkTypes="1" links="678" title="\@edit &lt;path&gt;" />
<node body=".. index:: &lt;br&gt;     pair: @file; Reference &lt;br&gt;     pair: @thin; Reference &lt;br&gt;  &lt;br&gt; The @file directive creates an external file containing sentinels. When writing &lt;br&gt; @file trees, Leo expands section references and @all and @others directives. &lt;br&gt;  &lt;br&gt; When reading external files created by @file, the sentinels allow Leo to &lt;br&gt; recreate all aspects of the outline. In particular, Leo can update the &lt;br&gt; outline based on changes made to the file by another editor.  &lt;br&gt;  &lt;br&gt; **Important**: @file is the recommended way to create and edit most &lt;br&gt; files. In particular, using @file nodes is **highly recommended** &lt;br&gt; when sharing external files in a collaborative environment. The @all &lt;br&gt; directivive is designed for &quot;catch-all&quot; files, like todo.txt or &lt;br&gt; notes.txt or whatever. Such files are assumed to contain a random &lt;br&gt; collection of nodes, so there is no language in effect and no real &lt;br&gt; comment delimiters. &lt;br&gt;  &lt;br&gt; The @thin directive is a synonym for @file. &lt;br&gt;  &lt;br&gt; Prior to Leo 4.7, @file worked differently from @thin. This should not be &lt;br&gt; a problem: Leo 4.7 can read all external files written by Leo 4.6. &lt;br&gt; " id="1162" linkTypes="1" links="678" title="\@file &lt;path&gt; (aka @thin)" />
<node body=".. index:: &lt;br&gt;     pair: @nosent; Reference &lt;br&gt;  &lt;br&gt; The @nosent directive creates an external file **without** sentinels. When writing &lt;br&gt; @nosent trees, Leo expands section references and @all and @others directives.  Because the external file contains no sentinels, @nosent trees can not be updated from changes made outside of Leo. If you want this capability, use @clean instead. &lt;br&gt; " id="1163" linkTypes="1" links="678" title="\@nosent &lt;path&gt;" />
<node body=".. index:: &lt;br&gt;     pair: @shadow; Reference &lt;br&gt;     pair: Private file; Reference &lt;br&gt;     pair: Public file; Reference &lt;br&gt;      &lt;br&gt; **Important**: As of Leo 5.1, @shadow is **deprecated** Use @clean instead. @clean is faster than @shadow and requires no hidden files. &lt;br&gt;  &lt;br&gt; The @shadow directive creates *two* external files, a **public** file without sentinels, and a **private** file containing sentinels. &lt;br&gt;  &lt;br&gt; .. _`Mulder/Ream update algorithm`: http://leoeditor.com/appendices.html#the-mulder-ream-update-algorithm &lt;br&gt;  &lt;br&gt; When reading an @shadow node, Leo uses the `Mulder/Ream update algorithm`_ to compare the public and private files, then updates the outline based on changes to the *public* file. &lt;br&gt;  &lt;br&gt; Leo can do an initial import of @shadow trees by parsing the corresponding public file, exactly as is done for @auto nodes. &lt;br&gt; " id="1164" linkTypes="1" links="678" title="\@shadow &lt;path&gt; (deprecated)" />
<node body="- Cursor motions: ^,$,0,b,e,f,F,gg,gG,j,h,k,l,t,T,w. &lt;br&gt; - The gb,ge,gh commands are synonyms for 0,$,^. &lt;br&gt; - The h,j,k,l commands work on outlines when entered in the outline pane. &lt;br&gt; - 0 in outline pane: goto-first-visible-node &lt;br&gt; - e in outline pane: goto-last-visible-node. &lt;br&gt; - Deleting text: d{motion},{motion}d,v{motion}d,diw,x. &lt;br&gt; - Insert commands: a,A,i,o,O and switch to insert mode if entered in the outline pane. &lt;br&gt; - Yank &amp; paste commands: y,p. These act on outlines if entered in the outline pane. &lt;br&gt; - Search commands: /,?,n,*,#.  These commands are node-only searches. &lt;br&gt; - The dot command '.' works for motions, but not yet for inserts or searches. &lt;br&gt; - v: start/end visual mode. &lt;br&gt;  &lt;br&gt; Notes: &lt;br&gt;  &lt;br&gt; - Except as noted above, all vim-mode commands must be entered in the body pane. &lt;br&gt; - &lt;Return&gt; in headlines switches to the outline pane. &lt;br&gt; - &lt;Return&gt; in the outline pane switches to the body pane. &lt;br&gt; " id="1165" linkTypes="1" links="687" title="Supported commands" />
<node body="- The gb,ge,gh commands are synonyms for 0,$,^. &lt;br&gt; - The h,j,k,l commands work on outlines when entered in the outline pane. &lt;br&gt; - The a,A,i,o,O commands switch to insert mode if entered in the outline pane. &lt;br&gt; - The y,p commands act on outlines if entered in the outline pane. &lt;br&gt; - Ending visual mode with 'v' retains the selection range. &lt;br&gt; - Ctrl-H puts the headline in insert mode. &lt;br&gt; - Mouse clicks never change vim's state. &lt;br&gt;  &lt;br&gt; " id="1166" linkTypes="1" links="687" title="Differences from the real vim" />
<node body="- The ``jj`` abbreviation switches to normal mode, preserving the changed &lt;br&gt;   status of the .leo file. &lt;br&gt; - Return in visual/normal mode enters insert mode. &lt;br&gt;  &lt;br&gt; ..  - ``,,`` in normal mode now moves to insert mode. &lt;br&gt; ..  ``,,`` in insert mode does nothing, unless there is an abbreviation template available. &lt;br&gt; " id="1167" linkTypes="1" links="687" title="Abbreviations" />
<node body="The ':' command enters Leo's minibuffer, with ':' pre-inserted. You may &lt;br&gt; backspace over the ':'. Here are the commands:: &lt;br&gt;    &lt;br&gt;     :! Execute a shell command. &lt;br&gt;     :e! Revert all changes to a .leo file, prompting if there have been changes. &lt;br&gt;     :gt cycle-focus &lt;br&gt;     :q Quit, prompting for saves. &lt;br&gt;     :qa Quit only if there are no unsaved changes. &lt;br&gt;     :r Prompt for a file name.  Insert it at the cursor. &lt;br&gt;     :tabnew Prompt for a file name, and open a new tab. &lt;br&gt;     :w Save the .leo file. &lt;br&gt;     :wa Save all changed  .leo files. &lt;br&gt;     :wq Save all open files and exit. &lt;br&gt;     :xa ave all open files and exit. &lt;br&gt;      &lt;br&gt; The following colon commands are unique to Leo:: &lt;br&gt;  &lt;br&gt;     :print-vim-dot &lt;br&gt;     :toggle-vim-mode &lt;br&gt;     :toggle-vim-trainer-mode &lt;br&gt; " id="1168" linkTypes="1" links="687" title="Colon commands" />
<node body="**@bool vim-mode = False**: Enables Leo's vim mode when True. &lt;br&gt;  &lt;br&gt; **@bool vim-crosses-lines = True**: When True the f,F,h,l,t,T,x &lt;br&gt; commands may cross line boundaries. &lt;br&gt; " id="1169" linkTypes="1" links="687" title="Settings" />
<node body="Place a copy of the &quot;@keys Vim bindings&quot; node and its sub-nodes, located in the leoSettings.leo file, under the &quot;@settings&quot; node in the myLeoSettings.leo file &lt;br&gt;  &lt;br&gt; The same procedure is performed to update to a new version. &lt;br&gt;  &lt;br&gt; Note: Place any local customized key bindings in a separate &quot;@keys My Vi&quot; node in the myLeoSettings.leo file to prevent them from being overwritten when updating to a new version. &lt;br&gt; " id="1170" linkTypes="1" links="689" title="Installing vim bindings" />
<node body="The following commands are always available. &lt;br&gt;  &lt;br&gt; State change commands:: &lt;br&gt;  &lt;br&gt;     i           Change state to insert from command state &lt;br&gt;     Esc         Change state to command from insert state &lt;br&gt;     Ctrl-[      Same as ESC &lt;br&gt;  &lt;br&gt; Save/Exit/Quite commands:: &lt;br&gt;  &lt;br&gt;     :e          Revert &lt;br&gt;     :w&lt;return&gt;  Save '.leo' file &lt;br&gt;     :wq&lt;return&gt; Save '.leo' file and quit Leo &lt;br&gt;     :q&lt;return&gt;  Quit Leo   (Leo will prompt if file not saved) &lt;br&gt;     ZZ          Save leo file and exit &lt;br&gt;  &lt;br&gt; Undo/Redo commands:: &lt;br&gt;  &lt;br&gt;     u           Undo previous command &lt;br&gt;     Ctrl-r      Redo previous command &lt;br&gt;  &lt;br&gt;  &lt;br&gt; Search options:: &lt;br&gt;  &lt;br&gt;     Ctrl-/      Prompt for option to change &lt;br&gt;                 Options: &lt;br&gt;                     a   Search all nodes (also &lt;cr&gt; key) &lt;br&gt;                     h   Toggle headline search &lt;br&gt;                     b   Toggle body search &lt;br&gt;                     m   Toggle marking of nodes (specify sub-option) &lt;br&gt;                         f   Toggle marking of nodes with found text &lt;br&gt;                         c   Toggle marking of nodes with changed text &lt;br&gt;                             (only supported with 'Alt-/', 'Alt-p') &lt;br&gt;                     r   Toggle regex matches &lt;br&gt;                         ('/' key turns off regex. 'n' key uses regex if turned on) &lt;br&gt;  &lt;br&gt;     Note: Whether a search is limited to node's body or the node's sub-outline &lt;br&gt;           is determined by which pane has focus when search text specified. &lt;br&gt;           (See &quot;Find text commands:&quot; sub-sections in Outline/Body Pane sections) &lt;br&gt;  &lt;br&gt; Miscellaneous commands:: &lt;br&gt;  &lt;br&gt;     Tab         Toggle focus between Outline and Body pane &lt;br&gt;     =           Simulate double-click on current node's icon box &lt;br&gt;     Alt-G       Go to specified line number (relative to external file) &lt;br&gt;     Ctrl-:      Enter Leo's command line &lt;br&gt; " id="1171" linkTypes="1" links="689" title="General commands" />
<node body="Move cursor commands:: &lt;br&gt;  &lt;br&gt;     h           Go back 1 character &lt;br&gt;        LtArrow  Mapped to &quot;h&quot; for convenience &lt;br&gt;     j           Go down 1 line &lt;br&gt;        DnArrow  Mapped to &quot;j&quot; for convenience &lt;br&gt;     k           Go up 1 line &lt;br&gt;        UpArrow  Mapped to &quot;k&quot; for convenience &lt;br&gt;     l           Go forward 1 character &lt;br&gt;        RtArrow  Mapped to &quot;l&quot; for convenience &lt;br&gt;  &lt;br&gt;     w           Go to beginning of next word &lt;br&gt;        W        Mapped to &quot;w&quot; until &quot;stop after blank characters&quot; supported &lt;br&gt;     b           Go to beginning of current/previous word &lt;br&gt;        B        Mapped to &quot;b&quot; until &quot;stop at blank character&quot; supported &lt;br&gt;     e           Go to end of current/next word &lt;br&gt;        E        Mapped to &quot;e&quot; until &quot;stop at blank character&quot; supported &lt;br&gt;  &lt;br&gt;     Note: Move by word commands stop at non-alpha characters &lt;br&gt;  &lt;br&gt;     |           Goto beginning of current line &lt;br&gt;     ^           Go to 1st non-blank character on current line &lt;br&gt;     $           Goto end of current line &lt;br&gt;  &lt;br&gt;     %           Go to matching bracket &lt;br&gt;  &lt;br&gt;     (           Go to beginning of current sentence &lt;br&gt;     )           Go to beginning of next sentence &lt;br&gt;     {           Go to beginning of current paragraph &lt;br&gt;     }           Go to beginning of next paragraph &lt;br&gt;  &lt;br&gt;     gg          Go to the first line (Cursor at column 1) &lt;br&gt;     G           Go to the last line  (Cursor at column 1) &lt;br&gt;  &lt;br&gt; Mark commands:: &lt;br&gt;  &lt;br&gt;     m&lt;label&gt;    Assign cursor location to a single character label &lt;br&gt;     `&lt;label&gt;    Go to location associated with label &lt;br&gt;  &lt;br&gt;       Note: Only character count is tracked. Any inserts or deletes will change mark. &lt;br&gt;           Mark's are not node specific; `&lt;label&gt; will go to location in current node. &lt;br&gt;  &lt;br&gt; Select commands:: &lt;br&gt;  &lt;br&gt;     Ctrl-v      Toggle text select mode (Vim's &quot;visual&quot; mode) &lt;br&gt;        V        Mapped to 'Ctrl-v' for convenience (Should toggle line select) &lt;br&gt;  &lt;br&gt; Insert/substitute commands:: &lt;br&gt;  &lt;br&gt;     a           Insert at cursor &lt;br&gt;     i           Mapped to &quot;a&quot; until &quot;cursor on a character&quot; supported &lt;br&gt;     A           Insert at end of line &lt;br&gt;     I           Insert at first non-space &lt;br&gt;     o           Open new line below current line &lt;br&gt;     O           Open new line above current line &lt;br&gt;     R           Overwrite text &lt;br&gt;     s           Substitute character (Delete character, enter insert state) &lt;br&gt;     S           Substitute line (Delete line, enter insert state) &lt;br&gt;  &lt;br&gt; Change commands:: &lt;br&gt;  &lt;br&gt;     C           Change to end of line &lt;br&gt;     cc          Change all of current line &lt;br&gt;     cw          Change to end of word &lt;br&gt;     cb          Change to beginning of word &lt;br&gt;     c)          Delete to end of sentence &lt;br&gt;     c(          Delete to beginning of sentence &lt;br&gt;     c}          Delete to end of paragraph &lt;br&gt;     c{          Delete to beginning of paragraph &lt;br&gt;     c%          Change from current bracket type its matching bracket type &lt;br&gt;     ct&lt;char&gt;    Selects forward to &lt;char&gt; (follow with 'i' to change selection) &lt;br&gt;     cT&lt;char&gt;    Selects backward to &lt;char&gt; (follow with 'i' to change selection) &lt;br&gt;     c&lt;cr&gt;       Change selected text &lt;br&gt;  &lt;br&gt; Delete commands:: &lt;br&gt;  &lt;br&gt;     x           Delete next character &lt;br&gt;     delete      Delete next character &lt;br&gt;     D           Delete to the end of the current line &lt;br&gt;     dd          Delete current line &lt;br&gt;     dw          Delete to end of word &lt;br&gt;     db          Delete to beginning of word &lt;br&gt;     d)          Delete to end of sentence &lt;br&gt;     d(          Delete to beginning of sentence &lt;br&gt;     d}          Delete to end of paragraph &lt;br&gt;     d{          Delete to start of paragraph &lt;br&gt;     d%          Delete from current bracket type to its apposing bracket &lt;br&gt;     dt&lt;ch&gt;      Delete to character (not limited to current line) &lt;br&gt;     d&lt;cr&gt;       Delete selected text &lt;br&gt;  &lt;br&gt;     J           Join next line to end of current line (deletes carriage return) &lt;br&gt;  &lt;br&gt; Yank text commands:: &lt;br&gt;  &lt;br&gt;     Y           Yank to end of line &lt;br&gt;     yy          Yank line &lt;br&gt;     yw          Yank to beginning of next word &lt;br&gt;     yb          Yank to beginning of current word &lt;br&gt;     y)          Yank to end of sentence &lt;br&gt;     y(          Yank to beginning of sentence &lt;br&gt;     y}          Yank to end of paragraph &lt;br&gt;     y{          Yank to beginning of paragraph &lt;br&gt;     y%          Yank from current bracket type to its opposing bracket &lt;br&gt;     yt&lt;char&gt;    Select forward to &lt;char&gt;  (use 'y&lt;cr&gt;' to yank selection) &lt;br&gt;     yT&lt;char&gt;    Select backward to &lt;char&gt; (use 'y&lt;cr&gt;' to yank selection) &lt;br&gt;     y&lt;cr&gt;       Yank selected text (Vim uses 'y' in visual mode) &lt;br&gt;  &lt;br&gt; Find character commands:: &lt;br&gt;  &lt;br&gt;     f           Find next occurrence of user specified character &lt;br&gt;     F           Find previous occurrence of user specified character &lt;br&gt;  &lt;br&gt; Find text commands:: &lt;br&gt;  &lt;br&gt;     /           Search forward within current node's body text &lt;br&gt;     ?           Search backward within current node's body text &lt;br&gt;     n           Find next (same scope, same direction) &lt;br&gt;     N           Find next (same scope, other direction) &lt;br&gt;  &lt;br&gt;     Note: See &quot;Search options&quot; in General Commands section to change options. &lt;br&gt;  &lt;br&gt; Replace [and find next] commands:: &lt;br&gt;  &lt;br&gt;     Commands using Paste buffer (clipboard) &lt;br&gt;     P           Paste text before cursor. &lt;br&gt;     p           Mapped to &quot;P&quot; until character based cursor supported. &lt;br&gt;     Ctrl-p      Paste then find next match &lt;br&gt;                 Note: Use 'pn' instead of 'Ctrl-p' in headlines (Leo limitation) &lt;br&gt;                       Command will continue to paste when match no longer found. &lt;br&gt;  &lt;br&gt;     Commands prompting for replace string &lt;br&gt;     Note: Scope and direction taken from last use of '/','?' or 'Ctrl-/'(scope only) &lt;br&gt;     Alt-/       Prompt for search &amp; replace string &lt;br&gt;     Alt-p       Replace then search (use after Alt-/) &lt;br&gt;                 Note: Works in headlines and body panes. &lt;br&gt;                       Doesn't paste unless last search found a match. &lt;br&gt;  &lt;br&gt; Indent/Unindent line commands:: &lt;br&gt;  &lt;br&gt;     &gt;&gt;          Indent the current line &lt;br&gt;     &gt;)          Indent to the end of sentence &lt;br&gt;     &gt;(          Indent to the beginning of sentence &lt;br&gt;     &gt;}          Indent to the end of paragraph &lt;br&gt;     &gt;{          Indent to the beginning of paragraph &lt;br&gt;     &gt;g          Indent to the start of buffer &lt;br&gt;     &gt;G          Indent to the end of buffer &lt;br&gt;  &lt;br&gt;     &lt;&gt;          Unindent the current line &lt;br&gt;     &lt;)          Unindent to the end of sentence &lt;br&gt;     &lt;(          Unindent to the beginning of sentence &lt;br&gt;     &lt;}          Unindent to the end of paragraph &lt;br&gt;     &lt;{          Unindent to the beginning of paragraph &lt;br&gt;     &lt;g          Unindent to the start of buffer &lt;br&gt;     &lt;G          Unindent to the end of buffer &lt;br&gt;  &lt;br&gt; Format commands:: &lt;br&gt;  &lt;br&gt;     gqap        Split long line into separate lines &lt;br&gt;     gwap        Split long line into separate lines &lt;br&gt;     gqq         Split long line into separate lines &lt;br&gt;     gww         Split long line into separate lines &lt;br&gt;  &lt;br&gt;     Note: 'gwap' and 'gww' should not move cursor but do. &lt;br&gt;  &lt;br&gt; Scroll commands:: &lt;br&gt;  &lt;br&gt;     Ctrl-b      Scroll text up by pane's height &lt;br&gt;     Ctrl-f      Scroll text down by pane's height &lt;br&gt;        Ctrl-y   Mapped to Ctrl-b until scroll up one line is supported &lt;br&gt;        Ctrl-e   Mapped to Ctrl-f until scroll down one line is supported &lt;br&gt;        Ctrl-u   Mapped to Ctrl-b until scroll up half a pane height is supported &lt;br&gt;        Ctrl-d   Mapped to Ctrl-f until scroll down half a pane height is supported &lt;br&gt;  &lt;br&gt; Window commands:: &lt;br&gt;  &lt;br&gt;     Ctrl-w s    Open another view into current node's body (Vim: Split window) &lt;br&gt;        Ctrl-w n Mapped to &quot;Ctrl-w s&quot; (Vim: New buffer in split window) &lt;br&gt;     Ctrl-w w    Switch to next view (Vim: Go to up/left window w/wrapping) &lt;br&gt;        Ctrl-w p Mapped to &quot;Ctrl-w w&quot; (Vim: Cycle through windows) &lt;br&gt;        Ctrl-w k Mapped to &quot;Ctrl-w w&quot; (Vim: Go to window above current window) &lt;br&gt;        Ctrl-w j Mapped to &quot;Ctrl-w w&quot; (Vim: Go to window below current window) &lt;br&gt;     Ctrl-w c    Close current view in body pane (Vim: Close current window) &lt;br&gt;        Ctrl-w q Mapped to &quot;Ctrl-w c&quot; (Vim: Quit current window) &lt;br&gt;  &lt;br&gt; Node commands:: &lt;br&gt;  &lt;br&gt;     Go to another node while focus remains in the body pane. &lt;br&gt;     Ctrl-j      Go to next visible node &lt;br&gt;     Ctrl-k      Go to previous visible node &lt;br&gt;     Ctrl-h      Hide sub-nodes or, if hidden, go up 1 level &lt;br&gt;     Ctrl-l      Display sub-nodes or, if displayed, go down 1 level &lt;br&gt;        Ctrl-DnArrow    Mapped to &quot;Ctrl-j&quot; for convenience &lt;br&gt;        Ctrl-UpArrow    Mapped to &quot;Ctrl-k&quot; for convenience &lt;br&gt;        Ctrl-LtArrow    Mapped to &quot;Ctrl-h&quot; for convenience &lt;br&gt;        Ctrl-RtArrow    Mapped to &quot;Ctrl-l&quot; for convenience &lt;br&gt; " id="1172" linkTypes="1" links="689" title="Body pane commands" />
<node body="The following commands are supported when in a headline's command mode. &lt;br&gt;  &lt;br&gt; State change commands:: &lt;br&gt;  &lt;br&gt;     Ctrl-i      Change state to command from grayed state &lt;br&gt;     return      Change state to command from insert state &lt;br&gt;     Ctrl-]      Change state to grayed from command state &lt;br&gt;  &lt;br&gt; Cursor movement commands:: &lt;br&gt;  &lt;br&gt;     h           Go to previous character &lt;br&gt;        LtArrow  Mapped to 'h' for convenience &lt;br&gt;     l           Go to next character &lt;br&gt;        RtArrow  Mapped to &quot;l&quot; for convenience &lt;br&gt;  &lt;br&gt;     Note: 'j' and 'k' will scroll the buffer contents up and down; &lt;br&gt;           leaving the focus in the outline pane. &lt;br&gt;  &lt;br&gt;     w           Go to beginning of next word &lt;br&gt;        W        Mapped to &quot;w&quot; until &quot;stop after blank characters&quot; supported &lt;br&gt;     b           Go to beginning of current/previous word &lt;br&gt;        B        Mapped to &quot;b&quot; until &quot;stop at blank character&quot; supported &lt;br&gt;     e           Go to end of current/next word &lt;br&gt;        E        Mapped to &quot;e&quot; until &quot;stop at blank character&quot; supported &lt;br&gt;  &lt;br&gt;     Note: Move by word commands stop at non-alpha characters &lt;br&gt;  &lt;br&gt;     |           Go to beginning of line &lt;br&gt;     ^           Go to beginning of line &lt;br&gt;     $           Go to end of line &lt;br&gt;  &lt;br&gt;     %           Go to matching bracket &lt;br&gt;  &lt;br&gt; Edit commands:: &lt;br&gt;  &lt;br&gt;     x           Delete next character &lt;br&gt;     delete      Delete next character &lt;br&gt;     dd          kill-line &lt;br&gt;  &lt;br&gt;     s           Select current character &lt;br&gt;  &lt;br&gt;     v           Toggle text select mode (issue cursor movement commands) &lt;br&gt;     y&lt;return&gt;   Yank selected text &lt;br&gt;  &lt;br&gt;     C           Select to end of line (follow with 'i' to change text) &lt;br&gt;     cc          Delete line (follow with 'i' to change text) &lt;br&gt;  &lt;br&gt;     D           Select to end of line (follow with 'x' to delete text) &lt;br&gt;     dd          Delete line &lt;br&gt;  &lt;br&gt;     Y           Select to end of line (follow with 'y&lt;return&gt;' to yank text) &lt;br&gt;     yy          Select line (follow with 'y&lt;return&gt;' to yank text) &lt;br&gt;  &lt;br&gt; Find character commands:: &lt;br&gt;  &lt;br&gt;     f           Find next occurrence of user specified character &lt;br&gt;     F           Find previous occurrence of user specified character &lt;br&gt;  &lt;br&gt; Find text commands:: &lt;br&gt;  &lt;br&gt;     /           Search forward within current node and its subnodes &lt;br&gt;     n           Find next (same scope, same direction) &lt;br&gt;     N           Find next (same scope, other direction) &lt;br&gt;  &lt;br&gt;     Note: See &quot;Search options&quot; section above to change options using 'Ctrl-/' &lt;br&gt;  &lt;br&gt; Replace [and find next] commands:: &lt;br&gt;  &lt;br&gt;     Commands that use Paste buffer (clipboard) &lt;br&gt;     Note: Paste-then-search command not possible in headlines (Use 'pn') &lt;br&gt;     P           Paste text before cursor. &lt;br&gt;     p           Mapped to &quot;P&quot; until character based cursor supported. &lt;br&gt;  &lt;br&gt;     Commands that prompt for the replace string &lt;br&gt;     Alt-/       Prompt for search &amp; replace string &lt;br&gt;     Alt-p       Replace then search (use after Alt-/) &lt;br&gt;                 Note: Works in headlines and body panes. &lt;br&gt;                       Doesn't paste unless last search found a match. &lt;br&gt;  &lt;br&gt; Node edit commands:: &lt;br&gt;  &lt;br&gt;     o           Insert node after current node &lt;br&gt;  &lt;br&gt;     Ctrl-x      Delete current node &lt;br&gt;     Ctrl-c      Yank current node &lt;br&gt;     Ctrl-v      Paste current node &lt;br&gt;  &lt;br&gt; Node goto commands:: &lt;br&gt;  &lt;br&gt;     G           Go to the outline's last node &lt;br&gt;     gg          Go to the outline's first node &lt;br&gt;  &lt;br&gt;     Ctrl-j      Go to next visible node &lt;br&gt;     Ctrl-k      Go to previous visible node &lt;br&gt;     Ctrl-h      Hide sub-nodes or, if hidden, go up 1 level &lt;br&gt;     Ctrl-l      Display sub-nodes or, if displayed, go down 1 level &lt;br&gt;  &lt;br&gt;        DnArrow  Mapped to &quot;Ctrl-j&quot; for convenience &lt;br&gt;        UpArrow  Mapped to &quot;Ctrl-k&quot; for convenience &lt;br&gt;  &lt;br&gt;        Ctrl-DnArrow Mapped to &quot;Ctrl-j&quot; for convenience &lt;br&gt;        Ctrl-UpArrow Mapped to &quot;Ctrl-k&quot; for convenience &lt;br&gt;        Ctrl-LtArrow Mapped to &quot;Ctrl-h&quot; for convenience &lt;br&gt;        Ctrl-RtArrow Mapped to &quot;Ctrl-l&quot; for convenience &lt;br&gt;  &lt;br&gt; Node move commands:: &lt;br&gt;  &lt;br&gt;     Ctrl-Shift-k    Move node down &lt;br&gt;     Ctrl-Shift-h    Move node left &lt;br&gt;     Ctrl-Shift-l    Move node right &lt;br&gt;     Ctrl-Shift-j    Move node up &lt;br&gt;  &lt;br&gt;        Ctrl-Shift-DnArrow    Mapped to &quot;Ctrl-Shift-k&quot; for convenience &lt;br&gt;        Ctrl-Shift-LtArrow    Mapped to &quot;Ctrl-Shift-h&quot; for convenience &lt;br&gt;        Ctrl-Shift-RtArrow    Mapped to &quot;Ctrl-Shift-l&quot; for convenience &lt;br&gt;        Ctrl-Shift-UpArrow    Mapped to &quot;Ctrl-Shift-j&quot; for convenience &lt;br&gt;  &lt;br&gt; Node mark commands:: &lt;br&gt;  &lt;br&gt;     m           Toggle node mark &lt;br&gt;     Ctrl-m      Go to next marked node &lt;br&gt;     Alt-m       Clear all marked nodes &lt;br&gt;  &lt;br&gt; Node clone commands:: &lt;br&gt;  &lt;br&gt;     t           Clone the current node (transclude) &lt;br&gt;     Ctrl-t      Go to next clone of current node &lt;br&gt;  &lt;br&gt; Outline scroll commands:: &lt;br&gt;  &lt;br&gt;    Ctrl-y       Scroll outline up one line &lt;br&gt;    Ctrl-e       scroll outline down one line &lt;br&gt;    Ctrl-u       Scroll outline up one half page &lt;br&gt;    Ctrl-d       scroll outline down one half page &lt;br&gt;    Ctrl-b       Scroll outline up one page &lt;br&gt;    Ctrl-f       scroll outline down one page &lt;br&gt;  &lt;br&gt; " id="1173" linkTypes="1" links="689" title="Outline commands" />
<node body="Notable missing editing commands:: &lt;br&gt;  &lt;br&gt;     t&lt;char&gt;     Move cursor to character before specified character &lt;br&gt;     r           Replace a single character with a single character &lt;br&gt;     0           Go to 1st column in current line (Use '|' instead) &lt;br&gt;     bksp        Move one character to the left &lt;br&gt;     ~           Toggle character's case &lt;br&gt;     .           Repeat last editing command &lt;br&gt;     ;           Repeat last cursor movement command &lt;br&gt;     &lt;n&gt;&lt;cmd&gt;    Perform command 'n' number of times &lt;br&gt;     &lt;cmd&gt;&lt;n&gt;&lt;object&gt;    Perform the command on the n'th or up to the n'th object &lt;br&gt;  &lt;br&gt; Notable missing body pane commands:: &lt;br&gt;  &lt;br&gt;     &lt;num&gt;G      Go to specified line number &lt;br&gt;     z&lt;movement&gt; Slide buffer to put current line at top/middle/bottom of pane &lt;br&gt;     '&lt;command&gt;  Go to line of last edit, jump, ... &lt;br&gt;     `&lt;command&gt;  Go to character of last edit, jump, ... &lt;br&gt; " id="1174" linkTypes="1" links="689" title="Commands not supported" />
<node body="If you use the open-with command to open a node text in Vim and your Vim's &quot;tag&quot; file refers to external files then there is a risk that a external file that is initially displayed via the &quot;tag&quot; command&quot; in Vim is accidentally edited and saved from the external Vim editor while your Leo session still contains the external file's original text that may later recreate the original external file during a Leo save operation (overwriting the changes saved from the Vim editor). &lt;br&gt;  &lt;br&gt; To prevent this problem, modifications to external files can be avoided by using Vim's &quot;modeline&quot; feature to disable editing of external files. &lt;br&gt;  &lt;br&gt; Vim's &quot;modeline&quot; feature scans each loaded buffer for text at the top or bottom of the file containing &quot; vim:&quot; followed by a series of Vim options. The text is usually embedded within a comment. The following example prevents modifications to a buffer in a Python file:: &lt;br&gt;  &lt;br&gt;     # vim:noma (A space is required between the '#' and &quot;vim:noma&quot;) &lt;br&gt;  &lt;br&gt; If this line is placed in a separate Leo node at the top or bottom of the list of nodes under a external file node (ex: @file) then any external file saved and then later loaded into Vim will, by default, not be modifiable. If a derived file does need to be edited then modifications can be re-enabled on a file-by-file basis by issuing Vim's &quot;:ma&quot; command while viewing the derived file. &lt;br&gt;  &lt;br&gt; The number of lines that Vim checks at the top and bottom of the buffer is configurable. The following Vim command must be placed in the vimrc file to allow for Leo's trailing sentinel lines:: &lt;br&gt;  &lt;br&gt;     set modelines=8 &lt;br&gt;  &lt;br&gt; Issue the &quot;:help modeline&quot; command within Vim for the more information about modelines. &lt;br&gt; " id="1175" linkTypes="1" links="689" title="Avoiding changes to 'tag' files" />
<node body="This function inits the zodb. pathToZodbStorage is the full path to the zodb storage file. You can call g.init_zodb as many times as you like. Only the first call for any path actually does anything: subsequent calls for a previously opened path simply return the same value as the first call. &lt;br&gt; " id="1176" linkTypes="1" links="706" title="g.init_zodb (pathToZodbStorage,verbose=True)" />
<node body="This vnode method returns v2, a copy of v that is completely detached from the outline. v2.fileIndex is unrelated to v.fileIndex initially, but it may be convenient to copy this field:: &lt;br&gt;  &lt;br&gt;     v2 = v.detach() &lt;br&gt;     v2.fileIndex = v.fileIndex &lt;br&gt; " id="1177" linkTypes="1" links="706" title="v.detach()" />
<node body="A **ruleset name** is a Python string having the form 'x_setname', where setname is the value of the SET attribute of the &lt;RULES&gt; element in x.xml. For example, the ruleset name of the ruleset whose SET attribute is JAVASCRIPT in php.xml is 'php_JAVASCRIPT'. **Important**: by convention, the ruleset name of the default &lt;RULES&gt; element is 'x_main'; note that default &lt;RULES&gt; element have no SET attributes. &lt;br&gt;  &lt;br&gt; The colorizer uses ruleset names to gain access to all data structures in x.py. To anticipate a bit, ruleset names are keys into two standard dictionaries, x.rulesDict and x.keywordsDictDict, from which the colorizer can get all other information in x.py:: &lt;br&gt;  &lt;br&gt;     # The rules list for the 'JAVASCRIPT' ruleset in php.xml. &lt;br&gt;     rules = x.rulesDict('php_JAVASCRIPT') &lt;br&gt;  &lt;br&gt;     # The keywords dict for the 'JAVASCRIPT' ruleset in php.xml. &lt;br&gt;     keywordsDict = x.keywordsDictDict('php_JAVASCRIPT') &lt;br&gt;  &lt;br&gt; In fact, ruleset names (and x.rulesDict and x.keywordsDictDict) are the **only** names that the colorizer needs to know in order to access all information in x.py. &lt;br&gt; " id="1178" linkTypes="1" links="710" title="Ruleset names" />
<node body="**x.properties** is a Python dictionary corresponding to the &lt;PROPS&gt; element in x.xml. Keys are property names; values are strings, namely the contents of &lt;PROPERTY&gt; elements in x.xml. x.properties contains properties for the entire mode. That is, only modes have &lt;PROPS&gt; elements. For example, here is x.properties in php.py:: &lt;br&gt;  &lt;br&gt;     # properties for mode php.xml &lt;br&gt;     properties = { &lt;br&gt;         &quot;commentEnd&quot;: &quot;--&gt;&quot;, &lt;br&gt;         &quot;commentStart&quot;: &quot;&lt;!--&quot;, &lt;br&gt;         &quot;indentCloseBrackets&quot;: &quot;}&quot;, &lt;br&gt;         &quot;indentOpenBrackets&quot;: &quot;{&quot;, &lt;br&gt;         &quot;lineUpClosingBracket&quot;: &quot;true&quot;, &lt;br&gt;     } &lt;br&gt; " id="1179" linkTypes="1" links="710" title="x.properties" />
<node body="x.py contains a **attribute dictionary** for each ruleset in x.xml. Keys are attribute names, values strings representing the values of the attributes. This dictionary is empty if a ruleset contains no attributes. The valid keys are: &lt;br&gt;  &lt;br&gt; - 'default': the default token type.  'null' is the default. &lt;br&gt;  &lt;br&gt; - 'digit_re': a regular expression. &lt;br&gt;   Words matching this regular expression are colored with the digit token type. &lt;br&gt;  &lt;br&gt; - 'ignore_case': 'true' or 'false'.  Default is 'true'. &lt;br&gt;  &lt;br&gt; - 'highlight_digits': 'true' or 'false'.  Default is 'true'. &lt;br&gt;  &lt;br&gt; - 'no_word_sep': A list of characters treated as 'alphabetic' characters when matching keywords. &lt;br&gt;  &lt;br&gt; For example, here is one attribute dictionary in php.py:: &lt;br&gt;  &lt;br&gt;     # Attributes dict for php_javascript ruleset. &lt;br&gt;     php_javascript_attributes_dict = { &lt;br&gt;         &quot;default&quot;: &quot;MARKUP&quot;, &lt;br&gt;         &quot;digit_re&quot;: &quot;&quot;, &lt;br&gt;         &quot;highlight_digits&quot;: &quot;true&quot;, &lt;br&gt;         &quot;ignore_case&quot;: &quot;true&quot;, &lt;br&gt;         &quot;no_word_sep&quot;: &quot;&quot;, &lt;br&gt;     } &lt;br&gt;  &lt;br&gt; x.py also contains **x.attributesDictDict**. Keys are ruleset names, values are attribute dictionaries. Here is attributesDictDict for php.py:: &lt;br&gt;  &lt;br&gt;     # Dictionary of attributes dictionaries for php mode. &lt;br&gt;     attributesDictDict = { &lt;br&gt;         &quot;php_javascript&quot;: php_javascript_attributes_dict, &lt;br&gt;         &quot;php_javascript_php&quot;: php_javascript_php_attributes_dict, &lt;br&gt;         &quot;php_main&quot;: php_main_attributes_dict, &lt;br&gt;         &quot;php_php&quot;: php_php_attributes_dict, &lt;br&gt;         &quot;php_php_literal&quot;: php_php_literal_attributes_dict, &lt;br&gt;         &quot;php_phpdoc&quot;: php_phpdoc_attributes_dict, &lt;br&gt;         &quot;php_tags&quot;: php_tags_attributes_dict, &lt;br&gt;         &quot;php_tags_literal&quot;: php_tags_literal_attributes_dict, &lt;br&gt;     } &lt;br&gt;  &lt;br&gt; **Note**: The jEdit2Py script creates 'friendly' names for attribute dictionaries *solely* as an aid for people reading the code. Leo's colorer uses only the name x.attributeDictDict; Leo's colorer never uses the actual names of attribute dictionaries. &lt;br&gt; " id="1180" linkTypes="1" links="710" title="Attribute dictionaries and x.attributesDictDict" />
<node body="x.py contains a **keyword dictionary** for each ruleset in x.xml. x.py contains an empty keywords dictionary if a ruleset contains no &lt;KEYWORDS&gt; element. &lt;br&gt;  &lt;br&gt; Keys are strings representing keywords of the language describe by the mode. Values are strings representing syntactic categories, i.e. a TYPE attribute valid in x.xml, namely: COMMENT1, COMMENT2, COMMENT3, COMMENT4, FUNCTION, KEYWORD1, KEYWORD2, KEYWORD3, KEYWORD4, LABEL, LITERAL1, LITERAL2, LITERAL3, LITERAL4, MARKUP, NULL and OPERATOR. &lt;br&gt;  &lt;br&gt; For example, here (parts of) some keyword dictionaries in php.py:: &lt;br&gt;  &lt;br&gt;     # Keywords dict for mode php::PHP &lt;br&gt;     php_PHP_keywords_dict = { &lt;br&gt;         &quot;COM_invoke&quot;: &quot;keyword2&quot;, &lt;br&gt;         &quot;COM_load&quot;: &quot;keyword2&quot;, &lt;br&gt;         &quot;__CLASS__&quot;: &quot;keyword3&quot;, &lt;br&gt;         ... &lt;br&gt;         &quot;abs&quot;: &quot;keyword2&quot;, &lt;br&gt;         &quot;abstract&quot;: &quot;keyword1&quot;, &lt;br&gt;         &quot;accept_connect&quot;: &quot;keyword2&quot;, &lt;br&gt;         ... &lt;br&gt;     } &lt;br&gt;  &lt;br&gt;     # Keywords dict for mode php::JAVASCRIPT_PHP &lt;br&gt;     php_JAVASCRIPT_PHP_keywords_dict = {} &lt;br&gt;  &lt;br&gt;     # Keywords dict for mode php::PHPDOC &lt;br&gt;     php_PHPDOC_keywords_dict = { &lt;br&gt;         &quot;@abstract&quot;: &quot;label&quot;, &lt;br&gt;         &quot;@access&quot;: &quot;label&quot;, &lt;br&gt;         &quot;@author&quot;: &quot;label&quot;, &lt;br&gt;         ... &lt;br&gt;         &quot;@var&quot;: &quot;label&quot;, &lt;br&gt;         &quot;@version&quot;: &quot;label&quot;, &lt;br&gt;     } &lt;br&gt;  &lt;br&gt; x.py also contains **x.keywordsDictDict**. Keys are ruleset names, values are keywords dictionaries. Here is keywordsDictDict for php.py:: &lt;br&gt;  &lt;br&gt;     # Dictionary of keywords dictionaries for php mode. &lt;br&gt;     keywordsDictDict = { &lt;br&gt;         &quot;php_javascript&quot;: php_javascript_keywords_dict, &lt;br&gt;         &quot;php_javascript_php&quot;: php_javascript_php_keywords_dict, &lt;br&gt;         &quot;php_main&quot;: php_main_keywords_dict, &lt;br&gt;         &quot;php_php&quot;: php_php_keywords_dict, &lt;br&gt;         &quot;php_php_literal&quot;: php_php_literal_keywords_dict, &lt;br&gt;         &quot;php_phpdoc&quot;: php_phpdoc_keywords_dict, &lt;br&gt;         &quot;php_tags&quot;: php_tags_keywords_dict, &lt;br&gt;         &quot;php_tags_literal&quot;: php_tags_literal_keywords_dict, &lt;br&gt;     } &lt;br&gt;  &lt;br&gt; The colorizer can get the keywords dictionary for a ruleset as follows:: &lt;br&gt;  &lt;br&gt;     keywordsDict = x.keywordsDictDict(rulesetName) &lt;br&gt;  &lt;br&gt; **Note**: The jEdit2Py script creates 'friendly' names for keyword dictionaries *solely* as an aid for people reading the code. Leo's colorer uses only the name x.keywordsDictDict; Leo's colorer never uses the actual names of keywords dictionaries such as php_PHPDOC_keywords_dict. &lt;br&gt; " id="1181" linkTypes="1" links="710" title="Keyword dictionaries and x.keywordsDictDict" />
<node body="x.py contains one **rule function** for every rule in every ruleset (&lt;RULES&gt; element) in x.xml. These rules have names rule1 through  ruleN, where N is the total number of rules in all rulesets in x.xml. &lt;br&gt;  &lt;br&gt; Each rules *function* merely calls a rules *method* in Leo's colorizer. Which method gets called depends on the corresponding element in `x.xml`. For example, the first rule in php.xml is:: &lt;br&gt;  &lt;br&gt;     &lt;SPAN TYPE=&quot;MARKUP&quot; DELEGATE=&quot;PHP&quot;&gt; &lt;br&gt; 		&lt;BEGIN&gt;&amp;lt;?php&lt;/BEGIN&gt; &lt;br&gt; 		&lt;END&gt;?&amp;gt;&lt;/END&gt; &lt;br&gt; 	&lt;/SPAN&gt; &lt;br&gt;  &lt;br&gt; and the corresponding rule function is:: &lt;br&gt;  &lt;br&gt;     def php_rule0(colorer, s, i): &lt;br&gt;         return colorer.match_span(s, i, kind=&quot;markup&quot;, begin=&quot;&lt;?php&quot;, end=&quot;?&gt;&quot;, &lt;br&gt;             at_line_start=False, at_whitespace_end=False, at_word_start=False, &lt;br&gt;             delegate=&quot;PHP&quot;,exclude_match=False, &lt;br&gt;             no_escape=False, no_line_break=False, no_word_break=False) &lt;br&gt;  &lt;br&gt;  &lt;br&gt; php_rule0 calls colorer.match_span because the corresponding xml rule is a &lt;SPAN&gt; element. &lt;br&gt;  &lt;br&gt; For each ruleset, x.py also contains a **rules dictionary**, a Python dictionary whose keys are characters and whose values are all lists of rules functions that that can match the key. For example:: &lt;br&gt;  &lt;br&gt;     # Rules dict for phpdoc ruleset. &lt;br&gt;     rulesDict8 = { &lt;br&gt;         &quot;*&quot;: [rule64,], &lt;br&gt;         &quot;0&quot;: [rule70,], &lt;br&gt;         &quot;1&quot;: [rule70,], &lt;br&gt;         &quot;2&quot;: [rule70,], &lt;br&gt;         &quot;3&quot;: [rule70,], &lt;br&gt;         &quot;4&quot;: [rule70,], &lt;br&gt;         &quot;5&quot;: [rule70,], &lt;br&gt;         &quot;6&quot;: [rule70,], &lt;br&gt;         &quot;7&quot;: [rule70,], &lt;br&gt;         &quot;8&quot;: [rule70,], &lt;br&gt;         &quot;9&quot;: [rule70,], &lt;br&gt;         &quot;&lt;&quot;: [rule65,rule66,rule67,rule68,rule69,], &lt;br&gt;         &quot;@&quot;: [rule70,], &lt;br&gt;         &quot;A&quot;: [rule70,], &lt;br&gt;         &quot;B&quot;: [rule70,], &lt;br&gt;         ... &lt;br&gt;         &quot;X&quot;: [rule70,], &lt;br&gt;         &quot;Y&quot;: [rule70,], &lt;br&gt;         &quot;Z&quot;: [rule70,], &lt;br&gt;         &quot;_&quot;: [rule70,], &lt;br&gt;         &quot;a&quot;: [rule70,], &lt;br&gt;         &quot;b&quot;: [rule70,], &lt;br&gt;        ... &lt;br&gt;         &quot;x&quot;: [rule70,], &lt;br&gt;         &quot;y&quot;: [rule70,], &lt;br&gt;         &quot;z&quot;: [rule70,], &lt;br&gt;         &quot;{&quot;: [rule63,], &lt;br&gt;     } &lt;br&gt;  &lt;br&gt; **Note**: The order of rules in each rules list is important; it should be the same as rules element in x.xml. &lt;br&gt;  &lt;br&gt; Finally, x.py contains **x.rulesDictDict**. Keys are ruleset names, values are rules dictionaries. The colorer can get the rules list for character ch as follows:: &lt;br&gt;  &lt;br&gt;     self.rulesDict = x.rulesDictDict.get(rulesetName) # When a mode is inited. &lt;br&gt;     ... &lt;br&gt;     rules = self.rulesDict.get(ch,[]) # In the main loop. &lt;br&gt;  &lt;br&gt; For example, here is the rules dictionary for php.py:: &lt;br&gt;  &lt;br&gt;     # x.rulesDictDict for php mode. &lt;br&gt;     rulesDictDict = { &lt;br&gt;         &quot;php_javascript&quot;: rulesDict6, &lt;br&gt;         &quot;php_javascript_php&quot;: rulesDict7, &lt;br&gt;         &quot;php_main&quot;: rulesDict1, &lt;br&gt;         &quot;php_php&quot;: rulesDict4, &lt;br&gt;         &quot;php_php_literal&quot;: rulesDict5, &lt;br&gt;         &quot;php_phpdoc&quot;: rulesDict8, &lt;br&gt;         &quot;php_tags&quot;: rulesDict2, &lt;br&gt;         &quot;php_tags_literal&quot;: rulesDict3, &lt;br&gt;     } &lt;br&gt;  &lt;br&gt; **Note**: The jEdit2Py script creates 'friendly' names for rules lists *solely* as an aid for people reading the code. Leo's colorer uses only the name x.rulesDictDict; Leo's colorer never uses the actual names of rules lists such as rulesDict8, and Leo's colorer never uses the actual names of rules functions such as rule64. &lt;br&gt; " id="1182" linkTypes="1" links="710" title="Rules, rules dictionaries and x.rulesDictDict" />
<node body="x.importDict is a Python dictionary. Keys are ruleset names; values are a list of ruleset names. For example:: &lt;br&gt;  &lt;br&gt;     # Import dict for php mode. &lt;br&gt;     importDict = { &lt;br&gt;         &quot;php_javascript_php&quot;: [&quot;javascript::main&quot;], &lt;br&gt;     } &lt;br&gt;  &lt;br&gt; For any ruleset R whose ruleset name is N, x.importDict.get(N) is the list of rulesets names whose rulesets appear in a DELEGATE attribute of an &lt;IMPORT&gt; rule element in R's ruleset. Such **imported** ruleset are copied to the end of the R's rules list. Leo's colorizer does this copying only once, when loading ruleset R for the first time. &lt;br&gt;  &lt;br&gt; **Note 1**: Loading imported rulesets must be done at 'run time'. It should definitely not be done by jEdit2Py at 'compile time'; that would require running jEdit2Py on *all* .xml files whenever any such file changed. &lt;br&gt;  &lt;br&gt; **Note 2**:  Multiple &lt;IMPORT&gt; rule elements in a single ruleset are allowed: delegated rules are copied to the end of N's rules list in the order they appear in the ruleset. &lt;br&gt;  &lt;br&gt; **Note 3**: The DELEGATE attribute of &lt;IMPORT&gt; elements is, in fact, completely separate from the DELEGATE attributes of other rules as discussed in `Arguments to rule methods`_. Indeed, the DELEGATE attribute of &lt;IMPORT&gt; elements creates entries in x.importDict, which in turn causes the colorizer to append the rules of the imported ruleset to the end of the present rules list. In contrast, the DELEGATE attributes of other rules sets the delegate argument to rules methods, which in tern causes the colorizer to recursively color the matched text with the **delegated** ruleset. In short: &lt;br&gt;  &lt;br&gt; - The rules of **imported** rulesets are appended to the end of another rules list; the rules of **delegated** rulesets never are. &lt;br&gt;  &lt;br&gt; - **Imported** ruleset names appear as the values of items in x.importDict; **delegated** ruleset names appear as delegate arguments to rule methods. &lt;br&gt; " id="1183" linkTypes="1" links="710" title="x.importDict and imported versus delegated rulesets" />
<node body=".. _`Ruleset name`: `Ruleset names`_ &lt;br&gt;  &lt;br&gt; All rule methods take three required arguments and zero or more optional keyword arguments. &lt;br&gt;  &lt;br&gt; Here is a list of the required arguments and their meaning: &lt;br&gt;  &lt;br&gt; - **self**: An instance of Leo's colorizer. &lt;br&gt;  &lt;br&gt; - **s**: The string in which matches may be found. &lt;br&gt;  &lt;br&gt; - **i**: The location within the string at which the rule method looks for a match. &lt;br&gt;  &lt;br&gt; Here is a list of all optional keyword arguments and their meaning: &lt;br&gt;  &lt;br&gt; - **at_line_start**: &lt;br&gt;   If True, a match will succeed only if i is at the start of a line. &lt;br&gt;  &lt;br&gt; - **at_whitespace_end**: &lt;br&gt;   If True, the match will succeed only if i is at the first non-whitespace text in a line. &lt;br&gt;  &lt;br&gt; - **at_word_start**: &lt;br&gt;   If True, the match will succeed only if i is at the beginning of a word. &lt;br&gt;  &lt;br&gt; - **delegate**: &lt;br&gt;   If non-empty, the value of this argument is a `ruleset name`_. &lt;br&gt;   If the match succeeds, the matched text will be colored recursively with the indicate ruleset. &lt;br&gt;  &lt;br&gt; - **exclude_match**: &lt;br&gt;   If True, the actual text that matched will not be colored. &lt;br&gt;   The meaning of this argument varies slightly depending on whether one or two sequences are matched. &lt;br&gt;   See the individual rule methods for details. &lt;br&gt;  &lt;br&gt; - **kind**: A string representing a class of tokens, i.e., one of: &lt;br&gt;   'comment1', 'comment2', 'comment3', 'comment4', 'function', &lt;br&gt;   'keyword1', 'keyword2', 'keyword3', 'keyword4', &lt;br&gt;   'label', 'literal1', 'literal2', 'literal3', 'literal4', &lt;br&gt;   'markup', 'null' and 'operator'. &lt;br&gt;  &lt;br&gt; - **no_escape**: &lt;br&gt;   If True, the ruleset's escape character will have no effect before the end argument to match_span. &lt;br&gt;   Otherwise, the presence of the escape character will cause that occurrence of the end string to be ignored. &lt;br&gt;  &lt;br&gt; - **no_line_break**: &lt;br&gt;   If True, the match will not succeed across line breaks. &lt;br&gt;  &lt;br&gt; - **no_word_break**: &lt;br&gt;   If True, the match will not cross word breaks. &lt;br&gt;  &lt;br&gt; New in Leo 4.4.1 final: the regular expression rule matchers no longer get a hash_char argument &lt;br&gt; because such matchers are called only if the present search pattern starts with hash_char. &lt;br&gt; " id="1184" linkTypes="1" links="711" title="Arguments to rule methods" />
<node body=":: &lt;br&gt;  &lt;br&gt;     def match_eol_span (self,s,i,kind,begin, &lt;br&gt;         at_line_start = False, &lt;br&gt;         at_whitespace_end = False, &lt;br&gt;         at_word_start = False, &lt;br&gt;         delegate = '', &lt;br&gt;         exclude_match = False): &lt;br&gt;  &lt;br&gt; match_eol_span succeeds if s[i:].startswith(begin) and the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied. &lt;br&gt;  &lt;br&gt; If successful, match_eol_span highlights from i to the end of the line with the color specified by kind. If the exclude_match argument is True, only the text before the matched text will be colored. The delegate argument, if present, specifies the ruleset to color the colored text. &lt;br&gt; " id="1185" linkTypes="1" links="711" title="match_eol_span" />
<node body=":: &lt;br&gt;  &lt;br&gt;     def match_eol_span_regexp (self,s,i,kind,regex, &lt;br&gt;         at_line_start = False, &lt;br&gt;         at_whitespace_end = False, &lt;br&gt;         at_word_start = False, &lt;br&gt;         delegate = '', &lt;br&gt;         exclude_match = False): &lt;br&gt;  &lt;br&gt; match_eol_span_exp succeeds if: &lt;br&gt;  &lt;br&gt; 1. The regular expression regex matches at s[i:], and &lt;br&gt;  &lt;br&gt; 2. The at_line_start, at_whitespace_end and at_word_start conditions are all satisfied. &lt;br&gt;  &lt;br&gt; If successful, match_eol_span_regexp  highlights from i to the end of the line. If the exclude_match argument is True, only the text before the matched text will be colored. The delegate argument, if present, specifies the ruleset to color the colored text. &lt;br&gt; " id="1186" linkTypes="1" links="711" title="match_eol_span_regexp" />
<node body=":: &lt;br&gt;  &lt;br&gt;     def match_keywords (self,s,i): &lt;br&gt;  &lt;br&gt; match_keywords succeeds if s[i:] starts with an identifier contained in the mode's keywords dictionary d. &lt;br&gt;  &lt;br&gt; If successful, match_keywords colors the keyword. match_keywords does not take a kind keyword argument. Instead, the keyword is colored as specified by d.get(theKeyword). &lt;br&gt; " id="1187" linkTypes="1" links="711" title="match_keywords" />
<node body=":: &lt;br&gt;  &lt;br&gt;     def match_mark_following (self,s,i,kind,pattern, &lt;br&gt;         at_line_start = False, &lt;br&gt;         at_whitespace_end = False, &lt;br&gt;         at_word_start = False, &lt;br&gt;         exclude_match = False): &lt;br&gt;  &lt;br&gt; match_mark_following succeeds if s[i:].startswith(pattern), and the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied. &lt;br&gt;  &lt;br&gt; If successful, match_mark_following colors from i to the start of the next token with the color specified by kind. If the exclude_match argument is True, only the text after the matched text will be colored. &lt;br&gt; " id="1188" linkTypes="1" links="711" title="match_mark_following" />
<node body=":: &lt;br&gt;  &lt;br&gt;     def match_mark_previous (self,s,i,kind,pattern, &lt;br&gt;         at_line_start = False, &lt;br&gt;         at_whitespace_end = False, &lt;br&gt;         at_word_start = False, &lt;br&gt;         exclude_match = False): &lt;br&gt;  &lt;br&gt; match_mark_previous succeeds if s[i:].startswith(pattern),and the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied. &lt;br&gt;  &lt;br&gt; If successful, match_mark_previous colors from the end of the previous token to i with the color specified by kind. If the exclude_match argument is True, only the text before the matched text will be colored. &lt;br&gt; " id="1189" linkTypes="1" links="711" title="match_mark_previous" />
<node body=":: &lt;br&gt;  &lt;br&gt;     def match_seq (self,s,i,kind,seq, &lt;br&gt;         at_line_start = False, &lt;br&gt;         at_whitespace_end = False, &lt;br&gt;         at_word_start = False, &lt;br&gt;         delegate = ''): &lt;br&gt;  &lt;br&gt; match_seq succeeds if s[i:].startswith(seq) and the at_line_start, at_whitespace_end and at_word_start conditions are all satisfied. &lt;br&gt;  &lt;br&gt; If successful, match_seq highlights from i to the end of the sequence with the color specified by kind. The delegate argument, if present, specifies the ruleset to color the colored text. &lt;br&gt; " id="1190" linkTypes="1" links="711" title="match_seq" />
<node body=":: &lt;br&gt;  &lt;br&gt;     def match_seq_regexp (self,s,i,kind,regex, &lt;br&gt;         at_line_start = False, &lt;br&gt;         at_whitespace_end = False, &lt;br&gt;         at_word_start = False, &lt;br&gt;         delegate = ''): &lt;br&gt;  &lt;br&gt; match_seq succeeds if: &lt;br&gt;  &lt;br&gt; 1. The regular expression regex matches at s[i:], and &lt;br&gt;  &lt;br&gt; 2. The at_line_start, at_whitespace_end and at_word_start conditions are all satisfied. &lt;br&gt;  &lt;br&gt; If successful, match_seq_regexp highlights from i to the end of the sequence with the color specified by kind. The delegate argument, if present, specifies the ruleset to color the colored text. &lt;br&gt; " id="1191" linkTypes="1" links="711" title="match_seq_regexp" />
<node body=":: &lt;br&gt;  &lt;br&gt;     def match_span (self,s,i,kind,begin,end, &lt;br&gt;         at_line_start = False, &lt;br&gt;         at_whitespace_end = False, &lt;br&gt;         at_word_start = False, &lt;br&gt;         exclude_match = False, &lt;br&gt;         delegate = '' &lt;br&gt;         no_escape = False, &lt;br&gt;         no_line_break = False, &lt;br&gt;         no_word_break = False): &lt;br&gt;  &lt;br&gt; match_span succeeds if there is an index j &gt; i such that s[:i].startswith(begin) and s[i:j].endswith(end) and the at_line_start, at_whitespace_end, at_word_start, no_escape, no_line_break and no_word_break conditions are all satisfied. &lt;br&gt;  &lt;br&gt; If successful, match_span highlights from s[i:j with the color specified by kind; but if the exclude_match argument is True, the begin and end text are not colored. The delegate argument, if present, specifies the ruleset to color the colored text. &lt;br&gt; " id="1192" linkTypes="1" links="711" title="match_span" />
<node body=":: &lt;br&gt;  &lt;br&gt;     def match_span (self,s,i,kind,regex,end, &lt;br&gt;         at_line_start = False, &lt;br&gt;         at_whitespace_end = False, &lt;br&gt;         at_word_start = False, &lt;br&gt;         exclude_match = False, &lt;br&gt;         delegate = '' &lt;br&gt;         no_escape = False, &lt;br&gt;         no_line_break = False, &lt;br&gt;         no_word_break = False): &lt;br&gt;  &lt;br&gt; match_span_regex succeeds if: &lt;br&gt;  &lt;br&gt; 1. The regular expression regex matches at s[i:], &lt;br&gt;  &lt;br&gt; 2. There is an index j &gt; i such that s[i:j].endswith(end), &lt;br&gt;  &lt;br&gt; 3. The at_line_start, at_whitespace_end, at_word_start, &lt;br&gt;    no_escape, no_line_break and no_word_break conditions are all satisfied. &lt;br&gt;  &lt;br&gt; If successful, match_span colors s[i:j], with the color specified by kind; but if the exclude_match argument is True, the begin and end text are not colored. The delegate argument, if present, specifies the ruleset to color the colored text. &lt;br&gt; " id="1193" linkTypes="1" links="711" title="match_span_regexp" />
<node body=":: &lt;br&gt;  &lt;br&gt;     def match_terminate (self,s,i,kind,at_char): &lt;br&gt;  &lt;br&gt; match_terminate succeeds if s[i:] contains at least at_char more characters. &lt;br&gt;  &lt;br&gt; If successful, match_terminate colors at_char characters with the color specified by kind. &lt;br&gt; " id="1194" linkTypes="1" links="711" title="match_terminate" />
<node body="The following table tells about each event handler: its name, when it is called, &lt;br&gt; and the additional arguments passed to the hook in the keywords dictionary. &lt;br&gt; For some kind of hooks, Leo will skip its own normal processing if the hook &lt;br&gt; returns anything *other* than None. The table indicates such hooks with 'yes' in &lt;br&gt; the 'Stop?' column. &lt;br&gt;  &lt;br&gt; **Important**: Ever since Leo 4.2, the v, old_v and new_v keys in &lt;br&gt; the keyword dictionary contain *positions*, not vnodes. These keys are &lt;br&gt; deprecated. The new_c key is also deprecated. Plugins should use the c key instead. &lt;br&gt;  &lt;br&gt; ============================= ======== =================================== ============================= &lt;br&gt; Event name (tag argument)     Stop?    When called                         Keys in keywords dict &lt;br&gt; ============================= ======== =================================== ============================= &lt;br&gt; 'after-auto'                           after each @auto file loaded        c,p (note 13) &lt;br&gt; 'after-create-leo-frame'               after creating any frame            c &lt;br&gt; 'after-redraw-outline'                 end of tree.redraw                  c (note 6) &lt;br&gt; 'before-create-leo-frame'              before frame.finishCreate           c &lt;br&gt; 'bodyclick1'                   yes     before normal click in body         c,p,v,event &lt;br&gt; 'bodyclick2'                           after normal click in body          c,p,v,event &lt;br&gt; 'bodydclick1'                  yes     before double click in body         c,p,v,event &lt;br&gt; 'bodydclick2'                          after  double click in body         c,p,v,event &lt;br&gt; 'bodykey1'                     yes     before body keystrokes              c,p,v,ch,oldSel,undoType &lt;br&gt; 'bodykey2'                             after  body keystrokes              c,p,v,ch,oldSel,undoType &lt;br&gt; 'bodyrclick1'                  yes     before right click in body          c,p,v,event &lt;br&gt; 'bodyrclick2'                          after  right click in body          c,p,v,event &lt;br&gt; 'boxclick1'                    yes     before click in +- box              c,p,v,event &lt;br&gt; 'boxclick2'                            after  click in +- box              c,p,v,event &lt;br&gt; 'clear-all-marks'                      after clear-all-marks command       c,p,v &lt;br&gt; 'clear-mark'                           when mark is set                    c,p,v &lt;br&gt; 'close-frame'                          in app.closeLeoWindow               c &lt;br&gt; 'color-optional-markup'        yes *   (note 7)                            colorer,p,v,s,i,j,colortag (note 7) &lt;br&gt; 'command1'                     yes     before each command                 c,p,v,label (note 2) &lt;br&gt; 'command2'                             after  each command                 c,p,v,label (note 2) &lt;br&gt; 'create-optional-menus'                (note 8)                            c (note 8) &lt;br&gt; 'create-popup-menu-items'              in tree.OnPopup                     c,p,v,event (new) &lt;br&gt; 'draw-outline-box'             yes     when drawing +- box                 tree,p,v,x,y &lt;br&gt; 'draw-outline-icon'            yes     when drawing icon                   tree,p,v,x,y &lt;br&gt; 'draw-outline-node'            yes     when drawing node                   tree,p,v,x,y &lt;br&gt; 'draw-outline-text-box'        yes     when drawing headline               tree,p,v,x,y &lt;br&gt; 'drag1'                        yes     before start of drag                c,p,v,event &lt;br&gt; 'drag2'                                after  start of drag                c,p,v,event &lt;br&gt; 'dragging1'                    yes     before continuing to drag           c,p,v,event &lt;br&gt; 'dragging2'                            after  continuing to drag           c,p,v,event &lt;br&gt; 'enable-popup-menu-items'              in tree.OnPopup                     c,p,v,event &lt;br&gt; 'end1'                                 start of app.quit()                 None &lt;br&gt; 'enddrag1'                     yes     before end of drag                  c,p,v,event &lt;br&gt; 'enddrag2'                             after  end of drag                  c,p,v,event &lt;br&gt; 'headclick1'                   yes     before normal click in headline     c,p,v,event &lt;br&gt; 'headclick2'                           after  normal click in headline     c,p,v,event &lt;br&gt; 'headrclick1'                  yes     before right click in headline      c,p,v,event &lt;br&gt; 'headrclick2'                          after  right click in headline      c,p,v,event &lt;br&gt; 'headkey1'                     yes     before headline keystrokes          c,p,v,ch (note 12) &lt;br&gt; 'headkey2'                             after  headline keystrokes          c,p,v,ch (note 12) &lt;br&gt; 'hoist-changed'                        whenever the hoist stack changes    c &lt;br&gt; 'hypercclick1'                 yes     before control click in hyperlink   c,p,v,event &lt;br&gt; 'hypercclick2'                         after  control click in hyperlink   c,p,v,event &lt;br&gt; 'hyperenter1'                  yes     before entering hyperlink           c,p,v,event &lt;br&gt; 'hyperenter2'                          after  entering hyperlink           c,p,v,event &lt;br&gt; 'hyperleave1'                  yes     before leaving  hyperlink           c,p,v,event &lt;br&gt; 'hyperleave2'                          after  leaving  hyperlink           c,p,v,event &lt;br&gt; 'iconclick1'                   yes     before single click in icon box     c,p,v,event (note 15) &lt;br&gt; 'iconclick2'                           after  single click in icon box     c,p,v,event (note 15) &lt;br&gt; 'iconrclick1'                  yes     before right click in icon box      c,p,v,event (note 15) &lt;br&gt; 'iconrclick2'                          after  right click in icon box      c,p,v,event (note 15) &lt;br&gt; 'icondclick1'                  yes     before double click in icon box     c,p,v,event (note 15) &lt;br&gt; 'icondclick2'                          after  double click in icon box     c,p,v,event (note 15) &lt;br&gt; 'idle'                                 periodically (at idle time)         c &lt;br&gt; 'init-color-markup'                    (note 7)                            colorer,p,v (note 7) &lt;br&gt; 'menu1'                        yes     before creating menus               c,p,v (note 3) &lt;br&gt; 'menu2'                        yes     during creating menus               c,p,v (note 3) &lt;br&gt; 'menu-update'                  yes     before updating menus               c,p,v &lt;br&gt; 'new'                                  start of New command                c,old_c,new_c (note 9) &lt;br&gt; 'open1'                        yes     before opening any file             c,old_c,new_c,fileName (note 4) &lt;br&gt; 'open2'                                after  opening any file             c,old_c,new_c,fileName (note 4) &lt;br&gt; 'openwith1'                    yes     before Open With command            c,p,v,d (note 14) &lt;br&gt; 'openwith2'                            after  Open With command            c,p,v,(note 14) &lt;br&gt; 'recentfiles1'                 yes     before Recent Files command         c,p,v,fileName,closeFlag &lt;br&gt; 'recentfiles2'                         after  Recent Files command         c,p,v,fileName,closeFlag &lt;br&gt; 'redraw-entire-outline'        yes     start of tree.redraw                c (note 6) &lt;br&gt; 'save1'                        yes     before any Save command             c,p,v,fileName &lt;br&gt; 'save2'                                after  any Save command             c,p,v,fileName &lt;br&gt; 'scan-directives'                      in scanDirectives                   c,p,v,s,old_dict,dict,pluginsList (note 10) &lt;br&gt; 'select1'                      yes     before selecting a position         c,new_p,old_p,new_v,new_v &lt;br&gt; 'select2'                              after  selecting a position         c,new_p,old_p,new_v,old_v &lt;br&gt; 'select3'                              after  selecting a position         c,new_p,old_p,new_v,old_v &lt;br&gt; 'set-mark'                             when a mark is set                  c,p,v &lt;br&gt; 'show-popup-menu'                      in tree.OnPopup                     c,p,v,event &lt;br&gt; 'start1'                               after app.finishCreate()            None &lt;br&gt; 'start2'                               after opening first Leo window      c,p,v,fileName &lt;br&gt; 'unselect1'                    yes     before unselecting a vnode          c,new_p,old_p,new_v,old_v &lt;br&gt; 'unselect2'                            after  unselecting a vnode          c,new_p,old_p,old_v,old_v &lt;br&gt; '\@url1'                        yes     before double-click @url node       c,p,v,url (note 5) &lt;br&gt; '\@url2'                                after  double-click @url node       c,p,v(note 5) &lt;br&gt; ============================= ======== =================================== ============================= &lt;br&gt;  &lt;br&gt; **Notes**: &lt;br&gt;  &lt;br&gt; 1.  'activate' and 'deactivate' hooks have been removed because they do not work as expected. &lt;br&gt;  &lt;br&gt; 2.  'commands' hooks: The label entry in the keywords dict contains the &lt;br&gt;     'canonicalized' form of the command, that is, the lowercase name of the command &lt;br&gt;     with all non-alphabetic characters removed. &lt;br&gt;     Commands hooks now set the label for undo and redo commands 'undo' and 'redo' &lt;br&gt;     rather than 'cantundo' and 'cantredo'. &lt;br&gt;  &lt;br&gt; 3.  'menu1' hook: Setting g.app.realMenuNameDict in this hook is an easy way of &lt;br&gt;     translating menu names to other languages. **Note**: the 'new' names created this &lt;br&gt;     way affect only the actual spelling of the menu items, they do *not* affect how &lt;br&gt;     you specify shortcuts settings, nor do they affect the 'official' &lt;br&gt;     command names passed in g.app.commandName. For example:: &lt;br&gt;  &lt;br&gt;         app().realMenuNameDict['Open...'] = 'Ouvre'. &lt;br&gt;  &lt;br&gt; 4.  'open1' and 'open2' hooks: These are called with a keywords dict containing the following entries: &lt;br&gt;  &lt;br&gt;     - c:          The commander of the newly opened window. &lt;br&gt;     - old_c:      The commander of the previously open window. &lt;br&gt;     - new_c:      (deprecated: use 'c' instead) The commander of the newly opened window. &lt;br&gt;     - fileName:   The name of the file being opened. &lt;br&gt;  &lt;br&gt;     You can use old_c.p and c.p to get the current position in the old and new windows. &lt;br&gt;     Leo calls the 'open1' and 'open2' hooks only if the file is not already open. Leo &lt;br&gt;     will also call the 'open1' and 'open2' hooks if: a) a file is opened using the &lt;br&gt;     Recent Files menu and b) the file is not already open. &lt;br&gt;  &lt;br&gt; 5.  '@url1' and '@url2' hooks are only executed if the 'icondclick1' hook returns None. &lt;br&gt;  &lt;br&gt; 6.  These hooks are useful for testing. &lt;br&gt;  &lt;br&gt; 7.  These hooks allow plugins to parse and handle markup within doc parts, &lt;br&gt;     comments and Python ''' strings. Note that these hooks are *not* called in &lt;br&gt;     Python ''' strings. See the color_markup plugin for a complete example of how to &lt;br&gt;     use these hooks. &lt;br&gt;  &lt;br&gt; 8.  Leo calls the 'create-optional-menus' hook when creating menus. This hook need &lt;br&gt;     only create new menus in the correct order, without worrying about the placement &lt;br&gt;     of the menus in the menu bar. See the plugins_menu and scripts_menu plugins for &lt;br&gt;     examples of how to use this hook. &lt;br&gt;  &lt;br&gt; 9.  The New command calls 'new'. &lt;br&gt;     The 'new_c' key is deprecated.  Use the 'c' key instead. &lt;br&gt;  &lt;br&gt; 10. g.scanDirectives calls 'scan-directives' hook. &lt;br&gt;     g.scanDirectives returns a dictionary, say d. &lt;br&gt;     d.get('pluginsList') is an a list of tuples (d,v,s,k) where: &lt;br&gt;  &lt;br&gt;     - d is the spelling of the @directive, without the leading @. &lt;br&gt;     - v is the vnode containing the directive, _not_ the original vnode. &lt;br&gt;     - s[k:] is a string containing whatever follows the @directive. &lt;br&gt;       k has already been moved past any whitespace that follows the @directive. &lt;br&gt;  &lt;br&gt;     See the add_directives plugins directive for a complete example of how to use &lt;br&gt;     the 'scan-directives' hook. &lt;br&gt;  &lt;br&gt; 11. g.app.closeLeoWindow calls the 'close-frame' hook just before &lt;br&gt;     removing the window from g.app.windowList. The hook code may remove the window &lt;br&gt;     from app.windowList to prevent g.app.closeLeoWindow from destroying the window. &lt;br&gt;  &lt;br&gt; 12. Leo calls the 'headkey1' and 'headkey2' when the headline *might* have changed. &lt;br&gt;  &lt;br&gt; 13. p is the new node (position) containing '@auto filename.ext' &lt;br&gt;  &lt;br&gt; 14. The d argument to the open-with event handlers is a python &lt;br&gt;     dictionary whose keys are all the tags specified by the user in the body of the &lt;br&gt;     @openwith node. &lt;br&gt;      &lt;br&gt; The following events can *only* be called be called by minibuffer commands: &lt;br&gt;  &lt;br&gt; ========================== ======== ===================== &lt;br&gt; Event name (tag argument)  Stop?    Keys in keywords dict &lt;br&gt; ========================== ======== ===================== &lt;br&gt; 'iconclick1'               yes      c,p,v,event (note 15) &lt;br&gt; 'iconrclick1'              yes      c,p,v,event (note 15) &lt;br&gt; 'iconrclick2'                       c,p,v,event (note 15) &lt;br&gt; 'icondclick1'              yes      c,p,v,event (note 15) &lt;br&gt; 'icondclick2'                       c,p,v,event (note 15) &lt;br&gt; ========================== ======== ===================== &lt;br&gt;  &lt;br&gt; 15. The only way to trigger these event is with the following minibuffer commands:: &lt;br&gt;  &lt;br&gt;                 click-icon-box &lt;br&gt;                 ctrl-click-icon &lt;br&gt;                 double-click-headline &lt;br&gt;         Ctrl+F3 double-click-icon-box &lt;br&gt;                 right-click-headline &lt;br&gt;                 right-click-icon &lt;br&gt; " id="1195" linkTypes="1" links="716" title="Summary of event handlers" />
<node body="This way of debugging can only be used for general scripts, not leo-specific scripts. The debug command writes the script to scriptFile.py and invokes winpdb. winpdb opens and is already 'attached' to the script to be debugged. You can single-step as you like. Leo continues to run, but killing the debugger will also kill Leo. &lt;br&gt; " id="1196" linkTypes="1" links="726" title="The debug command" />
<node body="This way of debugging scripts allows winpdb to debug scripts that use c, g and p. A bit more work is needed because winpdb does not start automatically. Here are step-by step instructions: &lt;br&gt;  &lt;br&gt; 1. Insert the following two lines of code at the start of the script to be debugged:: &lt;br&gt;  &lt;br&gt;     import rpdb2 &lt;br&gt;     rpdb2.start_embedded_debugger('go',fAllowUnencrypted=True) &lt;br&gt;  &lt;br&gt; 2. Execute Leo's execute-script command (*not* the debug command). Leo will appear to hang: start_embedded_debugger is waiting for *another* copy of winpdb to 'attach' to the script's process. The default timeout is 5 minutes, after which an exception gets thrown. &lt;br&gt;  &lt;br&gt; 3. Start winpdb explicitly by executing something like the following in a console:: &lt;br&gt;  &lt;br&gt;     python /Python26/Scripts/_winpdb.py -t &lt;br&gt;  &lt;br&gt;    The -t option tells winpdb that no encoding of password is necessary. &lt;br&gt;    The password is specified in the call to rpdb2.start_embedded_debugger in your script. &lt;br&gt;    In our example, the password is 'go'. &lt;br&gt;  &lt;br&gt; 4. Use winpdb's File:Attach command to attach winpdb to Leo. Specify the password as 'go' and you will see the scriptFile.py containing your entire script. You can now execute or single-step through the script. To repeat, c, g and p are defined, so you can debug any script this way. &lt;br&gt; " id="1197" linkTypes="1" links="726" title="The execute-script command with explicit debugger breaks" />
<node body="Leo creates commands in two ways: &lt;br&gt;  &lt;br&gt; 1. Using the @g.command(command-name) decorator. &lt;br&gt;  &lt;br&gt; 2. Using tables, usually getPublicCommands methods in various classes. &lt;br&gt;  &lt;br&gt; For example, to find the code for the sort-lines command, search for &lt;br&gt; sort-lines. You will find:: &lt;br&gt;  &lt;br&gt;     'sort-lines':    self.sortLines, &lt;br&gt;      &lt;br&gt; Now search for &quot;def sortLines&quot; and you have arrived." id="1198" linkTypes="1" links="746" title="Finding commands" />
<node body="The following methods and their helpers all have useful traces: &lt;br&gt;  &lt;br&gt; - leoQtEventFilter.eventFilter (qtGui.py) and helpers create keystrokes  &lt;br&gt;   (LeoKeyEvents) from QKeyEvent events. &lt;br&gt;  &lt;br&gt; - k.masterKeyHandler (leoKeys.py) receives LeoKeyEvents from eventFilter &lt;br&gt;   and invokes one of Leo's commands based on the users bindings. &lt;br&gt;  &lt;br&gt; - k.getArg handles commands like Ctrl-F (search-with-present-options) &lt;br&gt;   that prompt the user for input. &lt;br&gt; " id="1199" linkTypes="1" links="746" title="Finding key-handling code" />
<node body="c.outerUpdate and helpers eliminate flicker by redrawing the screen only at &lt;br&gt; the end of each command. &lt;br&gt;  &lt;br&gt; c.outerUpdate contains several sophisticated and useful traces. &lt;br&gt;  &lt;br&gt; qtGui.set_focus (qtGui.py) is the only place that actually explicitly sets &lt;br&gt; focus in Leo. Enabling a trace there can be useful. &lt;br&gt; " id="1200" linkTypes="1" links="746" title="Finding redraw and refocus code" />
<node body="Just use cff (clone-find-all-flattened).  This is my workhorse command when fixing complex bugs." id="1201" linkTypes="1" links="746" title="Finding all uses of a symbol" />
<node body="Once you know approximately where to look, it is easy to use traces to &lt;br&gt; discover what is going on. To trace the last n (default 4) callers of any &lt;br&gt; function:: &lt;br&gt;  &lt;br&gt;     g.trace(g.callers(n)) &lt;br&gt;      &lt;br&gt; Many complex methods define a trace variable:: &lt;br&gt;  &lt;br&gt;     trace = False and not g.unitTesting &lt;br&gt;      &lt;br&gt; A good rule of thumb: the more complex a method is, the more useful its &lt;br&gt; traces are likely to be. &lt;br&gt;  &lt;br&gt; You can also to use g.pdb() to single-step through the code. &lt;br&gt; I typically use g.pdb() only for deep mysteries! &lt;br&gt;  &lt;br&gt; **Note**: you must run Leo from a console window to use either g.trace or &lt;br&gt; g.pdb. I recommend always running Leo from a console." id="1202" linkTypes="1" links="746" title="Debugging with g.trace, g.callers &amp; g.pdb" />
<node body="@language python &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     def vim_d(vc): &lt;br&gt;         ''' &lt;br&gt;         N dd      delete N lines &lt;br&gt;         d{motion} delete the text that is moved over with {motion} &lt;br&gt;         ''' &lt;br&gt;         if vc.is_text_widget(vc.w): &lt;br&gt;             vc.n = 1 &lt;br&gt;             vc.accept(handler=vc.vim_d2) &lt;br&gt;         else: &lt;br&gt;             vc.quit() &lt;br&gt; @language rest &lt;br&gt;  &lt;br&gt; This is the key handler for the 'd' key in normal mode. &lt;br&gt;  &lt;br&gt; The entry in vc.normal_dispatch_d for 'd' is: 'd':vc.vim_d. &lt;br&gt;  &lt;br&gt; Because this command changes text, vc.is_text_widget(vc.w) must be True. If &lt;br&gt; so, this handler simply calls vc.accept(handler=vc.vim_d2) to queue up the &lt;br&gt; follow-on handler. Otherwise, the handler calls vc.quit() to end the &lt;br&gt; command. &lt;br&gt;  &lt;br&gt; " id="1203" linkTypes="1" links="757" title="vim_d" />
<node body="@language python &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     def vim_d2(vc): &lt;br&gt;         if vc.is_text_widget(vc.w): &lt;br&gt;             if vc.stroke == 'd': &lt;br&gt;                 w = vc.w &lt;br&gt;                 i = w.getInsertPoint() &lt;br&gt;                 for z in range(vc.n1*vc.n): &lt;br&gt;                     # It's simplest just to get the text again. &lt;br&gt;                     s = w.getAllText() &lt;br&gt;                     i,j = g.getLine(s,i) &lt;br&gt;                     # Special case for end of buffer only for n == 1. &lt;br&gt;                     # This is exactly how vim works. &lt;br&gt;                     if vc.n1*vc.n == 1 and i == j == len(s): &lt;br&gt;                         i = max(0,i-1) &lt;br&gt;                     w.delete(i,j) &lt;br&gt;                 vc.done() &lt;br&gt;             else: &lt;br&gt;                 vc.d_stroke = vc.stroke # A scratch var. &lt;br&gt;                 vc.begin_motion(vc.vim_d3) &lt;br&gt;         else: &lt;br&gt;             vc.quit() &lt;br&gt; @language rest &lt;br&gt;  &lt;br&gt; This is the follow-on handler for the 'd' command. It will be called when &lt;br&gt; the user types a *second* character following the 'd' command in normal &lt;br&gt; mode. &lt;br&gt;  &lt;br&gt; All forms of the 'd' command alter text, so this handler calls vc.quit if &lt;br&gt; vc.w is not a text widget. &lt;br&gt;  &lt;br&gt; If the second character is another 'd', we have the 'dd' command. The code &lt;br&gt; uses the high-level interface to delete a line, then calls vc.done() to end &lt;br&gt; the command. &lt;br&gt;  &lt;br&gt; If the second character is *not* a 'd', it should be a following motion, &lt;br&gt; such as &quot;2j&quot; in &quot;d2j&quot;. &lt;br&gt;  &lt;br&gt; vc.vim_d2 remembers the character that started the motion in a **scratch &lt;br&gt; ivar**, vc.d_stroke. Such ivars are not inited or touched outside of vim_d &lt;br&gt; and its follow-on key handlers. This code must remember this character so &lt;br&gt; that the vim_d3 handler will know whether to expand the deleted text to a &lt;br&gt; line. &lt;br&gt;  &lt;br&gt; Finally, vc.vim_d2 calls vc.begin_motion, which does the following: &lt;br&gt;  &lt;br&gt; - Calls vc.ignore if the second character doesn't really start a motion. &lt;br&gt; - Sets vc.handler to vc.do_inner_motion.  This handles the motion. &lt;br&gt; - Sets the vc.after_motion to the next follow-on handler: vc.vim_d3. &lt;br&gt;   vc.vim_d3 will be called when the motion is complete. The details are &lt;br&gt;   complicated, but happily the key handlers don't have to know about them! &lt;br&gt; " id="1204" linkTypes="1" links="757" title="vim_d2" />
<node body="@language python &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     def vim_d3(vc): &lt;br&gt;         '''Complete the d command after the cursor has moved.''' &lt;br&gt;         # d2w doesn't extend to line.  d2j does. &lt;br&gt;         trace = False and not g.unitTesting &lt;br&gt;         if vc.is_text_widget(vc.w): &lt;br&gt;             extend_to_line = vc.d_stroke in ('jk') &lt;br&gt;             w = vc.w &lt;br&gt;             s = w.getAllText() &lt;br&gt;             i1,i2 = vc.motion_i,w.getInsertPoint() &lt;br&gt;             if i1 == i2: &lt;br&gt;                 if trace: g.trace('no change') &lt;br&gt;             elif i1 &lt; i2: &lt;br&gt;                 for z in range(vc.n1*vc.n): &lt;br&gt;                     if extend_to_line: &lt;br&gt;                         i2 = vc.to_eol(s,i2) &lt;br&gt;                         if i2 &lt; len(s) and s[i2] == '\n': &lt;br&gt;                             i2 += 1 &lt;br&gt;                         if trace: g.trace('extend i2 to eol',i1,i2) &lt;br&gt;                 w.delete(i1,i2) &lt;br&gt;             else: # i1 &gt; i2 &lt;br&gt;                 i1,i2 = i2,i1 &lt;br&gt;                 for z in range(vc.n1*vc.n): &lt;br&gt;                     if extend_to_line: &lt;br&gt;                         i1 = vc.to_bol(s,i1) &lt;br&gt;                         if trace: g.trace('extend i1 to bol',i1,i2) &lt;br&gt;                 w.delete(i1,i2) &lt;br&gt;             vc.done() &lt;br&gt;         else: &lt;br&gt;             vc.quit() &lt;br&gt; @language rest &lt;br&gt;  &lt;br&gt; This is the second and last follow-on handler for the d command. The &lt;br&gt; dispatcher that handles vim motions will call this handler after the &lt;br&gt; motions **have actually happened**. &lt;br&gt;  &lt;br&gt; First, the code double-checks that we are still in a text widget, calling &lt;br&gt; vc.quit() if not. &lt;br&gt;  &lt;br&gt; Next, the code compares the present insertion point, w,getInsertPoint(), &lt;br&gt; with the insertion point before the motion happened, vc.motion_i. It &lt;br&gt; extends the selection range if the scratch ivar, vc.d_stroke, is in ('jk'). &lt;br&gt; The code then deletes the selected text. &lt;br&gt;  &lt;br&gt; Finally, this method calls vc.done(). &lt;br&gt; " id="1205" linkTypes="1" links="757" title="vim_d3" />
<node body="@language python &lt;br&gt; :: &lt;br&gt;  &lt;br&gt;     def vis_d(vc): &lt;br&gt;         '''Delete the highlighted text and terminate visual mode.''' &lt;br&gt;         w  = vc.vis_mode_w &lt;br&gt;         if vc.is_text_widget(w): &lt;br&gt;             i1 = vc.vis_mode_i &lt;br&gt;             i2 = w.getInsertPoint() &lt;br&gt;             w.delete(i1,i2) &lt;br&gt;             vc.state = 'normal' &lt;br&gt;             vc.done() &lt;br&gt;         else: &lt;br&gt;             vc.quit() &lt;br&gt; @language rest  &lt;br&gt;  &lt;br&gt; This is the key handler for the 'd' key in normal mode. &lt;br&gt;  &lt;br&gt; It is *not* a follow-on method of vim_d. The dispatcher calls this method &lt;br&gt; after visual mode has highlighted text. Here is the entry for 'd' in &lt;br&gt; vc.visual_dispatch_d: 'd':vc.vis_d. &lt;br&gt;  &lt;br&gt; Visual mode has already highlighted the text to be deleted, so this code &lt;br&gt; simply deletes the highlighted text and calls vc.done(). &lt;br&gt;  &lt;br&gt; " id="1206" linkTypes="1" links="757" title="vis_d" />
<node body="The init code for each Leo commander c assigns an instance of VimCommands to c.vimCommands. This is done regardless of the @bool vim-mode setting. &lt;br&gt;  &lt;br&gt; Each ivar of the VimCommands class is inited by exactly one of the following:: &lt;br&gt;  &lt;br&gt;     vc.init_constant_ivars() &lt;br&gt;     vc.init_dot_ivars() &lt;br&gt;     vc.init_persistent_ivars() &lt;br&gt;     vc.init_state_ivars() &lt;br&gt;     vc.create_dispatch_dicts() &lt;br&gt;      &lt;br&gt; In effect, this code partitions each ivar into disjoint sets. This partitioning simplifies code that must re-init some ivars but not others. &lt;br&gt;  &lt;br&gt; The init code creates **dispatch dicts** used by dispatchers.   &lt;br&gt; " id="1207" linkTypes="1" links="758" title="Initialization" />
<node body="Depending on various state date, dispatchers route incoming keys to the proper **key handler**. Dispatchers use **dispatch dicts** to assign handlers to incoming keys. These dicts eliminate almost all special case code. &lt;br&gt;     &lt;br&gt; vc.do_key is the top-level dispatcher. k.masterKeyHandler calls it for all keys *except* Ctrl-G. **Note**: k.masterKeyHandler calls vc.do_key only when there no key state in effect, that is, when the minibuffer is not active. &lt;br&gt;  &lt;br&gt; As discussed below, the value returned by vc.do_key tells k.masterKeyHandler whether vim mode has completely handled the key. &lt;br&gt;  &lt;br&gt; Depending on the vc.handler ivar, vc.do_key can route the incoming key either to an **inner dispatcher** or directly to a key handler. &lt;br&gt;  &lt;br&gt; Inner dispatchers handle keys for a particular vim mode using dispatch dicts. Inner dispatchers the following ivars behind the scenes:: &lt;br&gt;  &lt;br&gt;     vc.handler, vc.next_func, vc.return_value &lt;br&gt;     vc.in_motion and vc.motion_func &lt;br&gt;      &lt;br&gt; Handling these ivars can be tricky; hiding the details greatly simplifies all key handlers. &lt;br&gt; " id="1208" linkTypes="1" links="758" title="Dispatchers" />
<node body="Key handlers handle a single key during the parsing of a vim command. Key handlers can either complete a command, thereby actually doing something, or change state so as to be able to parse (and possibly complete) the next incoming keystroke. &lt;br&gt;  &lt;br&gt; For example, the key handler for the G command handles the command completely. In contrast, two key handlers are needed to handle the gg command. The first handler, vc.vim_g, simply calls vc.accept(handler=vc.vim_g2). This call changes the vc.handler ivar to point to the **follow-on handler**, vim_g2. vim_g2 handles all commands after the user has typed 'g' in normal mode. &lt;br&gt;  &lt;br&gt; Each key handler must end with a call to an **acceptance method**. vc.accept is one such method. Acceptance methods prepare for the next keystroke by setting internal state ivars used by the various dispatchers. &lt;br&gt;  &lt;br&gt; Many key handlers simply call vc.done(). This method handles all the details of completing a key handler: it hides the details of parsing vim command. &lt;br&gt;  &lt;br&gt; **Important**: Any key handler that wants to change vc.state should set vc.state *before* calling vc.done() &lt;br&gt;  &lt;br&gt; Key handlers can call either **direct acceptance methods**, vc.accept, vc.delegate, vc.done, vc.ignore, vc.not_ready, vc.quit, and vc.reset, or **indirect acceptance methods**: vc.begin_insert_mode, vc.begin_motion, vc.end_insert_mode, and vc.vim_digits. Indirect acceptance methods must eventually call direct acceptance methods. &lt;br&gt; " id="1209" linkTypes="1" links="758" title="About key handlers" />
<node body="Dispatchers set the following ivars for each key handler: &lt;br&gt;  &lt;br&gt; **vc.w** is the widget that has focus. Key handlers may use convenience methods to determine the location and type of vc.w. The most important are: &lt;br&gt;  &lt;br&gt; - vc.is_text_widget(w): True if w is any text widget, including headlines, body text and log pane. &lt;br&gt;    &lt;br&gt; - vc.in_headline(w): True if w is a headline widget in edit mode. &lt;br&gt;  &lt;br&gt; **vc.stroke** is a standard Leo stroke representing the incoming key. Note that the spelling of the stoke using the Tk spellings. Take a look at entries in the dispatch dicts to see such spellings. When in doubt, enable the trace in vc.do_key to see the incoming strokes. &lt;br&gt;  &lt;br&gt; **vc.n1** and **vc.n** are the repeat counts in effect for each key handler. Dispatchers and their allies handle most details of setting these repeat counts, so most key handlers can simply use vc.n1*vc.n as the ultimate repeat count. &lt;br&gt;  &lt;br&gt; **vc.motion_i** is the insertion point *before* the motion has taken place. &lt;br&gt; " id="1210" linkTypes="1" links="758" title="Ivars for key handlers" />
<node body="@language rest &lt;br&gt; .. @language python below &lt;br&gt;  &lt;br&gt; Various vim commands advertise, just by having a tab_callback method, that they want to handle a tab that follows their name. ga.do_tab then defers to the vim command. Vim's tab handler no longer knows *anything* about colon commands, or what any command intends to do with the tab. If the command handler has a tab_callback attribute, vim's tab handler just calls it. &lt;br&gt;  &lt;br&gt; Here is the flattened form of the class that handles the :tabnew command. Note that the __call__ and tab_callback methods are trivial:: &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt;      &lt;br&gt;     class Tabnew: &lt;br&gt;         ''' &lt;br&gt;         A class to handle Vim's :tabnew command. &lt;br&gt;         This class supports the do_tab callback. &lt;br&gt;         ''' &lt;br&gt;         def __init__(self,vc): &lt;br&gt;             '''Ctor for VimCommands.tabnew class.''' &lt;br&gt;             self.vc = vc &lt;br&gt;         __name__ = ':tabnew' &lt;br&gt;             # Required. &lt;br&gt;      &lt;br&gt;         def __call__(self,event=None): &lt;br&gt;             '''Prompt for a file name, the open a new Leo tab.''' &lt;br&gt;             self.vc.c.k.getFileName(event,callback=self.open_file_by_name) &lt;br&gt;             &lt;br&gt;         def tab_callback(self): &lt;br&gt;             '''Called when the user types :tabnew&lt;tab&gt;''' &lt;br&gt;             self.vc.c.k.getFileName(event=None,callback=self.open_file_by_name) &lt;br&gt;             &lt;br&gt;         def open_file_by_name(self,fn): &lt;br&gt;             c = self.vc.c &lt;br&gt;             if fn and not g.os_path_isdir(fn): &lt;br&gt;                 c2 = g.openWithFileName(fn,old_c=c) &lt;br&gt;                 try: &lt;br&gt;                     g.app.gui.runAtIdle(c2.treeWantsFocusNow) &lt;br&gt;                 except Exception: &lt;br&gt;                     pass &lt;br&gt;             else: &lt;br&gt;                 c.new() &lt;br&gt;              &lt;br&gt; @language rest &lt;br&gt;  &lt;br&gt; This pattern is particularly well suited to Leo, because the various getPublicCommands methods reference those functions in their command dictionaries. Here, the new entries are:: &lt;br&gt;  &lt;br&gt; @language python &lt;br&gt;  &lt;br&gt;     ':r':       vc.LoadFileAtCursor(vc), &lt;br&gt;     ':tabnew':  vc.Tabnew(vc), &lt;br&gt; " id="1211" linkTypes="1" links="758" title="Handling tabs" />
<node body="The simplest way of moving the cursor or changing text is to use the vc.do method, a thin wrapper for c.k.simulateCommand.  For example:: &lt;br&gt;  &lt;br&gt;     if vc.state == 'visual': &lt;br&gt;         vc.do('end-of-buffer-extend-selection') &lt;br&gt;     else: &lt;br&gt;         vc.do('end-of-buffer') &lt;br&gt;  &lt;br&gt; Key handlers may also use the **high-level interface**. This is the API used throughout Leo's core. For details, see the HighLevelInterface class in leoFrame.py and various subclasses in qtGui.py. &lt;br&gt; " id="1212" linkTypes="1" links="758" title="API's for key handlers" />
<node body="vc.do_key returns the value of vc.return_value. Most the acceptance functions set vc.return_value to True, indicating that vim mode has completely handled the key and that k.masterKeyHandler should simply return. k.masterKeyHandler handles the key as usual if vc.do_key returns False. &lt;br&gt;  &lt;br&gt; Each key handler sets vc.return_value indirectly by calling an acceptance method. A simple check in vc.do_key ensures that every key handler, has, in fact, called an acceptance method. In practice, this check has been very effective. &lt;br&gt; " id="1213" linkTypes="1" links="758" title="vc.return_value and internal error checking" />
<node body="The leo/plugins/importers folders now contains importer plugins. &lt;br&gt;  &lt;br&gt; The leo/plugins/writers folders now contain writer plugins. &lt;br&gt;  &lt;br&gt; Both importer and writer plugins can defined new kinds of @auto nodes. &lt;br&gt;  &lt;br&gt; Importers and writers can register either @auto-names or file extensions. For example, @auto x.xyzzy will use both the importer and the writer for the .xyzzy extension, that is, importers/test.py and writers/test.py. So, for *unique* extensions, there is no need to use a separate @auto name, you can just use @auto." id="1214" linkTypes="1" links="812" title="A plugable architecture for @auto nodes" />
<node body="1. Make Leo tutorials.  The world is waiting. &lt;br&gt; 2. Pay phone bill or the world will never know. &lt;br&gt; " id="1215" linkTypes="1" links="863" title="Urgent" />
<node body="" id="1216" linkTypes="1" links="863" title="Important" />
<node body="" id="1217" linkTypes="1" links="863" title="Soon" />
<node body="" id="1218" linkTypes="1" links="863" title="Whenever" />
<node body="@language rest &lt;br&gt;  &lt;br&gt; This is my diary. &lt;br&gt; " id="1219" linkTypes="3 3 3 3 3 3" links="1356 1357 1358 1359 1360 1361" title="2009" />
<node body="" id="1220" linkTypes="1" links="864" title="2010" />
<node body="" id="1221" linkTypes="3 3 3" links="1362 1363 1364" title="utils" />
<node body="def run (self): &lt;br&gt;  &lt;br&gt;     print('='*20) &lt;br&gt;  &lt;br&gt;     aList = self.get_wink_screenshots() &lt;br&gt;     if not aList: &lt;br&gt;         return &lt;br&gt;  &lt;br&gt;     if not self.check(aList): &lt;br&gt;         return &lt;br&gt;  &lt;br&gt;     # Pass 1: copy files for @slide nodes w/o @no-screenshot nodes. &lt;br&gt;     self.copy_files(aList) &lt;br&gt;  &lt;br&gt;     # Pass 2: adjust children of @slide nodes. &lt;br&gt;     self.adjust_slideshow() &lt;br&gt;  &lt;br&gt;     print('meld done') &lt;br&gt; " id="1222" linkTypes="3 3 3 3" links="1365 1366 1367 1368" title="run &amp; helpers" />
<node body="" id="1223" linkTypes="1" links="876" title="@title_pattern = Leo's NSIS Installer: Slide %(slide_number)s" />
<node body=".. _`here`:     http://www.nullsoft.com/free/nsis/ &lt;br&gt; .. _`Winamp`:   http://www.winamp.com/ &lt;br&gt;  &lt;br&gt; Nullsoft, the makers of the `Winamp`_ MP3 software, have released a powerful free &lt;br&gt; installer called NSIS, available `here`_. This application allows you to make &lt;br&gt; installation packages for Windows applications. &lt;br&gt;  &lt;br&gt; You create NSIS packages by writing a NSIS script and then compiling it. &lt;br&gt; Depending on the application, NSIS can often be a better choice than more &lt;br&gt; expensive installation generators, since NSIS installations are easy to create, &lt;br&gt; are small and fast, and yet can be configured with many features. &lt;br&gt;  &lt;br&gt; " id="1224" linkTypes="1" links="876" title="@slide 001" />
<node body="When you install Leo, you'll find that it comes with a script for generating an &lt;br&gt; installer for Leo. This script is called leo-&lt;version&gt;.nsi, and is distributed &lt;br&gt; in the Leo file leo/dist/leoDist.leo. &lt;br&gt;  &lt;br&gt; If you have NSIS installed, right-clicking on a .nsi file will give you the &lt;br&gt; option of compiling the script to create a package. &lt;br&gt;  &lt;br&gt; .. image:: slide-002.png &lt;br&gt;  &lt;br&gt; " id="1225" linkTypes="3 3 3 3 3 3" links="1369 1370 1371 1372 1373 1374" title="@slide 002" />
<node body="Since the NSIS script for the Leo installation is included in the Leo &lt;br&gt; distribution in the nsis.leo file, it is easy to understand the how the script &lt;br&gt; works. This .nsi file creates an installer that packages all of the Leo program &lt;br&gt; files, and creates a desktop shortcut, a Program Menu item, and the file &lt;br&gt; association for .leo files. &lt;br&gt; " id="1226" linkTypes="1" links="876" title="@slide 003" />
<node body="In this screenshot we're looking at the code that checks to see whether Python &lt;br&gt; has been installed. &lt;br&gt;  &lt;br&gt; Since Leo is a Python application, modifying this installation script to create &lt;br&gt; a script to build a Windows installer for your own Python application is &lt;br&gt; relatively simple. You would leave this section alone, and check other sections &lt;br&gt; for the program name &quot;Leo&quot;, and change these to your program name. &lt;br&gt; " id="1227" linkTypes="1" links="876" title="@slide 004" />
<node body="" id="1228" linkTypes="1" links="876" title="@slide 005" />
<node body="This slideshow shows some of the things you can do &lt;br&gt; with Leo &lt;br&gt; " id="1229" linkTypes="3" links="1375" title="@slide What you can do with Leo" />
<node body="Leo's main window consists of an **outline pane** &lt;br&gt; (1), a **body pane** (2) and a **log pane** (3). &lt;br&gt; All data in Leo resides in **nodes**. A node &lt;br&gt; consists of **headline text** and **body text**. &lt;br&gt; The outline pane shows headlines. The body pane &lt;br&gt; pane shows the body text of the presently selected &lt;br&gt; node. Messages from Leo appear in the log pane. &lt;br&gt;  &lt;br&gt; " id="1230" linkTypes="1" links="877" title="@slide Leo's main window" />
<node body="You can use Leo as a PIM. &lt;br&gt;  &lt;br&gt; As with other outliners, Leo outlines show  &lt;br&gt; " id="1231" linkTypes="1" links="877" title="@slide A Personal Information Manager" />
<node body="Leo is a better pim. &lt;br&gt; " id="1232" linkTypes="3" links="1376" title="@slide A Better PIM" />
<node body="" id="1233" linkTypes="1" links="877" title="@slide External Files" />
<node body="The body text of any node can contain a Python script. &lt;br&gt;  &lt;br&gt; You execute the script with (Ctrl-B) Leo's execute-script command. &lt;br&gt; " id="1234" linkTypes="3" links="1377" title="@slide A Scripting Environment" />
<node body="All Leo scripts have access to three predefined constants: c, g and p. &lt;br&gt; " id="1235" linkTypes="3" links="1378" title="@slide Better Scripting" />
<node body="All Leo scripts have full access to the outline in which the scripts reside. The &lt;br&gt; following scripts, executed from Leo's body pane, will print the headlines of &lt;br&gt; all the nodes of the outline, properly indented:: &lt;br&gt;  &lt;br&gt;     for p in c.all_positions(): &lt;br&gt;         print '%s%s' % (' '*p.level(),p.h) &lt;br&gt; " id="1236" linkTypes="3" links="1379" title="@slide Better Scripting, Part Deux" />
<node body="Discuss @button nodes &lt;br&gt; " id="1237" linkTypes="3" links="1380" title="@slide Outlines Create New Leo Commands" />
<node body="Discuss @test nodes &lt;br&gt; " id="1238" linkTypes="3" links="1381" title="@slide Outlines Create Unit tests" />
<node body="Leo outlines make it easy to create Restructured Text (rST) documents. &lt;br&gt;  &lt;br&gt; Within @rst trees, nodes correspond to rST sections. Naturally, the outline &lt;br&gt; level of a node in the Leo outline determines the section's level in the &lt;br&gt; resulting document. &lt;br&gt; " id="1239" linkTypes="3" links="1382" title="@slide Outlines Create Restructured Text" />
<node body="" id="1240" linkTypes="1" links="878" title="@title_pattern = What is Leo? Slide %(slide_number)s" />
<node body="Leo is a unique, powerful computer program that you can use to **organize**, &lt;br&gt; **analyze** and **describe** text and text files. Leo is a free and open &lt;br&gt; software written by Edward K. Ream. For information about downloading Leo, see &lt;br&gt; the **installation** tutorial in this series. Leo runs on Windows, Mac, or &lt;br&gt; Linux. &lt;br&gt;  &lt;br&gt; Use Leo: &lt;br&gt;  &lt;br&gt; - To brainstorm a new project. &lt;br&gt; - As a Personal Information Manager. &lt;br&gt; - To add multiple outlines and commentary to any text file. &lt;br&gt; - To create and organize computer programs. &lt;br&gt; - To apply computer scripts to any kind of data. &lt;br&gt;  &lt;br&gt; Because Leo is unlike other tools you may have used, a series of examples may be &lt;br&gt; the best way to demonstrate what can be done with Leo. &lt;br&gt; " id="1241" linkTypes="3" links="1383" title="@slide 001" />
<node body="From one perspective, Leo is an **outlining editor**. This is a screenshot of &lt;br&gt; Leo. The arrow shows the outline pane. (A later tutorial explains how to create &lt;br&gt; an outline like the one in the screenshot). &lt;br&gt;  &lt;br&gt; .. image:: slide-002.png &lt;br&gt;  &lt;br&gt; " id="1242" linkTypes="3 3 3 3 3 3 3" links="1384 1385 1386 1387 1388 1389 1390" title="@slide 002" />
<node body="Clicking on the open triangle will open the indicated node. &lt;br&gt;  &lt;br&gt; .. image:: slide-003.png &lt;br&gt;  &lt;br&gt; " id="1243" linkTypes="3 3 3 3 3 3" links="1391 1392 1393 1394 1395 1396" title="@slide 003" />
<node body="Here the node has been opened. Clicking on the box again will close the node. &lt;br&gt;  &lt;br&gt; .. image:: slide-004.png &lt;br&gt;  &lt;br&gt; " id="1244" linkTypes="3 3 3 3 3 3 3" links="1397 1398 1399 1400 1401 1402 1403" title="@slide 004" />
<node body="Here the indicated node has been closed. &lt;br&gt;  &lt;br&gt; .. image:: slide-005.png &lt;br&gt;  &lt;br&gt; " id="1245" linkTypes="3 3 3 3 3 3 3" links="1404 1405 1406 1407 1408 1409 1410" title="@slide 005" />
<node body="Clicking on a node headline (1) will show the text for that node in the body &lt;br&gt; pane (2) below. The body pane is a text editor--you can enter, delete or change &lt;br&gt; text here by typing it in. &lt;br&gt;  &lt;br&gt; .. image:: slide-006.png &lt;br&gt;  &lt;br&gt; " id="1246" linkTypes="3 3 3 3 3 3 3" links="1411 1412 1413 1414 1415 1416 1417" title="@slide 006" />
<node body="You can save the outline in a .leo file.  Click File:Save (or Ctrl-S). &lt;br&gt;  &lt;br&gt; .. image:: slide-007.png &lt;br&gt;  &lt;br&gt; " id="1247" linkTypes="3 3 3 3 3 3 3" links="1418 1419 1420 1421 1422 1423 1424" title="@slide 007" />
<node body="Here we will save our outline in a file named &quot;pim.leo&quot; &lt;br&gt;  &lt;br&gt; .. image:: slide-008.png &lt;br&gt;  &lt;br&gt; " id="1248" linkTypes="3 3 3 3 3 3 3" links="1425 1426 1427 1428 1429 1430 1431" title="@slide 008" />
<node body="The file is now saved, and the file appears in the title bar. &lt;br&gt;  &lt;br&gt; .. image:: slide-009.png &lt;br&gt;  &lt;br&gt; " id="1249" linkTypes="3 3 3 3 3 3 3 3" links="1432 1433 1434 1435 1436 1437 1438 1439" title="@slide 009" />
<node body="You've just seen an introduction to Leo as an outlining editor. You can use Leo &lt;br&gt; to make an outline, with optional text for each outline element. You can save &lt;br&gt; the outline to a file. Outlines are explained more in a later tutorial in this &lt;br&gt; series. &lt;br&gt;  &lt;br&gt;   *The outlining capability of Leo goes far beyond what has just been demonstrated, &lt;br&gt;   including multipath outlines, and multiple outlines in one file.* &lt;br&gt;  &lt;br&gt; What we've shown so far is no different from other outlining editors. What makes &lt;br&gt; Leo unique is the addition of a new feature. **Using simple directives, you can &lt;br&gt; instruct Leo to extract text from any number of nodes, in any order, and write &lt;br&gt; the text to a new file**. We call files created or managed from within a Leo &lt;br&gt; outline **external file**. You can also embed outline information in the &lt;br&gt; external file, giving Leo the ability to read the text pieces back into the Leo &lt;br&gt; outline, even if they have been changed. &lt;br&gt;  &lt;br&gt; In effect, Leo is a **meta-text** editor. It gives you the ability to create a &lt;br&gt; structural document for a non structured document, or a document that is &lt;br&gt; structured in some other way. &lt;br&gt;  &lt;br&gt; What does this mean in practice? Some examples should help clarify things... &lt;br&gt; " id="1250" linkTypes="3" links="1440" title="@slide 010" />
<node body="Here is the &quot;pim.leo&quot; file again. We have: &lt;br&gt;  &lt;br&gt; 1. Selected the &quot;Diary&quot; node. &lt;br&gt; 2. Typed Ctrl-H to start editing the headline. &lt;br&gt;    (You can also edit headlines with the Edit:Edit Headline...:Edit Headline command. &lt;br&gt;  &lt;br&gt; .. image:: slide-011.png &lt;br&gt;  &lt;br&gt; " id="1251" linkTypes="3 3 3 3 3" links="1441 1442 1443 1444 1445" title="@slide 011" />
<node body="" id="1252" linkTypes="1" links="878" title="@slide 012" />
<node body="" id="1253" linkTypes="1" links="878" title="@slide 013" />
<node body="" id="1254" linkTypes="1" links="878" title="@slide 014" />
<node body="" id="1255" linkTypes="1" links="878" title="@slide 015" />
<node body="" id="1256" linkTypes="1" links="878" title="@slide 016" />
<node body="" id="1257" linkTypes="1" links="878" title="@slide 017" />
<node body="" id="1258" linkTypes="1" links="878" title="@slide 018" />
<node body="" id="1259" linkTypes="1" links="878" title="@slide 019" />
<node body="" id="1260" linkTypes="1" links="878" title="@slide 020" />
<node body="" id="1261" linkTypes="1" links="878" title="@slide 021" />
<node body="" id="1262" linkTypes="1" links="878" title="@slide 022" />
<node body="" id="1263" linkTypes="1" links="878" title="@slide 023" />
<node body="An @buttons tree in a settings file defines global buttons that are created in the icon area of all .leo files. All @button nodes in the @commands tree create global buttons. All @button nodes outside the commands tree create buttons local to the settings file. &lt;br&gt; " id="1264" linkTypes="1" links="1055" title="\@button" />
<node body="An @commands tree in a settings file defines global commands. All @command nodes in the @commands tree create global commands. All @command nodes outside the commands tree create commands local to the settings file. &lt;br&gt; " id="1265" linkTypes="1" links="1055" title="\@commands" />
<node body="The body text contains a list of commands, one per line, to be preloaded into Leo's command history. You access command history using the up and down arrow keys in Leo's minibuffer." id="1266" linkTypes="1" links="1055" title="\@command-history" />
<node body="The body text contains a list of strings, one per line. Lines starting with '#' are ignored. &lt;br&gt; " id="1267" linkTypes="1" links="1055" title="\@data" />
<node body="The body text of the @enabled plugins node contains a list of enabled plugins, one per line. Comment lines starting with '#' are ignored. Leo loads plugins in the order they appear. **Important**: Leo handles @enabled-plugins nodes a differently from other kinds of settings. To avoid confusion, **please read the following carefully**. &lt;br&gt;  &lt;br&gt; As always, Leo looks for @enabled-plugins nodes in settings files in the order specified by `Search order for settings files`_. Leo will enable all plugins found in the @enabled-plugins node it finds *last* in the search order. Leo does *not* enable plugins found in any other @enabled-plugins node. In particular, **you can not specify a list of default plugins by placing that list in a settings file that appears early in the search list**. Instead, the last @enabled-plugins node found in the search list specifies all and *only* the plugins that will be enabled. &lt;br&gt;  &lt;br&gt; Let us distinguish two different situations. First, what Leo does when loading a file, say x.leo. Second, what Leo does when loading a second file, say y.leo, *from x.leo*. When loading the first .leo file, Leo enables plugins from the &lt;br&gt; @enabled-plugins node it finds *last* in the search order. But after plugins &lt;br&gt; have *already* been loaded and enabled, there is no way to disable previously &lt;br&gt; loaded-and-enabled plugins. But local settings files can enable additional &lt;br&gt; plugins. &lt;br&gt;  &lt;br&gt; To avoid confusion, I highly recommend following another kind of safe rule. We say that an @enabled-plugin node in file A.leo **covers** an @enabled-plugin node in file B.leo if all plugins specified in B's @enabled-plugin node appear A's @enabled-plugin node. The safe rule for plugins is:: &lt;br&gt;  &lt;br&gt;   @enabled-plugin nodes in settings files in local directories &lt;br&gt;   should cover @enabled-plugins nodes in all other settings files. &lt;br&gt; " id="1268" linkTypes="1" links="1055" title="\@enabled-plugins" />
<node body="The body text contains a list of settings for a font.  For example:: &lt;br&gt;  &lt;br&gt;     body_text_font_family = Courier New &lt;br&gt;     body_text_font_size = None &lt;br&gt;     body_text_font_slant = None &lt;br&gt;     body_text_font_weight = None &lt;br&gt;  &lt;br&gt; **Important**: you can use the show-fonts minibuffer command to guide you in making these settings. &lt;br&gt;  &lt;br&gt; " id="1269" linkTypes="1" links="1055" title="\@font" />
<node body="\@menuat modifies the menu tree created by @menus. This allows settings in myLeoSettings.leo to change menus without copying the entire menu tree from leoSettings.leo. This ensures you don’t miss out when new things are added in the @menus in leoSettings.leo, as you would if you replaced the @menus in leoSettings.leo with one in myLeoSettings.leo. &lt;br&gt;  &lt;br&gt; \@menuat should occur in a @settings tree, but not as a descendant of a @menus tree. Its children are @menu and @item nodes as for the @menu setting. &lt;br&gt;  &lt;br&gt; The @menuat setting has 2-3 parameters in its head text]:: &lt;br&gt;  &lt;br&gt;     @menuat *&lt;path&gt;* *&lt;action&gt;* *[clipboard]* &lt;br&gt;  &lt;br&gt; The path argument specifies a **target** in the menu tree as defined by @menus and modified by earlier @menuat settings. The path takes the form:: &lt;br&gt;  &lt;br&gt;     /entry1/entry2/entry3 &lt;br&gt;      &lt;br&gt; Each entry is the **cleaned** name of a menu or item. Cleaned names are a name with all text except a-z and 0-9 removed and upper case letters converted to lower case. For example, specify:: &lt;br&gt;  &lt;br&gt;     Outline-&gt;Move-&gt;Move Down &lt;br&gt;      &lt;br&gt; as:: &lt;br&gt;      &lt;br&gt;      /outline/move/movedown &lt;br&gt;  &lt;br&gt; The action argument specifies what the menu item does. There are 5 available actions: &lt;br&gt;  &lt;br&gt; - **before**: Insert items and sub menus immediately before the target. &lt;br&gt; - **after**:  Insert items and sub menus immediately after the target. &lt;br&gt; - **append**: Append items and sub menus at the end of the target menu or item. &lt;br&gt; - **cut**:    Remove the target from the menu tree and save it to an internal clipboard. &lt;br&gt; - **copy**:   Copy the target to an internal clipboard. Descendants of the @menuat setting are ignored. &lt;br&gt;  &lt;br&gt; The cut and copy arguments ignore descendants of the @menuat setting . &lt;br&gt;  &lt;br&gt; The optional clipboard argument modifies the action of the before, after, and append actions. By default these actions insert the menus and items supplied as descendants of the @menuat setting. If you specify “clipboard” (without the quotes) as the source, the contents of the clipboard from a previous cut or copy action will be used instead. &lt;br&gt; " id="1270" linkTypes="1" links="1055" title="\@menuat" />
<node body="Leo creates its menus from the @menu, @item and @popup nodes in the @menus tree. Within @menus trees, @menu nodes create menus and @item nodes create menu items. &lt;br&gt;  &lt;br&gt; The menu name always follows @menu. If the menu name is 'Plugins', Leo will create the Plugins menu and populate the menu by calling the 'create-optional-menus' hook. This creates the Plugins menu as usual. Nested @menu nodes define submenus. &lt;br&gt;  &lt;br&gt; The command name follows @item. If the body text of an @item node exists, this body text is the menu name. Otherwise, the menu name is the command name. However, if the command name starts with a '*', hyphens are removed from the menu name. Menu names and command names may contain a single ampersand (&amp;). If present, the following character is underlined in the name. If the command name in an @item node is just a hyphen (-), the item represents a menu separator. &lt;br&gt;  &lt;br&gt; \@popup *&lt;widget-name&gt;* creates a popup menu for use by the contextmenu.py plugin. The children of this node should be @menu and @item nodes, used as with @menus. &lt;br&gt; " id="1271" linkTypes="1" links="1055" title="\@menus" />
<node body="Leo allows you to specify input modes. You enter mode x with the enter-x-mode command. The purpose of a mode is to create different bindings for keys within a mode. Often plain keys are useful in input modes. &lt;br&gt;  &lt;br&gt; You can specify modes with @mode nodes in leoSettings.leo. @mode nodes work just like @shortcuts nodes, but in addition they have the side effect of creating the enter-&lt;mode name&gt;-mode command. &lt;br&gt;  &lt;br&gt; The form of this node is:: &lt;br&gt;  &lt;br&gt;     @mode *&lt;mode name&gt;* &lt;br&gt;  &lt;br&gt; The body text contains a list of shortcut specifiers. @mode nodes work just like @shortcuts nodes, but in addition they have the side effect of creating the enter-&lt;mode name&gt;-mode command. &lt;br&gt;  &lt;br&gt; Notes: &lt;br&gt;  &lt;br&gt; - You can exit any mode using the keyboard-quit (Control-g) command. This is the **only** binding that is automatically created in each mode. All other bindings must be specified in the @mode node. In particular, the bindings specified in @shortcuts nodes are **not** in effect in mode (again, except for the keyboard-quit binding). &lt;br&gt;  &lt;br&gt; - Leo supports something akin to tab completion within modes: if you type a key that isn't bound in a mode a 'Mode' tab will appear in the log pane. This tab shows all the keys that you can type and the commands to which they are bound. The mode-help command does the same thing. &lt;br&gt;  &lt;br&gt; - @shortcuts nodes specify the bindings for what might be called the 'top-level' mode. These are the bindings in effect when no internal state is present, for example, just after executing the keyboard-quit command. &lt;br&gt;  &lt;br&gt; - The top_level_unbound_key_action setting determines what happens to unbound keys in the top-level mode. Leo ignores unbound keys in all other modes. The possibilities are 'insert', 'replace' and 'ignore'. &lt;br&gt;  &lt;br&gt; - The set-insert-mode, set-overwrite-mode and set-ignore-mode commands alter what happens to unbound keys in the top-level mode. &lt;br&gt;    &lt;br&gt; - If the @mode headline contains ::, everything following the :: is the mode prompt. For example:: &lt;br&gt;      &lt;br&gt;     @mode abc :: xyz &lt;br&gt;      &lt;br&gt; Creates the enter-abc-mode command, but the prompt for the command is xyz. &lt;br&gt;  &lt;br&gt; With all these options it should be possible to emulate the keyboard behavior of any other editor. &lt;br&gt; " id="1272" linkTypes="1" links="1055" title="\@mode" />
<node body="The body text contains a list of paths of recently opened files, one path per line. Leo writes the list of recent files to .leoRecentFiles.txt in Leo's config directory, again one file per line. &lt;br&gt; " id="1273" linkTypes="1" links="1055" title="\@recentfiles" />
<node body="The body text contains a list of shortcut specifiers. &lt;br&gt; " id="1274" linkTypes="1" links="1055" title="\@shortcuts" />
<node body="Allows users to define new @directives." id="1275" linkTypes="1" links="1069" title="add_directives.py" />
<node body="Adds a context menu to each node containing all the commands in the bzr Qt interface. Bzr is invoked based on the path of the current node. &lt;br&gt;  &lt;br&gt; **Requires contextmenu.py.** &lt;br&gt;  &lt;br&gt; " id="1276" linkTypes="1" links="1069" title="bzr_qcommands.py" />
<node body="Allows Leo to open any empty file as a minimal .leo file. &lt;br&gt;  &lt;br&gt; " id="1277" linkTypes="1" links="1069" title="empty_leo_file.py" />
<node body="Allows the user to import Cisco configuration files. &lt;br&gt;  &lt;br&gt; Adds the &quot;File:Import:Import Cisco Configuration&quot; menu item. The plugin will: &lt;br&gt;  &lt;br&gt; 1)  Create a new node, under the current node, where the configuration will be written. This node will typically have references to several sections (see below). &lt;br&gt;  &lt;br&gt; 2)  Create sections (child nodes) for the indented blocks present in the original config file. These child nodes will have sub-nodes grouping similar blocks (e.g. there will be an 'interface' child node, with as many sub-nodes as there are real interfaces in the configuration file). &lt;br&gt;  &lt;br&gt; 3)  Create sections for the custom keywords specified in the customBlocks[] list in importCiscoConfig(). You can modify this list to specify different keywords. DO NOT put keywords that are followed by indented blocks (these are taken care of by point 2 above). The negated form of the keywords (for example, if the keyword is 'service', the negated form is 'no service') is also included in the sections. &lt;br&gt;  &lt;br&gt; 4)  Not display consecutive empty comment lines (lines with only a '!'). &lt;br&gt;  &lt;br&gt; All created sections are alphabetically ordered. &lt;br&gt;  &lt;br&gt; " id="1278" linkTypes="1" links="1069" title="import_cisco_config.py" />
<node body="Modifies the Python @auto importer so that the importer puts the __init__ method (ctor) into the body of the class node. &lt;br&gt;  &lt;br&gt; This makes it easier to keep the instance variable docs in the class docstring in sync. with the ivars as manipulated by __init__, saves repeating explanations in both places. &lt;br&gt;  &lt;br&gt; Note that this is done *after* the consistency checks by the @auto import code, so using this plugin is at your own risk.  It will change the order of declarations if other methods are declared before __init__. &lt;br&gt;  &lt;br&gt; " id="1279" linkTypes="1" links="1069" title="initinclass.py" />
<node body="Allows the user to browse XML documents in Leo. &lt;br&gt;  &lt;br&gt; This file implements an interface to XML generation, so that the resulting file can be processed by leo. &lt;br&gt;  &lt;br&gt; ..  class file represents the whole leo file. &lt;br&gt; ..  class leo_node has a headline and body text. &lt;br&gt;  &lt;br&gt; ..  If you encounter the first of a set of clones, create a leo_node. If you &lt;br&gt; ..  encounter the same set of clones later, create a leo_clone node and refer back &lt;br&gt; ..  to the first element. &lt;br&gt;  &lt;br&gt; " id="1280" linkTypes="1" links="1069" title="leo_interface.py" />
<node body="Adds #line directives in perl and perlpod programs. &lt;br&gt;  &lt;br&gt; Over-rides two methods in leoAtFile.py to write #line directives after node sentinels. This allows compilers to give locations of errors in relation to the node name rather than the filename. Currently supports only perl and perlpod. &lt;br&gt;  &lt;br&gt; " id="1281" linkTypes="1" links="1069" title="lineNumbers.py" />
<node body="Creates new nodes containing parameterized section reference. &lt;br&gt;  &lt;br&gt; This plugin adds nodes under the currently selected tree that are to act as section references. To do so, go the Outline menu and select the 'Parameterize Section Reference' command. This plugin looks for a top level node called 'Parameterized Nodes'. If it finds a headline that matches the section reference it adds a node/nodes to the current tree. &lt;br&gt;  &lt;br&gt; To see this in action, do the following: &lt;br&gt;  &lt;br&gt; 0. **Important**: in the examples below, type &lt;&lt; instead of &lt; &lt; and &lt;br&gt;    type &gt;&gt; instead of &gt; &gt;.  Docstrings can not contain section references! &lt;br&gt;  &lt;br&gt; 1. Create a node called 'Parameterized Nodes', with a sub-node called  &lt; &lt; Meow \&gt;\&gt;. &lt;br&gt;    The body of &lt; &lt; Meow &gt; &gt; should have the text:: &lt;br&gt;  &lt;br&gt;         I mmmm sooo happy I could  &lt; &lt; 1$  &gt; &gt;. &lt;br&gt;         But I don't know if I have all the  &lt; &lt; 2$  &gt; &gt; &lt;br&gt;         money in the world. &lt;br&gt;  &lt;br&gt; 2. In a node called A, type:: &lt;br&gt;  &lt;br&gt;         &lt; &lt; meow( purrrrrr, zzooot )  &gt; &gt; &lt;br&gt;         (leave the cursor at the end of the line) &lt;br&gt;  &lt;br&gt; 3. In a node called B, type:: &lt;br&gt;  &lt;br&gt;          &lt; &lt; meow ( spit or puke, blinking  )  &gt; &gt; &lt;br&gt;         (leave the cursor at the end of the line) &lt;br&gt;  &lt;br&gt; 4. Leave the cursor in Node A at the designated point. &lt;br&gt;  &lt;br&gt; 5. Go to Outline and select Parameterize Section Reference. &lt;br&gt;  &lt;br&gt; The plugin searches the outline, goes to level one and finds a Node with the Headline, &quot;Parameterized Nodes&quot;. It looks for nodes under that headline with the the headline &lt;\&lt; meow &gt;\&gt;. It then creates this node structure under Node A:: &lt;br&gt;  &lt;br&gt;         &lt; &lt; meow ( purrrrrr, zzooot ) &gt; &gt; &lt;br&gt;             &lt; &lt;2$&gt; &gt; &lt;br&gt;             &lt; &lt;1$&gt; &gt; &lt;br&gt;  &lt;br&gt; 6. Examine the new subnodes of Node A:   &lt;br&gt;  &lt;br&gt;         &lt; &lt; meow ( purrrrrr, zzooot ) &gt; &gt; contains the body text of the &lt; &lt; meow &gt; &gt; node. &lt;br&gt;         &lt; &lt; 1$ &gt; &gt; contains the word purrrrrr. &lt;br&gt;         &lt; &lt; 2$ &gt; &gt; contains the word zzooot. &lt;br&gt;  &lt;br&gt; 7. Go to Node B, and leave the cursor at the designated point. &lt;br&gt;  &lt;br&gt; Go to Outline Menu and select Parameterize Section Reference command. &lt;br&gt;  &lt;br&gt; 8. Examine the new subnodes of Node B. &lt;br&gt;  &lt;br&gt; It's a lot easier to use than to explain! &lt;br&gt; " id="1282" linkTypes="1" links="1069" title="macros.py" />
<node body="Autosaves the Leo outline every so often. &lt;br&gt;  &lt;br&gt; The time between saves is given by the setting, with default as shown:: &lt;br&gt;  &lt;br&gt;     @int mod_autosave_interval = 300 &lt;br&gt;  &lt;br&gt; This plugin is active only if:: &lt;br&gt;  &lt;br&gt;     @bool mod_autosave_active = True &lt;br&gt;  &lt;br&gt; " id="1283" linkTypes="1" links="1069" title="mod_autosave.py" />
<node body="Allows Leo to read a complete directory tree into a Leo outline. Converts directories into headlines and puts the list of file names into bodies. &lt;br&gt;  &lt;br&gt; Ce plug-in permet de traduire l'arborescence d'un répertoire en une arborescence Leo : Chaque dossier est converti en noeud dans Leo ; son nom est placé dans l'entête du noeud et chaque nom de fichier qu'il contient est listé dans son contenu. &lt;br&gt;  &lt;br&gt; Feedback on this plugin can be sent to:: &lt;br&gt;  &lt;br&gt;     Frédéric Momméja &lt;br&gt;     &lt;frederic [point] mommeja [at] laposte [point] net&gt; &lt;br&gt;  &lt;br&gt; " id="1284" linkTypes="1" links="1069" title="mod_read_dir_outline.py" />
<node body="Timestamps all save operations to show when they occur. &lt;br&gt;  &lt;br&gt; " id="1285" linkTypes="1" links="1069" title="mod_timestamp.py" />
<node body="Allows the definition of double-click actions. &lt;br&gt;  &lt;br&gt; When the user double-clicks a node this plugin checks for a match of the clicked node's headline text with a list of patterns. If a match occurs, the plugin executes the associated script. &lt;br&gt;  &lt;br&gt; **nodeAction** nodes may be located anywhere in the outline. Such nodes should contain one or more **pattern nodes** as children. The headline of each pattern node contains the pattern; the body text contains the script to be executed when the pattern matches the double-clicked node. &lt;br&gt;  &lt;br&gt; For example, the &quot;nodeActions&quot; node containing a &quot;launch URL&quot; pattern node and a &quot;pre-process python code&quot; node could be placed under an &quot;@settings&quot; node:: &lt;br&gt;  &lt;br&gt;    @settings &lt;br&gt;    | &lt;br&gt;    +- nodeActions &lt;br&gt;       | &lt;br&gt;       +- http:\\* &lt;br&gt;       | &lt;br&gt;       +- @file *.py &lt;br&gt;  &lt;br&gt; **Configuration** &lt;br&gt;  &lt;br&gt; The nodeActions plugin supports the following global configurations using Leo's support for setting global variables within an @settings node's sub-nodes in the leoSettings.leo, myLeoSettings.leo, and the project Leo file: &lt;br&gt;  &lt;br&gt; @bool nodeActions_save_atFile_nodes = False &lt;br&gt;  &lt;br&gt;   :True: &lt;br&gt;      Double-click on an @file type node will save the file to disk &lt;br&gt;      before executing the script. &lt;br&gt;  &lt;br&gt;   :False: &lt;br&gt;      Double-click on an @file type node will **not** save the file to disk &lt;br&gt;      before executing the script. (default) &lt;br&gt;  &lt;br&gt; @int nodeActions_message_level = 1 &lt;br&gt;  &lt;br&gt;   Specifies the type of messages to be sent to the log pane.  Specifying a &lt;br&gt;   higher message level will display that level and all lower levels. &lt;br&gt;   The following integer values are supported:: &lt;br&gt;  &lt;br&gt;     0 no messages &lt;br&gt;     1 Plugin triggered and the patterns that were matched (default) &lt;br&gt;     2 Double-click event passed or not to next plugin &lt;br&gt;     3 Patterns that did not match &lt;br&gt;     4 Code debugging messages &lt;br&gt;  &lt;br&gt; **Patterns** &lt;br&gt;  &lt;br&gt; Pattern matching is performed using python's support for Unix shell-style patterns unless overwritten by the &quot;X&quot; pattern directive. The following pattern elements are supported:: &lt;br&gt;  &lt;br&gt;     *           matches everything &lt;br&gt;     ?           matches any single character &lt;br&gt;     [&lt;seq&gt;]     matches any character in &lt;seq&gt; &lt;br&gt;     [!&lt;seq&gt;]    matches any character **not** in &lt;seq&gt; &lt;br&gt;  &lt;br&gt; Unix shell-style pattern matching is case insensitive and always starts from the beginning of the headline.  For example: &lt;br&gt;  &lt;br&gt;      ======= =========== ============== &lt;br&gt;      Pattern   Matches   Does not match &lt;br&gt;      ======= =========== ============== &lt;br&gt;      \*.py   Abc_Test.py &lt;br&gt;      .py     .py - Test  Abc_Test.py &lt;br&gt;      test*   Test_Abc.py Abc_Test.py &lt;br&gt;      ======= =========== ============== &lt;br&gt;  &lt;br&gt; To enable a script to run on any type of @file node (@thin, @shadow, ...), the pattern can start with &quot;@files&quot; to match on any external file type.  For example, the pattern &quot;@files \*.py&quot; will match a node with the headline &quot;@file abcd.py&quot;. &lt;br&gt;  &lt;br&gt; The headline of the double-clicked node is matched against the patterns starting from the first sub-node under the &quot;nodeActions&quot; node to the last sub-node. &lt;br&gt;  &lt;br&gt; Only the script associated with the first matching pattern is invoked unless overwritten by the &quot;V&quot; pattern directive. &lt;br&gt;  &lt;br&gt; Using the &quot;V&quot; pattern directive allows a broad pattern such as &quot;@files \*.py&quot; to be invoked, and then, by placing a more restrictive pattern above it, such as &quot;@files \*_test.py&quot;, a different script can be executed for those files requiring pre-processing:: &lt;br&gt;  &lt;br&gt;   +- nodeActions &lt;br&gt;      | &lt;br&gt;      +- @files *_test.py &lt;br&gt;      | &lt;br&gt;      +- @files *.py &lt;br&gt;  &lt;br&gt; **Note**: To prevent Leo from trying to save patterns that begin with a derived file directive (@file, @auto, ...) to disk, such as &quot;@file \*.py&quot;, place the &quot;@ignore&quot; directive in the body of the &quot;nodeActions&quot; node. &lt;br&gt;  &lt;br&gt; Pattern nodes can be placed at any level under the &quot;nodeActions&quot; node. Only nodes with no child nodes are considered pattern nodes. This allows patterns that are to be used in multiple Leo files to be read from a file.  For example, the following structure reads the pattern definition from the &quot;C:\\Leo\\nodeActions_Patterns.txt&quot; file:: &lt;br&gt;  &lt;br&gt;     +- nodeActions &lt;br&gt;     | &lt;br&gt;     +- @files C:\\Leo\\nodeActions_Patterns.txt &lt;br&gt;         | &lt;br&gt;         +- http:\\* &lt;br&gt;         | &lt;br&gt;         +- @file *.py &lt;br&gt;  &lt;br&gt; **Pattern directives** &lt;br&gt;  &lt;br&gt; The following pattern specific directives can be appended to the end of a pattern (do not include the ':'): &lt;br&gt;  &lt;br&gt; :[X]: &lt;br&gt;   Use python's regular expression type patterns instead of the Unix &lt;br&gt;   shell-style pattern syntax. &lt;br&gt;  &lt;br&gt;   For example, the following patterns will match the same headline string:: &lt;br&gt;  &lt;br&gt;      Unix shell-style pattern: &lt;br&gt;         @files *.py &lt;br&gt;  &lt;br&gt;      Regular Expression pattern: &lt;br&gt;         ^@files .*\.py$ [X] &lt;br&gt;  &lt;br&gt; :[V]: &lt;br&gt;   Matching the pattern will not block the double-click event from &lt;br&gt;   being passed to the remaining patterns. &lt;br&gt;   The &quot;V&quot; represents a down arrow that symbolizes the passing of the event &lt;br&gt;   to the next pattern below it. &lt;br&gt;  &lt;br&gt;   For example, adding the &quot;[V]&quot; directive to the &quot;@files \*_test.py&quot; in &lt;br&gt;   the Patterns section above, changes its script from being 'an &lt;br&gt;   alternate to' to being 'a pre-processor for' the &quot;@files \*.py&quot; script:: &lt;br&gt;  &lt;br&gt;      +- nodeActions &lt;br&gt;         | &lt;br&gt;         +- @files *_test.py [V] &lt;br&gt;         | &lt;br&gt;         +- @files *.py &lt;br&gt;  &lt;br&gt; :[&gt;]: &lt;br&gt;   Matching the pattern will not block the double-click event from being &lt;br&gt;   passed to other plugins. &lt;br&gt;   The &quot;&gt;&quot; represents a right arrow that &lt;br&gt;   symbolizes the passing of the event to the next plugin. &lt;br&gt;  &lt;br&gt;   If the headline matched more than one headline, &lt;br&gt;   the double-click event will be passed to the next plugin if the &lt;br&gt;   directive is associated with any of the matched patterns. &lt;br&gt;  &lt;br&gt; The directive(s) for a pattern must be contained within a single set of brackets, separated from the pattern by a space, with or without a comma separator.  For example, the following specifies all three directives:: &lt;br&gt;  &lt;br&gt;   ^@files .*\.py$ [X,V&gt;] &lt;br&gt;  &lt;br&gt; **Scripts** &lt;br&gt;  &lt;br&gt; The script for a pattern is located in the body of the pattern's node. The following global variables are available to the script:: &lt;br&gt;  &lt;br&gt;     c &lt;br&gt;     g &lt;br&gt;     pClicked - node position of the double-clicked node &lt;br&gt;     pScript - node position of the invoked script &lt;br&gt;  &lt;br&gt; **Examples** &lt;br&gt;  &lt;br&gt; Double-clicking on a node with a &quot;http:\\\\www.google.com&quot; headline will invoke the script associated with the &quot;http:\\\\\*&quot; pattern.  The following script in the body of the pattern's node displays the URL in a browser:: &lt;br&gt;  &lt;br&gt;      import webbrowser &lt;br&gt;      hClicked = pClicked.h     #Clicked node's Headline text &lt;br&gt;      webbrowser.open(hClicked) #Invoke browser &lt;br&gt;  &lt;br&gt; The following script can be placed in the body of a pattern's node to execute a command in the first line of the body of a double-clicked node:: &lt;br&gt;  &lt;br&gt;      g.os.system('&quot;Start /b ' + pClicked.bodyString() + '&quot;') &lt;br&gt; " id="1286" linkTypes="1" links="1069" title="nodeActions.py" />
<node body="Modifies the way exported outlines are written. &lt;br&gt;  &lt;br&gt; " id="1287" linkTypes="1" links="1069" title="outline_export.py" />
<node body="Creates new headlines from clipboard text. &lt;br&gt;  &lt;br&gt; If the pasted text would be greater than 50 characters in length, the plugin truncates the headline to 50 characters and pastes the entire line into the body text of that node. Creates a &quot;Paste as Headlines&quot; option the Edit menu directly under the existing Paste option. &lt;br&gt;  &lt;br&gt; " id="1288" linkTypes="1" links="1069" title="paste_as_headlines.py" />
<node body="Customizes pretty printing. &lt;br&gt;  &lt;br&gt; The plugin creates a do-nothing subclass of the default pretty printer. To customize, simply override in this file the methods of the base prettyPrinter class in leoCommands.py. You would typically want to override putNormalToken or its allies. Templates for these methods have been provided. You may, however, override any methods you like. You could even define your own class entirely, provided you implement the prettyPrintNode method. &lt;br&gt;  &lt;br&gt; " id="1289" linkTypes="1" links="1069" title="pretty_print.py" />
<node body="Creates buttons to move nodes quickly to other nodes. &lt;br&gt;  &lt;br&gt; Quickly move/copy/clone nodes from around the tree to one or more target nodes. It can also create bookmark and tagging functionality in an outline (see `Set Parent Notes` below). &lt;br&gt;  &lt;br&gt; Adds `Move/Clone/Copy To Last Child Button` and `Move/Clone/Copy To First Child Button`, `Link To/From` and `Jump To` commands to the Move sub-menu on the Outline menu, and each node's context menu, if the `contextmenu` plugin is enabled. &lt;br&gt;  &lt;br&gt; Select a node ``Foo`` and then use the `Move To Last Child Button` command. This adds a 'to Foo' button to the button bar. Now select another node and click the 'to Foo' button. The selected node will be moved to the last child of the node 'Foo'. &lt;br&gt;  &lt;br&gt; `To First Child Button` works the same way, except that moved nodes are inserted as the first child of the target node. &lt;br&gt;  &lt;br&gt; `Clone` and `Copy` variants are like `Move`, but clone or copy instead of moving. &lt;br&gt;  &lt;br&gt; `Link` works in conjunction with the `backlink` plugin (and also the `graphcanvas` plugin) creating a link to/from the target and current nodes. &lt;br&gt;  &lt;br&gt; `Jump` buttons act as bookmarks, taking you to the target node. &lt;br&gt;  &lt;br&gt; You can right click on any of these buttons to access their context menu: &lt;br&gt;  &lt;br&gt;   Goto Target &lt;br&gt;     takes you to the target node (like a `Jump` button). &lt;br&gt;   Make Permanent &lt;br&gt;     makes the button permanent, it will reappear &lt;br&gt;     when the file is saved / closed / re-opened. &lt;br&gt;   Set Parent &lt;br&gt;     allows you to move buttons to sub-menu items of other &lt;br&gt;     `quickMove` buttons.  This implicitly makes the moved button &lt;br&gt;     permanent.  It also causes the moved button to lose its context menu. &lt;br&gt;   Remove Button &lt;br&gt;     comes from the `mod_scripting` plugin, and just &lt;br&gt;     removes the button for the rest of the current session. &lt;br&gt;  &lt;br&gt; Set Parent Notes &lt;br&gt;   `Set Parent` doesn't allow you to do anything with `quickMove` you couldn't &lt;br&gt;   do with a long strip of separate buttons, but it collects quickMove buttons &lt;br&gt;   as sub-menu items of one quickMove button, saving a lot of toolbar space. &lt;br&gt;  &lt;br&gt; Bookmarks  &lt;br&gt;   Create somewhere out of the way in your outline a node called &lt;br&gt;   `Bookmarks`. Use the quickMove menu to make it a `Jump To` button, and use its &lt;br&gt;   context menu to make it permanent. There is no particular reason to jump to &lt;br&gt;   it, but it needs to be a `quickMove` button of some kind. &lt;br&gt;  &lt;br&gt;   Now, when you want to bookmark a node, first use the quickMove menu to make &lt;br&gt;   the node a `Jump To` button, and then use the context menu on the button to &lt;br&gt;   set its parent to your `Bookmarks` button.  It becomes a sub-menu item &lt;br&gt;   of the `Bookmarks` button. &lt;br&gt;  &lt;br&gt; Tags &lt;br&gt;   In conjunction with the `backlinks` plugin you can use `quickMove` to &lt;br&gt;   tag nodes.   The `backlinks` plugin adds a `Links` tab to the `Log pane`. &lt;br&gt;  &lt;br&gt;   Create somewhere in your outline a node called `Tags`. Use the quickMove menu &lt;br&gt;   to make it a `Jump To` button, and use its context menu to make it permanent. &lt;br&gt;   Clicking on it will jump you to your tag list. Now create a node under the &lt;br&gt;   `Tags` node for each tag you want. The node's name will be the tag name, and &lt;br&gt;   can be changed later. Then use the quickMove menu to make each of these nodes &lt;br&gt;   a `Link To` button, and then use the context menu on the button to set its &lt;br&gt;   parent to your `Tags` button. It becomes a sub-menu item of the `Tags` button. &lt;br&gt;  &lt;br&gt;   To see the tags on a node, you need to be looking at the `Links` tab in the &lt;br&gt;   `Log pane`.  To see all the nodes with a particular tag, click on the `Tags` &lt;br&gt;   button to jump to the tag list, and select the node which names the tag of &lt;br&gt;   interest.  The nodes with that tag will be listed in th `Links` tab in the &lt;br&gt;   `Log pane`. &lt;br&gt;  &lt;br&gt; " id="1290" linkTypes="1" links="1069" title="quickMove.py" />
<node body="Sets g.app.homeDir to a hard-coded path. &lt;br&gt;  &lt;br&gt; " id="1291" linkTypes="1" links="1069" title="setHomeDirectory.py" />
<node body="Counts characters, words, lines, and paragraphs in the body pane. &lt;br&gt;  &lt;br&gt; It adds a &quot;Word Count...&quot; option to the bottom of the Edit menu that will activate the command. &lt;br&gt;  &lt;br&gt; " id="1292" linkTypes="1" links="1069" title="word_count.py" />
<node body="Makes g.pdb() enter the Pudb debugger instead of pdb. &lt;br&gt;  &lt;br&gt; Pudb is a full-screen Python debugger: http://pypi.python.org/pypi/pudb &lt;br&gt; " id="1293" linkTypes="1" links="1070" title="debugger_pudb.py" />
<node body="Dumps Python globals at startup. &lt;br&gt;  &lt;br&gt; " id="1294" linkTypes="1" links="1070" title="dump_globals.py" />
<node body="Enables debugging and tracing for Python's garbage collector. &lt;br&gt;  &lt;br&gt; " id="1295" linkTypes="1" links="1070" title="enable_gc.py" />
<node body="Shows how to force Leo to quit. &lt;br&gt;  &lt;br&gt; " id="1296" linkTypes="1" links="1070" title="quit_leo.py" />
<node body="Traces changes to Leo's objects at idle time. &lt;br&gt;  &lt;br&gt; " id="1297" linkTypes="1" links="1070" title="trace_gc_plugin.py" />
<node body="Traces keystrokes in the outline and body panes. &lt;br&gt;  &lt;br&gt; " id="1298" linkTypes="1" links="1070" title="trace_keys.py" />
<node body="Traces most common hooks, but not key, drag or idle hooks. &lt;br&gt;  &lt;br&gt; " id="1299" linkTypes="1" links="1070" title="trace_tags.py" />
<node body="Creates a two-way communication (bridge) between Leo scripts and IPython running in the console from which Leo was launched. &lt;br&gt;  &lt;br&gt; Using this bridge, scripts running in Leo can affect IPython, and vice versa. In particular, scripts running in IPython can alter Leo outlines! &lt;br&gt;  &lt;br&gt; For full details, see Leo Users Guide: http://leoeditor.com/IPythonBridge.html &lt;br&gt; " id="1300" linkTypes="1" links="1071" title="ipython.py" />
<node body="Creates an 'Extensions' menu containing two commands: Open Console Window and Open Explorer. &lt;br&gt;  &lt;br&gt; The Open Console Window command opens xterm on Linux. The Open Explorer command Opens a Windows explorer window. &lt;br&gt;  &lt;br&gt; This allows quick navigation to facilitate testing and navigating large systems with complex directories. &lt;br&gt;  &lt;br&gt; Please submit bugs / feature requests to etaekema@earthlink.net &lt;br&gt;  &lt;br&gt; Current limitations: &lt;br&gt; - Not tested on Mac OS X ... &lt;br&gt; - On Linux, xterm must be in your path. &lt;br&gt;  &lt;br&gt; " id="1301" linkTypes="1" links="1071" title="open_shell.py" />
<node body="Allows imports of notes created in Tomboy / gnote. &lt;br&gt;  &lt;br&gt; Usage: &lt;br&gt;  &lt;br&gt; * Create a node with the headline 'tomboy' &lt;br&gt; * Select the node, and do alt+x act-on-node     &lt;br&gt; * The notes will appear as children of 'tomboy' node &lt;br&gt; * The next time you do act-on-node, existing notes will be updated (they don't need to  &lt;br&gt;   be under 'tomboy' node anymore) and new notes added. &lt;br&gt;  &lt;br&gt; " id="1302" linkTypes="1" links="1071" title="tomboy_import.py" />
<node body="Enables two-way communication with gvim (recommended) or vim. with the following commands: &lt;br&gt;  &lt;br&gt; ``vim-open-file`` &lt;br&gt;     Opens the nearest ancestor @file or @clean node in vim. Leo will update &lt;br&gt;     the file in the outline when you save the file in vim. &lt;br&gt;  &lt;br&gt; ``vim-open-node`` &lt;br&gt;     Opens the selected node in vim. Leo will update the node in the outline &lt;br&gt;     when you save the file in vim. &lt;br&gt; " id="1303" linkTypes="1" links="1071" title="vim.py" />
<node body="Allows you to edit nodes in emacs/xemacs. &lt;br&gt;  &lt;br&gt; Depending on your preference, selecting or double-clicking a node will pass the body text of that node to emacs. You may edit the node in the emacs buffer and changes will appear in Leo. &lt;br&gt;  &lt;br&gt; " id="1304" linkTypes="1" links="1071" title="xemacs.py" />
<node body="Adds the Plugins\:Word Export\:Export menu item to format and export the selected outline to a Word document, starting Word if necessary. &lt;br&gt;  &lt;br&gt; " id="1305" linkTypes="1" links="1071" title="word_export.py" />
<node body="Synchronizes @path nodes with folders. &lt;br&gt;  &lt;br&gt; If a node is named '@path path_to_folder', the content (file and folder names) of the folder and the children of that node will synchronized whenever the node's status-iconbox is double clicked. &lt;br&gt;  &lt;br&gt; For files not previously seen in a folder a new node will appear on top of the children list (with a mark). &lt;br&gt;  &lt;br&gt; Folders appear in the list as /foldername/. If you double click on the icon-box of the folder node, it will have children added to it based on the contents of the folder on disk. These folders have the '@path' directive as the first line of their body text. &lt;br&gt;  &lt;br&gt; When files are deleted from the folder and the list is updated by double clicking the files will appear in the list as *filename* (or */foldername/*). &lt;br&gt;  &lt;br&gt; You can describe files and directories in the body of the nodes. &lt;br&gt;  &lt;br&gt; You can organize files and directories with organizer nodes, an organizer node name cannot contain with '/'. &lt;br&gt;  &lt;br&gt; Files and folders can be created by entering a node with the required name as its headline (must start and/or end with &quot;/&quot; for a folder) and then double clicking on the node's status-iconbox. &lt;br&gt;  &lt;br&gt; \@auto nodes can be set up for existing files can be loaded by double clicking on the node's status-iconbox. If you prefer @shadow or something else use the &quot;active_path_attype&quot; setting, without the &quot;@&quot;. &lt;br&gt;  &lt;br&gt; There are commands on the Plugins active_path submenu: &lt;br&gt;  &lt;br&gt; - show path - show the current path &lt;br&gt; - set absolute path - changes a node &quot;/dirname/&quot; to &quot;@path /absolute/path/to/dirname&quot;. &lt;br&gt; - purge vanished (recursive) - remove *entries* &lt;br&gt; - update recursive - recursive load of directories, use with caution on large &lt;br&gt;   file systems &lt;br&gt;  &lt;br&gt; If you want to use an input other than double clicking a node's status-iconbox set active_path_event to a value like 'iconrclick1' or 'iconclick1'. &lt;br&gt;  &lt;br&gt; There are @settings for ignoring directory entries and automatically loading files.  ``re.search`` is used, rather than ``re.match``, so patterns need only match part of the filename, not the whole filename. &lt;br&gt;  &lt;br&gt; The body of the @setting ``@data active_path_ignore`` is a list of regex patterns, one per line.  Directory entries matching any pattern in the list will be ignored.  The names of directories used for matching will have forward slashes around them ('/dirname/'), so patterns can use this to distinguish between directories and files. &lt;br&gt;  &lt;br&gt; The body of the @setting ``@data active_path_autoload`` is a list of regex patterns, one per line.  File entries matching any pattern in the list will be loaded automatically.  This works only with files, not directories (but you can load directories recursively anyway). &lt;br&gt;  &lt;br&gt; Set ``@bool active_path_load_docstring = True`` to have active_path load the docstring of .py files automatically.  These nodes start with the special string:: &lt;br&gt;  &lt;br&gt;     @language rest # AUTOLOADED DOCSTRING &lt;br&gt;  &lt;br&gt; which must be left intact if you want active path to be able to double-click load the file later. &lt;br&gt;  &lt;br&gt; \@float active_path_timeout_seconds (default 10.) controls the maximum time active_path will spend on a recursive operation. &lt;br&gt;  &lt;br&gt; \@int active_path_max_size (default 1000000) controls the maximum size file active_path will open without query. &lt;br&gt;  &lt;br&gt; active_path is a rewrite of the at_directory plugin to use @path directives (which influence @auto and other @file type directives), and to handle sub-folders more automatically. &lt;br&gt; " id="1306" linkTypes="1" links="1072" title="active_path.py" />
<node body="Synchronizes @folder nodes with folders. &lt;br&gt;  &lt;br&gt; If a node is named '@folder path_to_folder', the content (filenames) of the folder and the children of that node will be sync. Whenever a new file is put there, a new node will appear on top of the children list (with mark). So that I can put my description (i.e. annotation) as the content of that node. In this way, I can find any files much easier from leo. &lt;br&gt;  &lt;br&gt; Moreover, I add another feature to allow you to group files(in leo) into children of another group. This will help when there are many files in that folder. You can logically group it in leo (or even clone it to many groups), while keep every files in a flat/single directory on your computer. &lt;br&gt;  &lt;br&gt; " id="1307" linkTypes="1" links="1072" title="at_folder.py" />
<node body="Executes commands in nodes whose body text starts with @produce. &lt;br&gt;  &lt;br&gt; WARNING: trying to execute a non-existent command will hang Leo. &lt;br&gt;  &lt;br&gt; To use, put in the body text of a node:: &lt;br&gt;  &lt;br&gt;     @produce echo hi &lt;br&gt;      &lt;br&gt; This plugin creates two new commands: at-produce-all and at-produce-selected. &lt;br&gt;  &lt;br&gt; at-produce-all scans the entire tree for body text containing @produce. at-produce-selected just scans the selected tree. &lt;br&gt;  &lt;br&gt; Whatever follows @produce is executed as a command. &lt;br&gt;  &lt;br&gt; @produce commands are executed in the order they are found, that is, in outline order. &lt;br&gt;  &lt;br&gt; The at-produce commands produce a log node as the last top-level node of the outline. Any output, including error messages, should be there. &lt;br&gt;  &lt;br&gt; This plugin is not intended as a replacement for make or Ant, but as a simple substitute when that machinery is overkill. &lt;br&gt; " id="1308" linkTypes="1" links="1072" title="at_produce.py" />
<node body="Adds support for @clip, @view and @strip nodes. &lt;br&gt;  &lt;br&gt; - Selecting a headline containing @clip appends the contents of the clipboard to &lt;br&gt;   the end of the body pane. &lt;br&gt;  &lt;br&gt; - Double clicking the icon box of a node whose headline contains @view &lt;br&gt;   *&lt;path-to-file&gt;* places the contents of the file in the body pane. &lt;br&gt;  &lt;br&gt; - Double clicking the icon box of a node whose headline contains @strip &lt;br&gt;   *&lt;path-to-file&gt;* places the contents of the file in the body pane, with all &lt;br&gt;   sentinels removed. &lt;br&gt;  &lt;br&gt; This plugin also accumulates the effect of all @path nodes. &lt;br&gt;  &lt;br&gt; " id="1309" linkTypes="1" links="1072" title="at_view.py" />
<node body="Allows arbitrary links between nodes. &lt;br&gt;  &lt;br&gt; " id="1310" linkTypes="1" links="1072" title="backlink.py" />
<node body="Allows users to insert headlines containing dates. &lt;br&gt;  &lt;br&gt; 'Date nodes' are nodes that have dates in their headlines. They may be added to the outline one at a time, a month's-worth at a time, or a year's-worth at a time. The format of the labels (headlines) is configurable. &lt;br&gt;  &lt;br&gt; There are options to omit Saturdays and Sundays. &lt;br&gt;  &lt;br&gt; An 'Insert Date Nodes ...' submenu will be created (by default) in the 'Outline' menu.  This menu can be suppressed by using either of the following settings:: &lt;br&gt;  &lt;br&gt;     - @bool suppress-datenodes-menus &lt;br&gt;     - @bool suppress-all-plugins-menus &lt;br&gt;  &lt;br&gt; The following commands are available for use via the minibuffer or in @menu/@popup settings:: &lt;br&gt;  &lt;br&gt;     - datenodes-today &lt;br&gt;     - datenodes-this-month &lt;br&gt;     - datenodes-this-year &lt;br&gt;  &lt;br&gt; " id="1311" linkTypes="1" links="1072" title="datenodes.py" />
<node body="Adds @expfolder nodes that represent folders in the file system. &lt;br&gt;  &lt;br&gt; Double clicking on the icon of an @expfolder heading reads the files in the directory at the path specified and creates child nodes for each file in the subfolder. Subdirectories are made into child @expfolder nodes so the tree can be easily traversed. If files have extensions specified in the expfolder.ini file they are made into @text nodes so the content of the files can be easily loaded into leo and edited. Double clicking a second time will delete all child nodes and refresh the directory listing. If there are any changed @text nodes contained inside you will be prompted about saving them. &lt;br&gt;  &lt;br&gt; The textextensions field on the expfolder Properties page contains a list of extensions which will be made into @text nodes, separated by spaces. &lt;br&gt;  &lt;br&gt; For the @text and @expfolder nodes to interact correctly, the textnode plugin must load before the expfolder plugin. This can be set using the Plugin Manager's Plugin Load Order pane. &lt;br&gt; " id="1312" linkTypes="1" links="1072" title="expfolder.py" />
<node body="Defines actions taken when double-clicking on @&lt;file&gt; nodes and supports @file-ref nodes. &lt;br&gt;  &lt;br&gt; Double-clicking any kind of @&lt;file&gt; node writes out the file if changes have been made since the last save, and then runs a script on it, which is retrieved from the outline. &lt;br&gt;  &lt;br&gt; Scripts are located in a node whose headline is FileActions. This node can be anywhere in the outline. If there is more than one such node, the first one in outline order is used. &lt;br&gt;  &lt;br&gt; The children of that node are expected to contain a file pattern in the headline and the script to be executed in the body. The file name is matched against the patterns (which are Unix-style shell patterns), and the first matching node is selected. If the filename is a path, only the last item is matched. &lt;br&gt;  &lt;br&gt; Execution of the scripts is similar to the &quot;Execute Script&quot; command in Leo. The main difference is that the namespace in which the scripts are run contains these elements: &lt;br&gt;  &lt;br&gt; - 'c' and 'g' and 'p': as in the regular execute script command. &lt;br&gt;  &lt;br&gt; - 'filename': the filename from the @file directive. &lt;br&gt;  &lt;br&gt; - 'shellScriptInWindow', a utility function that runs a shell script in an external windows, thus permitting programs to be called that require user interaction &lt;br&gt;  &lt;br&gt; File actions are implemented for all kinds @&lt;file&gt; nodes. There is also a new node type @file-ref for referring to files purely for the purpose of file actions, Leo does not do anything with or to such files. &lt;br&gt; " id="1313" linkTypes="1" links="1072" title="FileActions.py" />
<node body="Tags nodes with latitude and longitude. &lt;br&gt;  &lt;br&gt; " id="1314" linkTypes="1" links="1072" title="geotag.py" />
<node body="Creates a LeoCursor object that can walk around a Leo outline and decode attributes from nodes. &lt;br&gt;  &lt;br&gt; Node names can be used through . (dot) notation so ``cursor.Data.Name._B`` for example returns the body text of the Name node which is a child of the Data node which is a child of the cursors current location. &lt;br&gt;  &lt;br&gt; See .../plugins/examples/leocursorexample.leo for application. &lt;br&gt;  &lt;br&gt; " id="1315" linkTypes="1" links="1072" title="leocursor.py" />
<node body="Opens files with their default platform program. &lt;br&gt;  &lt;br&gt; Double-clicking @mime nodes will attempt to open the named file as if opened from a file manager. @path parent nodes are used to find the full filename path.  Fore example:: &lt;br&gt;  &lt;br&gt;     @mime foodir/document.pdf &lt;br&gt;  &lt;br&gt; The string setting 'mime_open_cmd' allows specifying a program to handle opening files:: &lt;br&gt;  &lt;br&gt;     @settings &lt;br&gt;         @string mime_open_cmd = see &lt;br&gt;         .. or .. &lt;br&gt;         @string mime_open_cmd = see %s &lt;br&gt;  &lt;br&gt; Where '%s' is replaced with the full pathname. &lt;br&gt;  &lt;br&gt; **Note**: This plugin terminates handling of the 'icondclick1' event by returning True. If another plugin using this event (e.g. vim.py) is also enabled, the order in @enabled-plugins matters. For example: if vim.py is enabled before mime.py, double-clicking on an @mime node will both open the body text in [g]vim AND call the mime_open_cmd. &lt;br&gt;  &lt;br&gt; This plugin is complementary to the UNL.py plugin's @url nodes. Use @url for opening either URLs or Uniform Node Locators in &quot;\*.leo&quot; files and use @mime nodes for opening files on the local file system. It also replaces the startfile.py plugin, where here the headline must start with @mime to activate this plugin. &lt;br&gt;  &lt;br&gt; For other sys.platform's, add an elif case to the section &quot;guess file association handler&quot; and either define a default _mime_open_cmd string, where &quot;%s&quot; will be replaced with the filename, or define a function taking the filename string as its only argument and set as open_func. &lt;br&gt; " id="1316" linkTypes="1" links="1072" title="mime.py" />
<node body="Allows Leo to write a file to multiple locations. &lt;br&gt;  &lt;br&gt; This plugin acts as a post-write mechanism, a file must be written to the file system for it to work. At this point it is not a replacement for @path or an absolute path, it works in tandem with them. &lt;br&gt;  &lt;br&gt; To use, place @multipath at the start of a line in the root node or an ancestor of the node. The format is (On Unix-like systems):: &lt;br&gt;  &lt;br&gt;     @multipath /machine/unit/:/machine/robot/:/machine/ &lt;br&gt;  &lt;br&gt; New in version 0.6 of this plugin: the separator used above is ';' not ':', for example:: &lt;br&gt;  &lt;br&gt;     @multipath c:\prog\test;c:\prog\unittest &lt;br&gt;  &lt;br&gt; It will places copy of the written file in each of these directories. &lt;br&gt;  &lt;br&gt; There is an additional directive that simplifies common paths, it is called &lt;br&gt; @multiprefix. By typing @multiprefix with a path following it, before a &lt;br&gt; @multipath directive you set the beginning of the paths in the @multipath &lt;br&gt; directive. For example:: &lt;br&gt;  &lt;br&gt;     #@multiprefix /leo #@multipath /plugins  &lt;br&gt;  &lt;br&gt; or:: &lt;br&gt;  &lt;br&gt;     #@multiprefix /leo/ &lt;br&gt;     #@multipath plugins: fungus : drain &lt;br&gt;  &lt;br&gt; copies a file to /leo/plugins /leo/fungus /leo/drain. &lt;br&gt;  &lt;br&gt; **Note**: I put # in front of the directives here because I don't want someone browsing this file to accidentally save multiple copies of this file to their system!  &lt;br&gt;  &lt;br&gt; The @multiprefix stays in effect for the entire tree until reset with another &lt;br&gt; @multiprefix directive. @multipath is cumulative, in that for each @multipath in &lt;br&gt; an ancestor a copy of the file is created. These directives must at the beginning of the line and by themselves. &lt;br&gt;  &lt;br&gt; " id="1317" linkTypes="1" links="1072" title="multifile.py" />
<node body="Ensures that all descendants of @file-nosent nodes end with exactly one newline, replaces all tabs with spaces, and adds a newline before class and functions in the derived file. &lt;br&gt;  &lt;br&gt; " id="1318" linkTypes="1" links="1072" title="niceNosent.py" />
<node body="Creates and updates @read-only nodes. &lt;br&gt;  &lt;br&gt; Here's my first attempt at customizing leo. I wanted to have the ability to import files in &quot;read-only&quot; mode, that is, in a mode where files could only be read by leo (not tangled), and also kept in sync with the content on the drive. &lt;br&gt;  &lt;br&gt; The reason for this is for example that I have external programs that generate resource files. I want these files to be part of a leo outline, but I don't want leo to tangle or in any way modify them. At the same time, I want them to be up-to-date in the leo outline. &lt;br&gt;  &lt;br&gt; So I coded the directive plugin. It has the following characteristics: &lt;br&gt;  &lt;br&gt; - It reads the specified file and puts it into the node content. &lt;br&gt;  &lt;br&gt; - If the @read-only directive was in the leo outline already, and the file content on disk has changed from what is stored in the outline, it marks the node as changed and prints a &quot;changed&quot; message to the log window; if, on the other hand, the file content has _not_ changed, the file is simply read and the node is not marked as changed. &lt;br&gt;  &lt;br&gt; - When you write a @read-only directive, the file content is added to the node immediately, i.e. as soon as you press Enter (no need to call a menu entry to import the content). &lt;br&gt;  &lt;br&gt; - If you want to refresh/update the content of the file, just edit the headline and press Enter. The file is reloaded, and if in the meantime it has changed, a &quot;change&quot; message is sent to the log window. &lt;br&gt;  &lt;br&gt; - The body text of a @read-only file cannot be modified in leo. &lt;br&gt;  &lt;br&gt; The syntax to access files in @read-only via ftp/http is the following:: &lt;br&gt;  &lt;br&gt;     @read-only http://www.ietf.org/rfc/rfc0791.txt &lt;br&gt;     @read-only ftp://ftp.someserver.org/filepath &lt;br&gt;  &lt;br&gt; If FTP authentication (username/password) is required, it can be specified as follows:: &lt;br&gt;  &lt;br&gt;     @read-only ftp://username:password@ftp.someserver.org/filepath &lt;br&gt;  &lt;br&gt; For more details, see the doc string for the class FTPurl. &lt;br&gt;  &lt;br&gt; Davide Salomoni &lt;br&gt;  &lt;br&gt; " id="1319" linkTypes="1" links="1072" title="read_only_nodes.py" />
<node body="Runs a program and interface Leos through its input/output/error streams. &lt;br&gt;  &lt;br&gt; Double clicking the icon box whose headlines are @run 'cmd args' will execute the command. There are several other features, including @arg and @input nodes. &lt;br&gt;  &lt;br&gt; The run_nodes.py plugin introduce two new nodes that transform leo into a terminal. It was mostly intended to run compilers and debuggers while having the possibility to send messages to the program. &lt;br&gt;  &lt;br&gt; Double clicking on the icon of an node whose headline is @run &lt;command&gt; &lt;args&gt; will launch &lt;command&gt; with the given arguments. It will also mark the node. # Terminates the argument list. @run # &lt;comment&gt; is also valid. &lt;br&gt;  &lt;br&gt; @in nodes are used to send input to the running process. Double clicking on &lt;br&gt; the icon of an @in &lt;message&gt; node will append a &quot;\n&quot; to &lt;message&gt; and write it to the program, no matter where the node is placed. If no @run node is active, nothing happens. &lt;br&gt;  &lt;br&gt; The body text of every child, in which the headlines do not begin with '@run' or '@in', will be appended to &lt;command&gt;, allowing you to add an unlimited number of arguments to &lt;command&gt;. &lt;br&gt;  &lt;br&gt; The output of the program is written in the log pane (Error output in red). When the program exit the node is set unmarked and the return value is displayed... When the enter key is pressed in the body pane of an active @run node the content of it body pane is written to the program and then emptied ready for another line of input. If the node have @run nodes in its descendants, they will be launched successively. (Unless one returned an exit code other than 0, then it will stop there) &lt;br&gt;  &lt;br&gt; By Alexis Gendron Paquette. Please send comments to the Leo forums. &lt;br&gt; " id="1320" linkTypes="1" links="1072" title="run_nodes.py" />
<node body="Launches (starts) a file given by a headline when double-clicking the icon. &lt;br&gt;  &lt;br&gt; This plugin ignores headlines starting with an '@'. Uses the @folder path if the headline is under an @folder headline. Otherwise the path is relative to the Leo file. &lt;br&gt; " id="1321" linkTypes="1" links="1072" title="startfile.py" />
<node body="By Kent Tenney &lt;br&gt;  &lt;br&gt; The timestamp plugin manages the following node attributes: &lt;br&gt;  &lt;br&gt; - str_ctime: creation time &lt;br&gt; - str_mtime: time node was last modified &lt;br&gt; - str_atime: time node contents were last viewed &lt;br&gt; " id="1322" linkTypes="1" links="1072" title="timestamp.py" />
<node body="Adds the Outline:XSLT menu containing XSLT-related commands. &lt;br&gt;  &lt;br&gt; This menu contains the following items: &lt;br&gt;  &lt;br&gt; - Set StyleSheet Node: &lt;br&gt;     - Selects the current node as the xsl stylesheet the plugin will use. &lt;br&gt;  &lt;br&gt; - Process Node with Stylesheet Node: &lt;br&gt;     - Processes the current node as an xml document, &lt;br&gt;       resolving section references and Leo directives. &lt;br&gt;     - Creates a sibling containing the results. &lt;br&gt;  &lt;br&gt; Requires 4Suite 1.0a3 or better, downloadable from http://4Suite.org. &lt;br&gt;  &lt;br&gt; " id="1323" linkTypes="1" links="1072" title="xsltWithNodes.py" />
<node body="The dyna_menu plugin is a remarkable body of work by 'e'. This plugin creates a dyna_menu menu from which you can execute commands. You may download the latest version at: http://rclick.netfirms.com/dyna_menu.py.html &lt;br&gt; " id="1324" linkTypes="1" links="1073" title="dyna_menu" />
<node body="Allows interaction with shell apps via screen. &lt;br&gt;  &lt;br&gt; Analysis environments like SQL, R, scipy, ipython, etc. can be used by pasting sections of text from an editor (Leo) and a shell window.  Results can be pasted back into the editor. &lt;br&gt;  &lt;br&gt; This plugin streamlines the process by communicating with ``screen``, the shell multiplexer &lt;br&gt;  &lt;br&gt; **Commands** &lt;br&gt;  &lt;br&gt; leoscreen-run-text &lt;br&gt;   Send the text selected in Leo's body text to the shell app. &lt;br&gt;   Selects the next line for your convenience. &lt;br&gt;  &lt;br&gt; leoscreen-get-line &lt;br&gt;   Insert a line of the last result from the shell into Leo's body text &lt;br&gt;   at the current insert point.  Lines are pulled one at a time starting &lt;br&gt;   from the end of the output.  Can be used repeatedly to get the &lt;br&gt;   output you want into Leo. &lt;br&gt;  &lt;br&gt; leoscreen-get-all &lt;br&gt;   Insert all of the last result from the shell into Leo's body text &lt;br&gt;   at the current insert point. &lt;br&gt;  &lt;br&gt; leoscreen-get-note &lt;br&gt;   Insert all of the last result from the shell into a new child node of &lt;br&gt;   the current node. &lt;br&gt;  &lt;br&gt; leoscreen-show-all &lt;br&gt;   Show the output from the last result from the shell in a temporary &lt;br&gt;   read only window. **Important**: The output is not stored. &lt;br&gt;  &lt;br&gt; leoscreen-show-note &lt;br&gt;   Insert all of the last result from the shell into a new child node of &lt;br&gt;   the current node and display that node a a stickynote (requires stickynote &lt;br&gt;   plugin). &lt;br&gt;  &lt;br&gt; leoscreen-next &lt;br&gt;   Switch screen session to next window. &lt;br&gt;  &lt;br&gt; leoscreen-prev &lt;br&gt;   Switch screen session to preceding window. &lt;br&gt;  &lt;br&gt; leoscreen-other &lt;br&gt;   Switch screen session to last window displayed. &lt;br&gt;  &lt;br&gt; leoscreen-get-prefix &lt;br&gt;   Interactively get prefix for inserting text into body (#, --, //, etc/) &lt;br&gt;   Can also set using:: &lt;br&gt;  &lt;br&gt;       c.leo_screen.get_line_prefix = '#' &lt;br&gt;  &lt;br&gt; leoscreen-more-prompt &lt;br&gt;   Skip one less line at the end of output when fetching output into Leo. &lt;br&gt;   Adjusts lines skipped to avoid pulling in the applications prompt line. &lt;br&gt;  &lt;br&gt; leoscreen-less-prompt &lt;br&gt;   Skip one more line at the end of output when fetching output into Leo &lt;br&gt;   Adjusts lines skipped to avoid pulling in the applications prompt line. &lt;br&gt;  &lt;br&gt; **Settings** &lt;br&gt;  &lt;br&gt; leoscreen_prefix &lt;br&gt;   Prepended to output pulled in to Leo. The substring SPACE in this &lt;br&gt;   setting will be replaced with a space character, to allow for trailing &lt;br&gt;   spaces. &lt;br&gt;  &lt;br&gt; leoscreen_time_fmt &lt;br&gt;   time.strftime format for note type output headings. &lt;br&gt;  &lt;br&gt; **Theory of operation** &lt;br&gt;  &lt;br&gt; leoscreen creates a instance at c.leo_screen which has some methods which might &lt;br&gt; be useful in ``@button`` and other Leo contexts. &lt;br&gt;  &lt;br&gt; **Example SQL setup** &lt;br&gt;  &lt;br&gt; In a Leo file full of interactive SQL analysis, I have:: &lt;br&gt;  &lt;br&gt;     @settings &lt;br&gt;         @string leoscreen_prefix = --SPACE &lt;br&gt;     @button rollback &lt;br&gt;         import time &lt;br&gt;         c.leo_screen.run_text('ROLLBACK;  -- %s\n' % time.asctime()) &lt;br&gt;     @button commit &lt;br&gt;         import time &lt;br&gt;         cmd = 'COMMIT;  -- %s' % time.asctime() &lt;br&gt;         c.leo_screen.run_text(cmd) &lt;br&gt;         c.leo_screen.insert_line(cmd) &lt;br&gt;  &lt;br&gt; which creates a button to rollback messed up queries, another to commit (requiring additional action to supply the newline as a safeguard) and sets the prefix to &quot;-- &quot; for text pulled back from the SQL session into Leo. &lt;br&gt;  &lt;br&gt; **Implementation note**: screen behaves differently if screen -X is executed with the same stdout as the target screen, vs. a different stdout. Although stdout is ignored, Popen() needs to ensure it's not just inherited. &lt;br&gt; " id="1325" linkTypes="1" links="1073" title="leoscreen.py" />
<node body="Creates script buttons and @button, @command, @plugin and @script nodes. &lt;br&gt;  &lt;br&gt; This plugin puts buttons in the icon area. Depending on settings the plugin will create the 'Run Script', the 'Script Button' and the 'Debug Script' buttons. &lt;br&gt;  &lt;br&gt; The 'Run Script' button is simply another way of doing the Execute Script command: it executes the selected text of the presently selected node, or the entire text if no text is selected. &lt;br&gt;  &lt;br&gt; The 'Script Button' button creates *another* button in the icon area every time you push it. The name of the button is the headline of the presently selected node. Hitting this *newly created* button executes the button's script. &lt;br&gt;  &lt;br&gt; For example, to run a script on any part of an outline do the following: &lt;br&gt;  &lt;br&gt; 1.  Select the node containing the script. &lt;br&gt; 2.  Press the scriptButton button.  This will create a new button. &lt;br&gt; 3.  Select the node on which you want to run the script. &lt;br&gt; 4.  Push the *new* button. &lt;br&gt;  &lt;br&gt; That's all. &lt;br&gt;  &lt;br&gt; For every @button node, this plugin creates two new minibuffer commands: x and delete-x-button, where x is the 'cleaned' name of the button. The 'x' command is equivalent to pushing the script button. &lt;br&gt;  &lt;br&gt; You can specify **global buttons** in leoSettings.leo or myLeoSettings.leo by putting @button nodes as children of an @buttons node in an @settings trees. Such buttons are included in all open .leo (in a slightly different color). Actually, you can specify global buttons in any .leo file, but @buttons nodes affect all later opened .leo files so usually you would define global buttons in leoSettings.leo or myLeoSettings.leo. &lt;br&gt;  &lt;br&gt; The cleaned name of an @button node is the headline text of the button with: &lt;br&gt;  &lt;br&gt; - Leading @button or @command removed, &lt;br&gt; - @key and all following text removed, &lt;br&gt; - @args and all following text removed, &lt;br&gt; - all non-alphanumeric characters converted to a single '-' characters. &lt;br&gt;  &lt;br&gt; Thus, cleaning headline text converts it to a valid minibuffer command name. &lt;br&gt;  &lt;br&gt; You can delete a script button by right-clicking on it, or by executing the delete-x-button command. &lt;br&gt;  &lt;br&gt; The 'Debug Script' button runs a script using an external debugger. &lt;br&gt;  &lt;br&gt; This plugin optionally scans for @button nodes, @command, @plugin nodes and &lt;br&gt; @script nodes whenever a .leo file is opened. &lt;br&gt;  &lt;br&gt; - @button nodes create script buttons. &lt;br&gt; - @command nodes create minibuffer commands. &lt;br&gt; - @plugin nodes cause plugins to be loaded. &lt;br&gt; - @script nodes cause a script to be executed when opening a .leo file. &lt;br&gt;  &lt;br&gt; Such nodes may be security risks. This plugin scans for such nodes only if the corresponding atButtonNodes, atPluginNodes, and atScriptNodes constants are set to True in this plugin. &lt;br&gt;  &lt;br&gt; You can specify the following options in leoSettings.leo.  See the node: &lt;br&gt; @settings--&gt;Plugins--&gt;scripting plugin.  Recommended defaults are shown:: &lt;br&gt;  &lt;br&gt;     @bool scripting-at-button-nodes = True &lt;br&gt;     True: adds a button for every @button node. &lt;br&gt;  &lt;br&gt;     @bool scripting-at-commands-nodes = True &lt;br&gt;     True: define a minibuffer command for every @command node. &lt;br&gt;  &lt;br&gt;     @bool scripting-at-plugin-nodes = False &lt;br&gt;     True: dynamically loads plugins in @plugins nodes when a window is created. &lt;br&gt;  &lt;br&gt;     @bool scripting-at-script-nodes = False &lt;br&gt;     True: dynamically executes script in @script nodes when a window is created. &lt;br&gt;     This is dangerous! &lt;br&gt;  &lt;br&gt;     @bool scripting-create-debug-button = False &lt;br&gt;     True: create Debug Script button. &lt;br&gt;  &lt;br&gt;     @bool scripting-create-run-script-button = False &lt;br&gt;     True: create Run Script button. &lt;br&gt;     Note: The plugin creates the press-run-script-button regardless of this setting. &lt;br&gt;  &lt;br&gt;     @bool scripting-create-script-button-button = True &lt;br&gt;     True: create Script Button button in icon area. &lt;br&gt;     Note: The plugin creates the press-script-button-button &lt;br&gt;           regardless of this setting. &lt;br&gt;  &lt;br&gt;     @int scripting-max-button-size = 18 &lt;br&gt;     The maximum length of button names: longer names are truncated. &lt;br&gt;  &lt;br&gt; You can bind key shortcuts to @button and @command nodes as follows. &lt;br&gt;  &lt;br&gt; @button name @key=shortcut &lt;br&gt;  &lt;br&gt;     Binds the shortcut to the script in the script button. The button's name is &lt;br&gt;     'name', but you can see the full headline in the status line when you move the &lt;br&gt;     mouse over the button. &lt;br&gt;  &lt;br&gt; @command name @key=shortcut &lt;br&gt;  &lt;br&gt;     Creates a new minibuffer command and binds shortcut to it. As with @buffer &lt;br&gt;     nodes, the name of the command is the cleaned name of the headline. &lt;br&gt;  &lt;br&gt; This plugin is based on ideas from e's dynabutton plugin, quite possibly the most brilliant idea in Leo's history. &lt;br&gt;  &lt;br&gt; You can run the script with sys.argv initialized to string values using @args. For example:: &lt;br&gt;  &lt;br&gt;     @button test-args @args = a,b,c &lt;br&gt;  &lt;br&gt; will set sys.argv to [u'a',u'b',u'c'] &lt;br&gt; " id="1326" linkTypes="1" links="1073" title="mod_scripting.py" />
<node body="Sends output from the Execute Script command to the end of the body pane. &lt;br&gt;  &lt;br&gt; " id="1327" linkTypes="1" links="1073" title="script_io_to_body.py" />
<node body="Remote control for Leo. &lt;br&gt;  &lt;br&gt; Example client:: &lt;br&gt;  &lt;br&gt;     from leo.external import lproto &lt;br&gt;     import os &lt;br&gt;  &lt;br&gt;  &lt;br&gt;     addr = open(os.path.expanduser('~/.leo/leoserv_sockname')).read() &lt;br&gt;     print(&quot;will connect to&quot;,addr) &lt;br&gt;     pc  = lproto.LProtoClient(addr) &lt;br&gt;     pc.send(&quot;&quot;&quot; &lt;br&gt;         g.es(&quot;hello world from remote&quot;)  &lt;br&gt;         c = g.app.commanders()[0] &lt;br&gt;     &quot;&quot;&quot;) &lt;br&gt;  &lt;br&gt;     # note how c persists between calls &lt;br&gt;     pc.send(&quot;&quot;&quot;c.k.simulateCommand('stickynote')&quot;&quot;&quot;) &lt;br&gt;  &lt;br&gt; " id="1328" linkTypes="1" links="1074" title="leoremote.py" />
<node body="A minimal http plugin for Leo, based on AsyncHttpServer.py. &lt;br&gt;  &lt;br&gt; Use this plugin is as follows: &lt;br&gt;  &lt;br&gt; 1. Start Leo with the plugin enabled. You will see a purple message that says something like:: &lt;br&gt;  &lt;br&gt;     &quot;http serving enabled on port 8080, version 0.91&quot; &lt;br&gt;  &lt;br&gt; 2. Start a web browser, and enter the following url: http://localhost:8080/ &lt;br&gt;  &lt;br&gt; You will see a a &quot;top&quot; level page containing one link for every open .leo file. Start clicking :-) &lt;br&gt;  &lt;br&gt; You can use the browser's refresh button to update the top-level view in the browser after you have opened or closed files. &lt;br&gt;  &lt;br&gt; To enable this plugin put this into your file:: &lt;br&gt;  &lt;br&gt;     @settings &lt;br&gt;     @bool http_active = True &lt;br&gt;     @int  port = 8080 &lt;br&gt;     @string rst_http_attributename = 'rst_http_attribute' &lt;br&gt;  &lt;br&gt; **Note**: the browser_encoding constant (defined in the top node of this file) must match the character encoding used in the browser. If it does not, non-ascii characters will look strange. &lt;br&gt;  &lt;br&gt; " id="1329" linkTypes="1" links="1074" title="mod_http.py" />
<node body="Creates stand-alone slideshows containing screenshots. &lt;br&gt;  &lt;br&gt; This plugin defines five commands. The **apropos-slides** command prints this message to Leo's log pane. The **slide-show-info** command prints the settings in effect. &lt;br&gt;  &lt;br&gt; The **make-slide** and **make-slide-show** commands, collectively called **slide commands**, create collections of slides from **@slideshow** trees containing **@slide** nodes. &lt;br&gt;  &lt;br&gt; Slides may link to screenshots. The slide commands can generate screenshots from **@screenshot-tree** nodes, but this feature has proven to be clumsy and inflexible. It is usually more convenient to use screenshots taken with a program such as Wink. The **meld-slides** command creates references to externally-generated screenshots within @slide nodes. &lt;br&gt;  &lt;br&gt; \@slide nodes may contain **@url nodes**. These @url nodes serve two purposes. First, they allow you to see various files (slides, initial screenshots, working files and final screenshots). Second, these @url nodes guide the meld script and the four commands defined by this plugin (see below). By inserting or deleting these @url nodes you (or your scripts) can customize how the commands (and meld) work. In effect, the @url nodes become per-slide settings. &lt;br&gt;  &lt;br&gt; **Prerequisites** &lt;br&gt;  &lt;br&gt; Inkscape (Required) &lt;br&gt;   An SVG editor: http://www.inkscape.org/ &lt;br&gt;   Allows the user to edit screenshots. &lt;br&gt;   Required to create final output (PNG) files. &lt;br&gt;  &lt;br&gt; PIL (Optional but highly recommended) &lt;br&gt;   The Python Imaging Library, &lt;br&gt;   http://www.pythonware.com/products/pil/ &lt;br&gt;  &lt;br&gt; Wink (Optional) &lt;br&gt;   A program that creates slideshows and slides. &lt;br&gt;   http://www.debugmode.com/wink/ &lt;br&gt;  &lt;br&gt; **Summary** &lt;br&gt;  &lt;br&gt; @slideshow &lt;slideshow-name&gt; &lt;br&gt;   Creates the folder: &lt;br&gt;   &lt;sphinx_path&gt;/slides/&lt;slideshow-name&gt; &lt;br&gt;  &lt;br&gt; @slide &lt;ignored text&gt; &lt;br&gt;   Creates slide-&lt;slide-number&gt;.html &lt;br&gt;   (in the sphinx _build directory). &lt;br&gt;   **Note**: the plugin skips any @slide nodes &lt;br&gt;   with empty body text. &lt;br&gt;  &lt;br&gt; @screenshot &lt;br&gt;   Specifies the contents of the screenshot. &lt;br&gt;  &lt;br&gt; **Options** are child nodes of @slideshow or @slide nodes that control the make-slide and make-slide-show commands. See the Options section below. &lt;br&gt;  &lt;br&gt; The make-slide and make-slide-show commands create the following @url nodes as children of each @slide node: &lt;br&gt;  &lt;br&gt; @url built slide &lt;br&gt;   Contains the absolute path to the final slide in &lt;br&gt;   the _build/html subfolder of the slideshow &lt;br&gt;   folder. If present, this @url node completely &lt;br&gt;   disables rebuilding the slide. &lt;br&gt;  &lt;br&gt; @url screenshot &lt;br&gt;   Contains the absolute path to the original &lt;br&gt;   screenshot file. If present, this @url node &lt;br&gt;   inhibits taking the screenshot. &lt;br&gt;  &lt;br&gt; @url working file &lt;br&gt;   Contains the absolute path to the working file. &lt;br&gt;   If present, this @url node disables taking the &lt;br&gt;   screenshot, creating the working file. The final &lt;br&gt;   output file will be regenerated if the working &lt;br&gt;   file is newer than the final output file. &lt;br&gt;  &lt;br&gt; @url final output file &lt;br&gt;   Contains the absolute path to the final output &lt;br&gt;   file. &lt;br&gt;  &lt;br&gt; Thus, to completely recreate an @slide node, you must delete any of the following nodes that appear as its children:: &lt;br&gt;  &lt;br&gt;     @url screenshot &lt;br&gt;     @url working file &lt;br&gt;     @url built slide &lt;br&gt;  &lt;br&gt; **Making slides** &lt;br&gt;  &lt;br&gt; For each slide, the make-slide and make-slide-show commands do the following: &lt;br&gt;  &lt;br&gt; 1. Create a slide. &lt;br&gt;  &lt;br&gt;   If the @slide node contains an @screenshot tree, &lt;br&gt;   the plugin appends an ``.. image::`` directive &lt;br&gt;   referring to the screenshot to the body text of &lt;br&gt;   the @slide node. The plugin also creates a child &lt;br&gt;   @image node referring to the screenshot. &lt;br&gt;  &lt;br&gt; 2. (Optional) Create a screenshot. &lt;br&gt;  &lt;br&gt;   The plugin creates a screenshot for an @slide &lt;br&gt;   node only if the @slide node contains an &lt;br&gt;   @screenshot node as a direct child. &lt;br&gt;  &lt;br&gt;   **Important**: this step has largely been &lt;br&gt;   superseded by the ``@button meld`` script in &lt;br&gt;   LeoDocs.leo. &lt;br&gt;  &lt;br&gt;   Taking a screenshot involves the following steps: &lt;br&gt;  &lt;br&gt;   A. Create the **target outline**: screenshot-setup.leo. &lt;br&gt;  &lt;br&gt;     The target outline contains consists of all &lt;br&gt;     the children (and their descendants) of the &lt;br&gt;     @screenshot node. &lt;br&gt;  &lt;br&gt;   B. Create the **screenshot**, a bitmap (PNG) file. &lt;br&gt;  &lt;br&gt;     The slide commands take a screen shot of the &lt;br&gt;     target outline. The @pause option opens the &lt;br&gt;     target outline but does *not* take the &lt;br&gt;     screenshot. The user must take the screenshot &lt;br&gt;     manually. For more details, see the the &lt;br&gt;     options section below. &lt;br&gt;  &lt;br&gt;   C. Convert the screenshot file to a **work file**. &lt;br&gt;  &lt;br&gt;     The work file is an SVG (Scalable Vector &lt;br&gt;     Graphics) file: http://www.w3.org/Graphics/SVG/. &lt;br&gt;  &lt;br&gt;   D. (Optional) Edit the work file. &lt;br&gt;  &lt;br&gt;     If the @slide node has a child @edit node, the &lt;br&gt;     plugin opens Inkscape so that the user can &lt;br&gt;     edit the work file. &lt;br&gt;  &lt;br&gt;   E. Render the **final output file**. &lt;br&gt;  &lt;br&gt;     The plugin calls Inkscape non-interactively to &lt;br&gt;     render the final output file (a PNG image) &lt;br&gt;     from the work file. If the Python Imaging &lt;br&gt;     Library (PIL) is available, this step will use &lt;br&gt;     PIL to improve the quality of the final output &lt;br&gt;     file. &lt;br&gt;  &lt;br&gt; 3. Build the slide using Sphinx. &lt;br&gt;  &lt;br&gt;   After making all files, the plugins runs Sphinx &lt;br&gt;   by running 'make html' in the slideshow folder. &lt;br&gt;   This command creates the final .html files in the &lt;br&gt;   _build/html subfolder of the slideshow folder. &lt;br&gt;  &lt;br&gt; 4. Create url nodes. &lt;br&gt;  &lt;br&gt;   Depending on options, and already-existing @url &lt;br&gt;   nodes, the make-slide and make-slide-show &lt;br&gt;   commands may create one or more of the following &lt;br&gt;   @url nodes:: &lt;br&gt;  &lt;br&gt;     @url built slide &lt;br&gt;     @url screenshot &lt;br&gt;     @url working file  &lt;br&gt;     @url final output file &lt;br&gt;  &lt;br&gt; **Options and settings** &lt;br&gt;  &lt;br&gt; You specify options in the headlines of nodes. **Global options** appear as direct children of @slideshow nodes and apply to all @slide nodes unless overridden by a local option. **Local options** appear as direct children of an @slide node and apply to only to that @slide node. &lt;br&gt;  &lt;br&gt; **Global options nodes** &lt;br&gt;  &lt;br&gt; The following nodes may appear *either* as a direct child of the @slideshow node or as the direct child of an @slide node. &lt;br&gt;  &lt;br&gt; @sphinx_path = &lt;path&gt; &lt;br&gt;   This directory contains the slides directory, &lt;br&gt;   and the following files: 'conf.py', &lt;br&gt;   'Leo4-80-border.jpg', 'Makefile' and 'make.bat'. &lt;br&gt;  &lt;br&gt; @screenshot_height = &lt;int&gt; &lt;br&gt;   The height in pixels of screenshots. &lt;br&gt;  &lt;br&gt; @screenshot_width = &lt;int&gt; &lt;br&gt;   The height in pixels of screenshots. &lt;br&gt;  &lt;br&gt; @template_fn = &lt;path&gt; &lt;br&gt;   The absolute path to inkscape-template.svg &lt;br&gt;  &lt;br&gt; @title = &lt;any text&gt; &lt;br&gt;   The title to use for one slide or the entire &lt;br&gt;   slideshow. &lt;br&gt;  &lt;br&gt; @title_pattern = &lt;pattern&gt; &lt;br&gt;   The pattern used to generate patterns for one &lt;br&gt;   slide or the entire slideshow. The title is &lt;br&gt;   computed as follows:: &lt;br&gt;  &lt;br&gt;     d = { &lt;br&gt;         'slideshow_name':slideshow_name, &lt;br&gt;         'slide_name':    slide_name, &lt;br&gt;         'slide_number':  sc.slide_number, &lt;br&gt;     } &lt;br&gt;     title = (pattern % (d)).title() &lt;br&gt;  &lt;br&gt;   If neither an @title or @title_pattern option &lt;br&gt;   node applies, the title is the headline of the &lt;br&gt;   @slide node. If this is empty, the default &lt;br&gt;   pattern is:: &lt;br&gt;  &lt;br&gt;     '%(slideshow_name)s:%(slide_number)s' &lt;br&gt;  &lt;br&gt; \@verbose = True/False &lt;br&gt;   True (or true or 1):  generate informational message. &lt;br&gt;   False (or false or 0): suppress informational messages. &lt;br&gt;  &lt;br&gt; \@wink_path = &lt;path&gt; &lt;br&gt;   This path contains screenshots created by wink. &lt;br&gt;   This is used only by the meld-slides command. &lt;br&gt;  &lt;br&gt; **Local options nodes** &lt;br&gt;  &lt;br&gt; The following nodes are valid only as the direct child of an @slide node. &lt;br&gt;  &lt;br&gt; @callout &lt;any text&gt; &lt;br&gt;   Generates a text callout in the working .svg file. &lt;br&gt;   An @slide node may have several @callout children. &lt;br&gt;  &lt;br&gt; @edit = True/False &lt;br&gt;   If True (or true or 1) the plugin enters &lt;br&gt;   Inkscape interactively after taking a &lt;br&gt;   screenshot. &lt;br&gt;  &lt;br&gt; @markers = &lt;list of integers&gt; &lt;br&gt;   Generates 'numbered balls' in the working .svg file. &lt;br&gt;  &lt;br&gt; @pause = True/False &lt;br&gt;   If True (or true or 1) the user must take the &lt;br&gt;   screenshot manually. Otherwise, the plugin takes &lt;br&gt;   the screenshot automatically. &lt;br&gt;  &lt;br&gt;   If the slide node contains an @pause node as one &lt;br&gt;   of its directive children, the slide commands &lt;br&gt;   open the target node, but do *not* take a screen &lt;br&gt;   shot. &lt;br&gt;  &lt;br&gt;   The user may adjust the screen as desired, for &lt;br&gt;   example by selecting menus or showing dialogs. &lt;br&gt;   The *user* must then take the screen shot &lt;br&gt;   manually. **Important**: the screenshot need not &lt;br&gt;   be of Leo--it could be a screenshot of anything &lt;br&gt;   on the screen. &lt;br&gt;  &lt;br&gt;   As soon as the user closes the target &lt;br&gt;   outline, the slide commands look for the screen &lt;br&gt;   shot on the clipboard. If found, the slide &lt;br&gt;   commands save the screenshot to the screenshot &lt;br&gt;   file. &lt;br&gt;  &lt;br&gt; @screenshot &lt;br&gt;   The root of a tree that becomes the entire &lt;br&gt;   contents of screenshot. No screenshot is taken &lt;br&gt;   if this node does not exist. &lt;br&gt;  &lt;br&gt; @select &lt;headline&gt; &lt;br&gt;   Causes the given headline in the @screenshot &lt;br&gt;   outline to be selected before taking the screenshot. &lt;br&gt;  &lt;br&gt; **Settings** &lt;br&gt;  &lt;br&gt; @string screenshot-bin = &lt;path to inkscape.exe&gt; &lt;br&gt;   The full path to the Inkscape program.    &lt;br&gt;  &lt;br&gt; **File names** &lt;br&gt;  &lt;br&gt; Suppose the @slide node is the n'th @slide node in the @slideshow tree whose sanitized name is 'name'. The following files will be created in (relative to) the slideshow directory:: &lt;br&gt;  &lt;br&gt;     slide-n.html.txt:   the slide's rST source. &lt;br&gt;     screenshot-n.png:   the original screenshot. &lt;br&gt;     screenshot-n.svg:   the working file. &lt;br&gt;     slide-n.png:        the final output file. &lt;br&gt;     _build/html/slide-n.html: the final slide. &lt;br&gt; " id="1330" linkTypes="1" links="1075" title="screenshots.py" />
<node body="Support slideshows in Leo outlines. &lt;br&gt;  &lt;br&gt; This plugin defines four new commands: &lt;br&gt;  &lt;br&gt; - next-slide-show:  move to the start of the next slide show, &lt;br&gt;   or the first slide show if no slide show has been seen yet. &lt;br&gt; - prev-slide-show:  move to the start of the previous slide show, &lt;br&gt;   or the first slide show if no slide show has been seen yet. &lt;br&gt; - next-slide: move to the next slide of a present slide show. &lt;br&gt; - prev-slide: move to the previous slide of the present slide show. &lt;br&gt;  &lt;br&gt; Slides shows consist of a root @slideshow node with descendant @slide nodes. @slide nodes may be organized via non-@slide nodes that do not appear in the slideshow. &lt;br&gt;  &lt;br&gt; All these commands ignore @ignore trees. &lt;br&gt;  &lt;br&gt; " id="1331" linkTypes="1" links="1075" title="slideshow.py" />
<node body="Manages BibTeX files with Leo. &lt;br&gt;  &lt;br&gt; Create a bibliographic database by putting '@bibtex filename' in a headline. Entries are added as nodes, with '@entrytype key' as the headline, and the contents of the entry in body text. The plugin will automatically insert a template for the entry in the body pane when a new entry is created (hooked to pressing enter when typing the headline text). The templates are defined in dictionary 'templates' in the \&lt;\&lt;globals\&gt;\&gt; section, by default containing all required fields for every entry. &lt;br&gt;  &lt;br&gt; The file is written by double-clicking the node. Thus the following outline:: &lt;br&gt;  &lt;br&gt;     -@bibtex biblio.bib &lt;br&gt;      +@book key &lt;br&gt;       author = {A. Uthor}, &lt;br&gt;       year = 1999 &lt;br&gt;  &lt;br&gt; will be written in the file 'biblio.bib' as:: &lt;br&gt;  &lt;br&gt;     @book{key, &lt;br&gt;     author = {A. Uthor}, &lt;br&gt;     year= 1999} &lt;br&gt;  &lt;br&gt; Strings are defined in @string nodes and they can contain multiple entries. All @string nodes are written at the start of the file. Thus the following outline:: &lt;br&gt;  &lt;br&gt;     -@bibtext biblio.bib &lt;br&gt;      +@string &lt;br&gt;       j1 = {Journal1} &lt;br&gt;      +@article AUj1 &lt;br&gt;       author = {A. Uthor}, &lt;br&gt;       journal = j1 &lt;br&gt;      +@string &lt;br&gt;       j2 = {Journal2} &lt;br&gt;       j3 = {Journal3} &lt;br&gt;  &lt;br&gt; Will be written as:: &lt;br&gt;  &lt;br&gt;     @string{j1 = {Journal1}} &lt;br&gt;     @string{j2 = {Journal2}} &lt;br&gt;     @string{j3 = {Journal3}} &lt;br&gt;  &lt;br&gt;     @article{AUj1, &lt;br&gt;     author = {A. Uthor}, &lt;br&gt;     journal = j1} &lt;br&gt;  &lt;br&gt; No error checking is made on the syntax. The entries can be organized under nodes --- if the headline doesn't start with '@', the headline and body text are ignored, but the child nodes are parsed as usual. &lt;br&gt;  &lt;br&gt; BibTeX files can be imported by creating an empty node with '@bibtex filename' in the headline. Double-clicking it will read the file 'filename' and parse it into a @bibtex tree. No syntax checking is made, 'filename' is expected to be a valid BibTeX file. &lt;br&gt; " id="1332" linkTypes="1" links="1076" title="bibtex.py" />
<node body="Sends code to the doctest module and reports the result. &lt;br&gt;  &lt;br&gt; When the Dtest plugin is enabled, the ``dtest`` command is active. &lt;br&gt; Typing::  &lt;br&gt;  &lt;br&gt;     Alt-X dtest &lt;br&gt;  &lt;br&gt; will run doctest on a file consisting of the current node and it's children. If text is selected only the selection is tested. &lt;br&gt;  &lt;br&gt; From Wikipedia:: &lt;br&gt;  &lt;br&gt;     'Doctest' is a module included in the Python programming language's  &lt;br&gt;     standard library that allows for easy generation of tests based on  &lt;br&gt;     output from the standard Python interpreter. &lt;br&gt;  &lt;br&gt; http://tinyurl.com/cqh53 - Python.org doctest page     &lt;br&gt;  &lt;br&gt; http://tinyurl.com/pxhlq - Jim Fulton's presentation:: &lt;br&gt;  &lt;br&gt;     Literate Testing: &lt;br&gt;     Automated Testing with doctest &lt;br&gt; " id="1333" linkTypes="1" links="1076" title="dtest.py" />
<node body="Converts a leo outline to an html web page. &lt;br&gt;  &lt;br&gt; This plugin takes an outline stored in Leo and converts it to html which is then either saved in a file or shown in a browser. It is based on the original leoToHTML 1.0 plugin by Dan Rahmel which had bullet list code by Mike Crowe. &lt;br&gt;  &lt;br&gt; The outline can be represented as a bullet list, a numbered list or using html &lt;h?&gt; type headings. Optionally, the body text may be included in the output. &lt;br&gt;  &lt;br&gt; If desired, only the current node will be included in the output rather than the entire outline. &lt;br&gt;  &lt;br&gt; An xhtml header may be included in the output, in which case the code will be valid XHTML 1.0 Strict. &lt;br&gt;  &lt;br&gt; The plugin is fully scriptable as all its functionality is available through a Leo_to_HTML object which can be imported and used in scripts. &lt;br&gt;  &lt;br&gt; **Menu items and @settings** &lt;br&gt;  &lt;br&gt; If this plugin loads properly, the following menu items should appear in your File &gt; Export... menu in Leo:: &lt;br&gt;  &lt;br&gt;     Save Outline as HTML  (equivalent to export-html) &lt;br&gt;     Save Node as HTML     (equivalent to export-html-node) &lt;br&gt;     Show Outline as HTML  (equivalent to show-html) &lt;br&gt;     Show Node as HTML     (equivalent to show-html-node) &lt;br&gt;  &lt;br&gt; *Unless* the following appears in an @setting tree:: &lt;br&gt;  &lt;br&gt;     @bool leo_to_html_no_menus = True &lt;br&gt;  &lt;br&gt; in which case the menus will **not** be created. This is so that the user can use @menu and @item to decide which commands will appear in the menu and where. &lt;br&gt;  &lt;br&gt; **Commands** &lt;br&gt;  &lt;br&gt; Several commands will also be made available &lt;br&gt;  &lt;br&gt; export-html &lt;br&gt;   will export to a file according to current settings. &lt;br&gt; export-html-* &lt;br&gt;   will export to a file using bullet type '*' which can be &lt;br&gt;   **number**, **bullet** or **head**. &lt;br&gt;  &lt;br&gt; The following commands will start a browser showing the html. &lt;br&gt;  &lt;br&gt; show-html &lt;br&gt;   will show the outline according to current settings. &lt;br&gt;  &lt;br&gt; show-html-* &lt;br&gt;   will show the outline using bullet type '*' which can be &lt;br&gt;   **number**, **bullet** or **head**. &lt;br&gt;  &lt;br&gt; The following commands are the same as above except only the current node is converted:: &lt;br&gt;  &lt;br&gt;     export-html-node &lt;br&gt;     export-html-node-* &lt;br&gt;     show-html-node &lt;br&gt;     show-html-node-* &lt;br&gt;  &lt;br&gt; **Properties** &lt;br&gt;  &lt;br&gt; There are several settings that can appear in the leo_to_html.ini properties file in leo's plugins folder or be set via the Plugins &gt; leo_to_html &gt; Properties... menu. These are: &lt;br&gt;  &lt;br&gt; exportpath: &lt;br&gt;     The path to the folder where you want to store the generated html file. &lt;br&gt;     Default: c:\\ &lt;br&gt;  &lt;br&gt; flagjustheadlines: &lt;br&gt;     Default: 'Yes' to include only headlines in the output. &lt;br&gt;  &lt;br&gt; flagignorefiles: &lt;br&gt;     Default: 'Yes' to ignore @file nodes. &lt;br&gt;  &lt;br&gt; use_xhtml: &lt;br&gt;     Yes to include xhtml doctype declarations and make the file valid XHTML 1.0 Strict. &lt;br&gt;     Otherwise only a simple &lt;html&gt; tag is used although the output will be xhtml &lt;br&gt;     compliant otherwise. Default: Yes &lt;br&gt;  &lt;br&gt; bullet_type: &lt;br&gt;     If this is 'bullet' then the output will be in the form of a bulleted list. &lt;br&gt;     If this is 'number' then the output will be in the form of a numbered list. &lt;br&gt;     If this is 'heading' then the output will use &lt;h?&gt; style headers. &lt;br&gt;  &lt;br&gt;     Anything else will result in &lt;h?&gt; type tags being used where '?' will be a &lt;br&gt;     digit starting at 1 and increasing up to a maximum of six depending on depth &lt;br&gt;     of nesting. Default: number &lt;br&gt;  &lt;br&gt; browser_command: &lt;br&gt;     Set this to the command needed to launch a browser on your system or leave it blank &lt;br&gt;     to use your systems default browser. &lt;br&gt;  &lt;br&gt;     If this is an empty string or the browser can not be launched using this command then &lt;br&gt;     python's `webbrowser` module will be tried. Using a bad command here will slow down the &lt;br&gt;     launch of the default browser, better to leave it blank. &lt;br&gt;     Default: empty string &lt;br&gt;  &lt;br&gt; **Configuration** &lt;br&gt;  &lt;br&gt; At present, the file leo/plugins/leo_to_html.ini contains configuration settings. In particular, the default export path, &quot;c:\&quot; must be changed for \*nix systems. &lt;br&gt; " id="1334" linkTypes="1" links="1076" title="leo_to_html.py" />
<node body="Outputs a Leo outline as a numbered list to an RTF file. The RTF file can be loaded into Microsoft Word and formatted as a proper outline. &lt;br&gt;  &lt;br&gt; If this plug-in loads properly, you should have an &quot;Outline to Microsoft RTF&quot; option added to your File &gt; Export... menu in Leo. &lt;br&gt;  &lt;br&gt; Settings such as outputting just the headlines (vs. headlines &amp; body text) and whether to include or ignore the contents of @file nodes are stored in the rtf_export.ini file in your Leo\plugins folder. &lt;br&gt;  &lt;br&gt; The default export path is also stored in the INI file. By default, it's set to c:\ so you may need to modify it depending on your system. &lt;br&gt; " id="1335" linkTypes="1" links="1076" title="leo_to_rtf.py" />
<node body="Supports Uniform Node Locators (UNL's) for linking to nodes in any Leo file. &lt;br&gt;  &lt;br&gt; UNL's specify nodes within any Leo file. You can use them to create cross-Leo-file links! UNL &lt;br&gt;  &lt;br&gt; This plugin consists of two parts: &lt;br&gt;  &lt;br&gt; 1) Selecting a node shows the UNL in the status line at the bottom of the Leo window. You can copy from the status line and paste it into headlines, emails, whatever. &lt;br&gt;  &lt;br&gt; 2) Double-clicking @url nodes containing UNL's select the node specified in the UNL. If the UNL species in another Leo file, the other file will be opened. &lt;br&gt;  &lt;br&gt; Format of UNL's: &lt;br&gt;  &lt;br&gt; UNL's referring to nodes within the present outline have the form:: &lt;br&gt;  &lt;br&gt;     headline1--&gt;headline2--&gt;...--&gt;headlineN &lt;br&gt;  &lt;br&gt; headline1 is the headline of a top-level node, and each successive headline is the headline of a child node. &lt;br&gt;  &lt;br&gt; UNL's of the form:: &lt;br&gt;  &lt;br&gt;     file:&lt;path&gt;#headline1--&gt;...--&gt;headlineN &lt;br&gt;  &lt;br&gt; refer to a node specified in &lt;path&gt; For example, double clicking the following headline will take you to Chapter 8 of Leo's Users Guide:: &lt;br&gt;  &lt;br&gt;     @url file:c:/prog/leoCvs/leo/doc/leoDocs.leo#Users Guide--&gt;Chapter 8: Customizing Leo &lt;br&gt;  &lt;br&gt; For example, suppose you want to email someone with comments about a Leo file. Create a comments.leo file containing @url UNL nodes. That is, headlines are @url followed by a UNL. The body text contains your comments about the nodes in the _other_ Leo file! Send the comments.leo to your friend, who can use the comments.leo file to quickly navigate to the various nodes you are talking about. As another example, you can copy UNL's into emails. The recipient can navigate to the nodes 'by hand' by following the arrows in the UNL. &lt;br&gt;  &lt;br&gt; **Notes**: &lt;br&gt;  &lt;br&gt; - At present, UNL's refer to nodes by their position in the outline. Moving a node will break the link. &lt;br&gt;  &lt;br&gt; - Don't refer to nodes that contain UNL's in the headline. Instead, refer to the parent or child of such nodes. &lt;br&gt;  &lt;br&gt; - You don't have to replace spaces in URL's or UNL's by '%20'. &lt;br&gt; " id="1336" linkTypes="1" links="1077" title="UNL.py" />
<node body="Creates hoist buttons. &lt;br&gt;  &lt;br&gt; This plugin puts two buttons in the icon area: a button called 'Save Hoist' and a button called 'Dehoist'. The 'Save Hoist' button hoists the presently selected node and creates a button which can later rehoist the same node. The 'Dehoist' button performs one level of dehoisting &lt;br&gt;  &lt;br&gt; Requires at least version 0.19 of mod_scripting. &lt;br&gt;  &lt;br&gt; " id="1337" linkTypes="1" links="1077" title="chapter_hoist.py" />
<node body="Colorizes URLs everywhere in node's body on node selection or saving. Double click on any URL launches it in default browser. &lt;br&gt;  &lt;br&gt; URL regex:  (http|https|file|ftp)://[^\s'&quot;]+[\w=/] &lt;br&gt;  &lt;br&gt; Related plugin:  contextmenu.py &lt;br&gt; " id="1338" linkTypes="1" links="1077" title="detect_urls.py" />
<node body="Lets the user to associate text with a specific node. &lt;br&gt;  &lt;br&gt; Summon it by pressing button-2 or button-3 on an icon Box in the outline. This will create an attribute editor where the user can add, remove and edit attributes. Since attributes use the underlying tnode, clones will share the attributes of one another. &lt;br&gt;  &lt;br&gt; " id="1339" linkTypes="1" links="1077" title="EditAttributes.py" />
<node body="Adds buttons so Leo can interact with command line environments. &lt;br&gt;  &lt;br&gt; :20100226: see also leoscreen.py for a simpler approach. &lt;br&gt;  &lt;br&gt; Currently implements `bash` shell and `psql` (postresql SQL db shell). &lt;br&gt;  &lt;br&gt; Single-line commands can be entered in the headline with a blank body, multi-line commands can be entered in the body with a descriptive title in the headline.  Press the `bash` or `psql` button to send the command to the appropriate interpreter. &lt;br&gt;  &lt;br&gt; The output from the command is **always** stored in a new node added as the first child of the command node.  For multi-line commands this new node is selected.  For single-line command this new node is not shown, instead the body text of the command node is updated to reflect the most recent output.  Comment delimiter magic is used to allow single-line and multi-line commands to maintain their single-line and multi-line flavors. &lt;br&gt;  &lt;br&gt; Both the new child nodes and the updated body text of single-line commands are timestamped. &lt;br&gt;  &lt;br&gt; For the `bash` button the execution directory is either the directory containing the `.leo` file, or any other path as specified by ancestor `@path` nodes. &lt;br&gt;  &lt;br&gt; Currently the `psql` button just connects to the default database.  &quot;;&quot; is required at the end of SQL statements. &lt;br&gt;  &lt;br&gt; Requires `pexpect` module. &lt;br&gt; " id="1340" linkTypes="1" links="1077" title="interact.py" />
<node body="Maximizes all new windows. &lt;br&gt;  &lt;br&gt; " id="1341" linkTypes="1" links="1077" title="maximizeNewWindows.py" />
<node body="Sets a hard coded frame size. &lt;br&gt;  &lt;br&gt; Prevents Leo from setting custom frame size (e.g. from an external .leo document) &lt;br&gt;  &lt;br&gt; " id="1342" linkTypes="1" links="1077" title="mod_framesize.py" />
<node body="Creates a Plugins menu and adds all actives plugins to it. &lt;br&gt;  &lt;br&gt; Selecting these menu items will bring up a short **About Plugin** dialog with the details of the plugin. In some circumstances a submenu will be created instead and an 'About' menu entry will be created in this. &lt;br&gt;  &lt;br&gt; **INI files and the Properties Dialog** &lt;br&gt;  &lt;br&gt; If a file exists in the plugins directory with the same file name as the plugin but with a .ini extension instead of .py, then a **Properties** item will be created in a submenu. Selecting this item will pop up a Properties Dialog which will allow the contents of this file to be edited. &lt;br&gt;  &lt;br&gt; The .ini file should be formated for use by the python ConfigParser class. &lt;br&gt;  &lt;br&gt; **Special Methods** &lt;br&gt;  &lt;br&gt; Certain methods defined at the top level are considered special. &lt;br&gt;  &lt;br&gt; cmd_XZY &lt;br&gt;     If a method is defined at the module level with a name of the form &lt;br&gt;     **cmd_XZY** then a menu item **XZY** will be created which will invoke &lt;br&gt;     **cmd_XZY** when it is selected. These menus will appear in a sub menu. &lt;br&gt;  &lt;br&gt; applyConfiguration &lt;br&gt;  &lt;br&gt; topLevelMenu &lt;br&gt;     This method, if it exists, will be called when the user clicks on the plugin &lt;br&gt;     name in the plugins menu (or the **About** item in its submenu), but only if &lt;br&gt;     the plugin was loaded properly and registered with g.plugin_signon. &lt;br&gt;  &lt;br&gt; **Special Variable Names** &lt;br&gt;  &lt;br&gt; Some names defined at the top level have special significance. &lt;br&gt;  &lt;br&gt; __plugin_name__ &lt;br&gt;     This will be used to define the name of the plugin and will be used &lt;br&gt;     as a label for its menu entry. &lt;br&gt;  &lt;br&gt; __plugin_priority__ &lt;br&gt;     Plugins can also attempt to select the order they will appear in the menu by &lt;br&gt;     defining a __plugin_priority__. The menu will be created with the highest &lt;br&gt;     priority items first. This behavior is not guaranteed since other plugins &lt;br&gt;     can define any priority. This priority does not affect the order of calling &lt;br&gt;     handlers. &lt;br&gt;     To change the order select a number outside the range 0-200 since this range &lt;br&gt;     is used internally for sorting alphabetically. Properties and INI files. &lt;br&gt; " id="1343" linkTypes="1" links="1077" title="plugins_menu.py" />
<node body="Sends all output to the log pane. &lt;br&gt;  &lt;br&gt; " id="1344" linkTypes="1" links="1077" title="redirect_to_log.py" />
<node body="Creates a Scripts menu for LeoPy.leo. &lt;br&gt;  &lt;br&gt; " id="1345" linkTypes="1" links="1077" title="scripts_menu.py" />
<node body="Replaces the gui file dialogs on Linux with external calls to the zenity gtk dialog package. &lt;br&gt;  &lt;br&gt; This plugin is more a proof of concept demo than a useful tool.  The dialogs presented do not take filters and starting folders can not be specified. &lt;br&gt;  &lt;br&gt; Despite this, some Linux users might prefer it to the gui dialogs. &lt;br&gt; " id="1346" linkTypes="1" links="1077" title="zenity_file_dialogs.py" />
<node body="This plugin registers a controller object to c.theTagController, which &lt;br&gt; provides the following API:: &lt;br&gt;  &lt;br&gt;     tc = c.theTagController &lt;br&gt;     tc.get_all_tags() &lt;br&gt;         # return a list of all tags used in the current &lt;br&gt;         # outline, automatically updated to be consistent &lt;br&gt;     tc.get_tagged_nodes('foo') &lt;br&gt;         # return a list of positions tagged 'foo' &lt;br&gt;     tc.get_tags(p) &lt;br&gt;         # return a list of tags applied to the node at &lt;br&gt;         # position p; returns [] if node has no tags &lt;br&gt;     tc.add_tag(p, 'bar') # add the tag 'bar' to the node at position p &lt;br&gt;     tc.remove_tag(p, 'baz') &lt;br&gt;         # remove the tag 'baz' from p if it is in the tag list &lt;br&gt;  &lt;br&gt; Internally, tags are stored in `p.v.unknownAttributes['__node_tags']` as &lt;br&gt; a set. &lt;br&gt; " id="1347" linkTypes="1" links="1087" title="API" />
<node body="The &quot;Tags&quot; tab in the Log pane is the UI for this plugin.  The bar at &lt;br&gt; the top is a search bar, editable to allow complex search queries.  It &lt;br&gt; is pre-populated with all existing tags in the outline, and remembers &lt;br&gt; your custom searches within the given session.  It also acts double duty &lt;br&gt; as an input box for the add (+) button, which adds the contents of the &lt;br&gt; search bar as a tag to the currently selected node. &lt;br&gt;  &lt;br&gt; The list box in the middle is a list of headlines of nodes which contain &lt;br&gt; the tag(s) defined by the current search string.  These are clickable, &lt;br&gt; and doing so will center the focus in the outline pane on the selected node. &lt;br&gt;  &lt;br&gt; Below the list box is a dynamic display of tags on the currently &lt;br&gt; selected node.  Left-clicking on any of these will populate the search &lt;br&gt; bar with that tag, allowing you to explore similarly tagged nodes. &lt;br&gt; Right-clicking on a tag will remove it from the currently selected node. &lt;br&gt;  &lt;br&gt; The status line at the bottom is purely informational. &lt;br&gt;  &lt;br&gt; The tag browser has set-algebra querying possible.  Users may search for &lt;br&gt; strings like 'foo&amp;bar', to get nodes with both tags foo and bar, or &lt;br&gt; 'foo|bar' to get nodes with either or both.  Set difference (-) and &lt;br&gt; symmetric set difference (^) are supported as well.  These queries are &lt;br&gt; left-associative, meaning they are read from left to right, with no &lt;br&gt; other precedence.  Parentheses are not supported. See below for more &lt;br&gt; details. &lt;br&gt;  &lt;br&gt; " id="1348" linkTypes="1" links="1087" title="UI" />
<node body="The API is unlimited in tagging abilities.  If you do not wish to use &lt;br&gt; the UI, then the API may be used to tag nodes with any arbitrary &lt;br&gt; strings.  The UI, however, due to searching capabilities, may *not* be &lt;br&gt; used to tag (or search for) nodes with tags containing the special &lt;br&gt; search characters, `&amp;|-^`.  The UI also cannot search for tags of &lt;br&gt; zero-length, and it automatically removes surrounding whitespace &lt;br&gt; (calling .strip()). &lt;br&gt; " id="1349" linkTypes="1" links="1087" title="Tag Limitation" />
<node body="I like to use reStructuredText (reST) for all of my note-taking, idea &lt;br&gt; development, project and task management and automation of desktop &lt;br&gt; activities (e.g. initiating a backup). You could say it is the control &lt;br&gt; center of my daily activities, including calculating and showing dashboards &lt;br&gt; of where I am and where I'm going. &lt;br&gt;  &lt;br&gt; This means I need a tool which seamlessly shows me the full-fidelity &lt;br&gt; browser-rendered version of what I am writing and be able to print my notes &lt;br&gt; for meetings, cut and paste nicely formatted output to my office e-mails &lt;br&gt; and documents, as well as show some of the material as a slideshow. &lt;br&gt;  &lt;br&gt; The existing *viewrendered* plugin couldn't seem to do what I needed &lt;br&gt; (especially math) and I was almost ready to abandon Leo again. This time I &lt;br&gt; bit the bullet and created a more capable renderer in viewrendered2 (VR2). &lt;br&gt; Initially I made a plugin that rendered, on demand, to my normal web &lt;br&gt; browser. This worked well, but I really thought live rendering like &lt;br&gt; &quot;viewrendered&quot; would be better, and for that I needed close control over &lt;br&gt; scroll positions etc. that I couldn't get with an external browser. So the &lt;br&gt; plugin became much more complex as I merged it with the existing &lt;br&gt; viewrendered plugin, but was ultimately more powerful and useful to me. &lt;br&gt;  &lt;br&gt; " id="1350" linkTypes="1" links="1099" title="Why a better viewrendered plugin?" />
<node body="* Show a &quot;full&quot; html representation of any reST node or tree, without an &lt;br&gt;   @rst root node, including more features than the existing viewrendered &lt;br&gt;   plugin:: &lt;br&gt;  &lt;br&gt;       proper html layout &lt;br&gt;       math (mathjax, etc.) &lt;br&gt;       clickable URLs &lt;br&gt;       clickable hyperlinks within the page (e.g. TOC) &lt;br&gt;       good quality zoom &lt;br&gt;       cut and paste html with ctl-C &lt;br&gt;       s5 slideshows &lt;br&gt;       javascript &lt;br&gt;       svg images &lt;br&gt;       configurable css &lt;br&gt;  &lt;br&gt; * Allow showing of node tree rather than just the current node. This can &lt;br&gt;   give a better overview perspective of the tree contents. &lt;br&gt;  &lt;br&gt; * Be able to lock the rendering on the root node of a tree, to view the &lt;br&gt;   effect editing a sub-node within the larger html document. &lt;br&gt;  &lt;br&gt; * Provide proper rendering of any combination of node types in a tree, so long as &lt;br&gt;   they have been properly designated by @language directives (i.e. reST, text, &lt;br&gt;   code, css, ...). &lt;br&gt;  &lt;br&gt; * Allow viewing (and printing) of an entire source file from an @file type &lt;br&gt;   root node. &lt;br&gt;  &lt;br&gt; * Be able to *export* any of these renderings to a full web-browser to take advantage &lt;br&gt;   of the large rendering window (especially for slideshows, as well as printing, saving output. &lt;br&gt;    &lt;br&gt; * Be able to integrate automatically executed code nodes intermingled with &lt;br&gt;   reST nodes to provide an automatic calculation-based &quot;Notebook&quot; or &quot;Report&quot; &lt;br&gt;   type output. &lt;br&gt;  &lt;br&gt; * Don't increase the dependencies of Leo. &lt;br&gt; " id="1351" linkTypes="1" links="1099" title="Objectives" />
<node body="VR2 is implemented mostly as an ~600 line expansion of the update_rst &lt;br&gt; method in the viewrendered.py plugin. The text-oriented class used for &lt;br&gt; rendering in VR1 has been replaced by the QWebView class which provides the &lt;br&gt; full rendering functionality of a real web-browser. To make this flexible, &lt;br&gt; a toolbar has been attached to the top with a few controls. &lt;br&gt;  &lt;br&gt; Because I wanted to retain compatibility with VR1, I created the &lt;br&gt; viewrendered2.py plugin, but retained all the class naming which occurred &lt;br&gt; within VR1. This means that it remains compatible with the existing &lt;br&gt; mechanisms (like free_layout) of showing and creating panes for VR1. I &lt;br&gt; tried this with an expectation that it would fail, but it appears to work &lt;br&gt; without any unintended side-effects. &lt;br&gt;  &lt;br&gt; Tooltips have been added where Qt allows, with the philosophy that a user &lt;br&gt; shouldn't need a manual to use this pane. &lt;br&gt;  &lt;br&gt; VR2 has been used a lot under Windows 7 and a little under Ubuntu 13.10. &lt;br&gt;  &lt;br&gt; " id="1352" linkTypes="1" links="1099" title="Implementation" />
<node body="I use VR2 every few minutes every working day. However, VR2 is likely to &lt;br&gt; still have a lot of rough edges and, in particular, bugs that show up with &lt;br&gt; different work flows or css folder layouts etc. In fact, VR2 is still a &lt;br&gt; work in progress and therefore still being fiddled with, so bugs creep in &lt;br&gt; regularly. &lt;br&gt;  &lt;br&gt; But overall, my perception of its deficiencies are: &lt;br&gt;  &lt;br&gt; * Does not handle reST headings within the node bodies well (sometimes very &lt;br&gt;   slow render, blocking Leo). &lt;br&gt;  &lt;br&gt; * VR2 attempts to reconcile reST headings that originate from explicit &lt;br&gt;   headings within the nodes against reST headings that are &lt;br&gt;   automatically generated by the node hierarchy. In many cases, this &lt;br&gt;   is impossible, resulting in many errors which drastically slows down &lt;br&gt;   rendering. - Recommend not using headings within the nodes &lt;br&gt;   themselves, leaving the node hierarchy to do this automatically. &lt;br&gt;  &lt;br&gt; * If the node triggers one of the special viewrendered node header types &lt;br&gt;   (@md, @image, @movie, @html) VR2 simply defaults to the old handlers for &lt;br&gt;   those types. This means it jumps back to whatever pane type VR1 uses, so &lt;br&gt;   the features of VR2 disappear. I suspect that VR2 could incorporate these &lt;br&gt;   types into the new version and retain these new features. I should look &lt;br&gt;   at that. &lt;br&gt;      &lt;br&gt; * Doesn't integrate with rst3 plugin, especially honouring @others etc. &lt;br&gt;   There are some conflicts in objectives, so this may never be fully &lt;br&gt;   resolved. It would probably make sense for rst3 settings to get used for &lt;br&gt;   VR2 as well, along with additional VR2 specific settings. Currently, VR2 &lt;br&gt;   has its own @settings-style settings. The rst3 code is not used. &lt;br&gt;    &lt;br&gt; * For slideshow purposes, a patch to docutils s5_writer is required to be &lt;br&gt;   able to handle an arbitrary hierarchy of nodes (forces all headings to &lt;br&gt;   start a new slide). Otherwise, only the 2nd level nodes (from the root) &lt;br&gt;   force a new slide. &lt;br&gt;    &lt;br&gt; * The integration of VR2 code into the existing viewrendered plugin code is &lt;br&gt;   rudimentary. I took the shortcut of not trying to understand this code &lt;br&gt;   well and confining my integration to the rst rendering only. Better &lt;br&gt;   integration would be a good future step. &lt;br&gt;  &lt;br&gt; With the plugin being able to execute javascript etc. there may be some &lt;br&gt; form of security issue, but I can't see it myself (given that Leo can &lt;br&gt; execute arbitrary python code anyway). &lt;br&gt; " id="1353" linkTypes="1" links="1099" title="Issues / Limitations" />
<node body="- Expand the export button if pandoc is installed, adding optional &lt;br&gt;   output formats such as docx, odt, plus additional slideshow formats. &lt;br&gt;  &lt;br&gt; - Use new reST functionality to replace other media viewrendered methods &lt;br&gt;   for images, svg, movies, etc. * Integrate better with rst3? &lt;br&gt; " id="1354" linkTypes="1" links="1099" title="Future" />
<node body="When importing files into @auto trees, Leo performs several checks to ensure that writing the imported file will produce exactly the same file. These checks can produces **errors** or **warnings**. Errors indicate a potentially serious problem. Leo inserts an @ignore directive in the @auto tree if any error is found. This prevents the @auto tree from modifying the external file. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Strict language; Reference &lt;br&gt;  &lt;br&gt; Before importing a file, Leo **regularizes** the leading whitespace of all lines of the original source file. That is, Leo converts blanks to tabs or tabs to blanks depending on the value of the @tabwidth directive in effect for the @auto node. Leo also checks that the indentation of any non-blank line is a multiple of the indentation specified by the @tabwidth directive. **Strict languages** are languages such as Python for which leading whitespace must be preserved exactly as it appears in the original source file. Problems during regularizing whitespace generate errors for strict languages and warnings for non-strict languages. &lt;br&gt;  &lt;br&gt; After importing a file, Leo verifies that writing the @auto node would create the same file as the original file. Such file comparison mismatches generate errors unless the problem involves only leading whitespace for non-strict languages. Whenever a mismatch occurs the first non-matching line is printed. &lt;br&gt;  &lt;br&gt; File comparison mismatches can arise for several reasons: &lt;br&gt;  &lt;br&gt; 1. Bugs in the import parsers. Please report any such bugs immediately. &lt;br&gt;  &lt;br&gt; 2. Underindented lines in classes, methods or function. &lt;br&gt;  &lt;br&gt; .. index:: &lt;br&gt;     pair: Underindented line; Reference &lt;br&gt;  &lt;br&gt; An **underindented line** is a line of body text that is indented less then the starting line of the class, method or function in which it appears. Leo outlines can not represent such lines exactly: every line in an external file will have at least the indentation of any unindented line of the corresponding node in the outline. Leo will issue a warning (not an error) for underindented Python comment lines. Such lines can not change the meaning of Python programs. &lt;br&gt; " id="1355" linkTypes="1" links="1159" title="\@auto sanity checks" />
<node body="July 1 &lt;br&gt;     Started writing in my diary. &lt;br&gt; July 2 &lt;br&gt;     Wrote another sentence in my diary. &lt;br&gt; July 3 &lt;br&gt;     Keeping my diary very regularly. &lt;br&gt; July 5 &lt;br&gt;     Oops...Yesterday I forgot to write in my diary. &lt;br&gt; " id="1356" linkTypes="1" links="1219" title="Jul 2009" />
<node body="" id="1357" linkTypes="1" links="1219" title="Aug 2009" />
<node body="" id="1358" linkTypes="1" links="1219" title="Sep 2009" />
<node body="" id="1359" linkTypes="1" links="1219" title="Oct 2009" />
<node body="" id="1360" linkTypes="1" links="1219" title="Nov 2009" />
<node body="" id="1361" linkTypes="1" links="1219" title="Dec 2009" />
<node body="def fix (self,fn): &lt;br&gt;     return os.path.normcase(fn).replace('\\','/') &lt;br&gt;  &lt;br&gt; def finalize (self,fn): &lt;br&gt;     return self.fix(g.os_path_finalize_join(self.slideshow_dir,fn)) &lt;br&gt; " id="1362" linkTypes="1" links="1221" title="finalize &amp; fix" />
<node body="def has_at_no_screenshot_node (self,p): &lt;br&gt;  &lt;br&gt;     for p in p.children(): &lt;br&gt;         if self.match(p,'@no-screenshot'): &lt;br&gt;             return True &lt;br&gt;     else: &lt;br&gt;         return False &lt;br&gt; " id="1363" linkTypes="1" links="1221" title="has_at_no_screenshot_node" />
<node body="def match (self,p,pattern): &lt;br&gt;  &lt;br&gt;     '''Return True if p.h matches the pattern.''' &lt;br&gt;  &lt;br&gt;     return g.match_word(p.h,0,pattern) &lt;br&gt; " id="1364" linkTypes="1" links="1221" title="match" />
<node body="def adjust_slideshow(self): &lt;br&gt;  &lt;br&gt;     '''Adjust all @slide nodes in the slideshow.''' &lt;br&gt;  &lt;br&gt;     # Traverse the tree as in the screenshot plugin. &lt;br&gt;     # That is, ignore @ignore trees and nested @slide nodes. &lt;br&gt;     # This ensures that the slide number, n, is correct. &lt;br&gt;     p = self.slideshow_node &lt;br&gt;     after = p.nodeAfterTree() &lt;br&gt;     p = p.firstChild() &lt;br&gt;     n = 1 &lt;br&gt;     while p and p != after: &lt;br&gt;         if self.match(p,'@slide'): &lt;br&gt;             self.adjust_slide_node(p,n) &lt;br&gt;             n += 1 &lt;br&gt;             p.moveToNodeAfterTree() &lt;br&gt;         elif self.match(p,'@ignore'): &lt;br&gt;             p.moveToNodeAfterTree() &lt;br&gt;         else: &lt;br&gt;             p.moveToThreadNext() &lt;br&gt; " id="1365" linkTypes="3" links="1446" title="adjust_slideshow &amp; helper" />
<node body="def check (self,aList): &lt;br&gt;  &lt;br&gt;     ''' &lt;br&gt;     Check that len(aList) matches the number of @slide nodes in the &lt;br&gt;     slideshow. Don't count @slide nodes containing an @no-screenshot node. &lt;br&gt;     ''' &lt;br&gt;  &lt;br&gt;     p = self.slideshow_node &lt;br&gt;     n1 = len(aList) &lt;br&gt;     n2,n3 = self.count_slide_nodes() &lt;br&gt;  &lt;br&gt;     if not self.check_dir(self.wink_dir): &lt;br&gt;         return False &lt;br&gt;     if not self.check_dir(self.slideshow_dir): &lt;br&gt;         return False &lt;br&gt;     if not self.match(p,'@slideshow'): &lt;br&gt;         return g.error('not a @slideshow node: %s',p.h) &lt;br&gt;  &lt;br&gt;     if n1 != (n2-n3): &lt;br&gt;         return g.error( &lt;br&gt;             '%s wink slides\n' &lt;br&gt;             '%s @slide nodes\n' &lt;br&gt;             '%s @no_screenshot nodes' % ( &lt;br&gt;                 n1,n2,n3)) &lt;br&gt;  &lt;br&gt;     return True &lt;br&gt; " id="1366" linkTypes="3 3" links="1447 1448" title="check &amp; helpers" />
<node body="def copy_files (self,aList): &lt;br&gt;  &lt;br&gt;     '''Copy files from the wink_dir to slideshow_dir, &lt;br&gt;     numbering the destination files to reflect &quot;holes&quot; &lt;br&gt;     created by @no-screenshot nodes.''' &lt;br&gt;  &lt;br&gt;     # Traverse the tree as in the screenshot plugin. &lt;br&gt;     # That is, ignore @ignore trees and nested @slide nodes. &lt;br&gt;     # This ensures that the slide number, n, is correct. &lt;br&gt;     p = self.slideshow_node &lt;br&gt;     after = p.nodeAfterTree() &lt;br&gt;     p = p.firstChild() &lt;br&gt;     wink_n = 0 # Wink screenshot numbers start at 0. &lt;br&gt;     slide_n = 1 # Slide numbers start at 1. &lt;br&gt;     while p and p != after: &lt;br&gt;         if self.match(p,'@slide'): &lt;br&gt;             if not self.has_at_no_screenshot_node(p): &lt;br&gt;                 self.copy_file(aList,slide_n,wink_n) &lt;br&gt;                 wink_n += 1 &lt;br&gt;             slide_n += 1 &lt;br&gt;             p.moveToNodeAfterTree() &lt;br&gt;         elif self.match(p,'@ignore'): &lt;br&gt;             p.moveToNodeAfterTree() &lt;br&gt;         else: &lt;br&gt;             p.moveToThreadNext() &lt;br&gt; " id="1367" linkTypes="3" links="1449" title="copy_files &amp; helper" />
<node body="def get_wink_screenshots (self): &lt;br&gt;  &lt;br&gt;     '''Return the properly sorted list of wink screenshots.''' &lt;br&gt;  &lt;br&gt;     trace = False &lt;br&gt;  &lt;br&gt;     aList = glob.glob(self.wink_dir + '/*.png') &lt;br&gt;  &lt;br&gt;     def key(s): &lt;br&gt;         path,ext = g.os_path_splitext(s) &lt;br&gt;         junk,n = g.os_path_split(path) &lt;br&gt;         n = n.strip() &lt;br&gt;         if n.isdigit(): &lt;br&gt;             return int(n) &lt;br&gt;         else: &lt;br&gt;             g.error('bad wink screenshot: %s' % (s)) &lt;br&gt;             raise KeyError &lt;br&gt;  &lt;br&gt;     aList.sort(key=key) # Essential. &lt;br&gt;  &lt;br&gt;     if trace: &lt;br&gt;         for z in aList: &lt;br&gt;             print(z) &lt;br&gt;  &lt;br&gt;     return aList &lt;br&gt; " id="1368" linkTypes="1" links="1222" title="get_wink_screenshots" />
<node body="" id="1369" linkTypes="3" links="1450" title="@screenshot" />
<node body="" id="1370" linkTypes="1" links="1225" title="@pause" />
<node body="c:/leo.repo/trunk/leo/doc/html/slides/leos-nsis-installer/screenshot-002.png &lt;br&gt; " id="1371" linkTypes="1" links="1225" title="@url screenshot" />
<node body="c:/leo.repo/trunk/leo/doc/html/slides/leos-nsis-installer/screenshot-002.svg &lt;br&gt; " id="1372" linkTypes="1" links="1225" title="@url working file" />
<node body="c:/leo.repo/trunk/leo/doc/html/slides/leos-nsis-installer/slide-002.png &lt;br&gt; " id="1373" linkTypes="1" links="1225" title="@url final output file" />
<node body="c:\leo.repo\trunk\leo\doc\html\slides\leos-nsis-installer\_build\html\slide-002.html &lt;br&gt; " id="1374" linkTypes="1" links="1225" title="@url built slide" />
<node body="" id="1375" linkTypes="1" links="1229" title="@no-screenshot" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-003.html &lt;br&gt; " id="1376" linkTypes="1" links="1232" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-005.html &lt;br&gt; " id="1377" linkTypes="1" links="1234" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-006.html &lt;br&gt; " id="1378" linkTypes="1" links="1235" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-007.html &lt;br&gt; " id="1379" linkTypes="1" links="1236" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-008.html &lt;br&gt; " id="1380" linkTypes="1" links="1237" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-009.html &lt;br&gt; " id="1381" linkTypes="1" links="1238" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\whetting-your-appetite\_build\html\slide-010.html &lt;br&gt; " id="1382" linkTypes="1" links="1239" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\what-is-leo\_build\html\slide-001.html &lt;br&gt; " id="1383" linkTypes="1" links="1241" title="@url built slide" />
<node body="" id="1384" linkTypes="3 3" links="1451 1452" title="@screenshot" />
<node body="" id="1385" linkTypes="1" links="1242" title="@select To Do List" />
<node body="" id="1386" linkTypes="1" links="1242" title="@edit" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-002.png &lt;br&gt; " id="1387" linkTypes="1" links="1242" title="@url screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-002.svg &lt;br&gt; " id="1388" linkTypes="1" links="1242" title="@url working file" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/slide-002.png &lt;br&gt; " id="1389" linkTypes="1" links="1242" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\what-is-leo\_build\html\slide-002.html &lt;br&gt; " id="1390" linkTypes="1" links="1242" title="@url built slide" />
<node body="" id="1391" linkTypes="3 3" links="1453 1454" title="@screenshot" />
<node body="" id="1392" linkTypes="1" links="1243" title="@select 2009" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-003.png &lt;br&gt; " id="1393" linkTypes="1" links="1243" title="@url screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-003.svg &lt;br&gt; " id="1394" linkTypes="1" links="1243" title="@url working file" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/slide-003.png &lt;br&gt; " id="1395" linkTypes="1" links="1243" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\what-is-leo\_build\html\slide-003.html &lt;br&gt; " id="1396" linkTypes="1" links="1243" title="@url built slide" />
<node body="" id="1397" linkTypes="3 3" links="1455 1456" title="@screenshot" />
<node body="" id="1398" linkTypes="1" links="1244" title="@select 2009" />
<node body="" id="1399" linkTypes="1" links="1244" title="@edit" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-004.png &lt;br&gt; " id="1400" linkTypes="1" links="1244" title="@url screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-004.svg &lt;br&gt; " id="1401" linkTypes="1" links="1244" title="@url working file" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/slide-004.png &lt;br&gt; " id="1402" linkTypes="1" links="1244" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\what-is-leo\_build\html\slide-004.html &lt;br&gt; " id="1403" linkTypes="1" links="1244" title="@url built slide" />
<node body="" id="1404" linkTypes="3 3" links="1457 1458" title="@screenshot" />
<node body="" id="1405" linkTypes="1" links="1245" title="@select 2009" />
<node body="" id="1406" linkTypes="1" links="1245" title="@edit" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-005.png &lt;br&gt; " id="1407" linkTypes="1" links="1245" title="@url screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-005.svg &lt;br&gt; " id="1408" linkTypes="1" links="1245" title="@url working file" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/slide-005.png &lt;br&gt; " id="1409" linkTypes="1" links="1245" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\what-is-leo\_build\html\slide-005.html &lt;br&gt; " id="1410" linkTypes="1" links="1245" title="@url built slide" />
<node body="" id="1411" linkTypes="3 3" links="1459 1460" title="@screenshot" />
<node body="" id="1412" linkTypes="1" links="1246" title="@edit" />
<node body="" id="1413" linkTypes="1" links="1246" title="@select Urgent" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-006.png &lt;br&gt; " id="1414" linkTypes="1" links="1246" title="@url screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-006.svg &lt;br&gt; " id="1415" linkTypes="1" links="1246" title="@url working file" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/slide-006.png &lt;br&gt; " id="1416" linkTypes="1" links="1246" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\what-is-leo\_build\html\slide-006.html &lt;br&gt; " id="1417" linkTypes="1" links="1246" title="@url built slide" />
<node body="" id="1418" linkTypes="3 3" links="1461 1462" title="@screenshot" />
<node body="" id="1419" linkTypes="1" links="1247" title="@select Urgent" />
<node body="" id="1420" linkTypes="1" links="1247" title="@pause" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-007.png &lt;br&gt; " id="1421" linkTypes="1" links="1247" title="@url screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-007.svg &lt;br&gt; " id="1422" linkTypes="1" links="1247" title="@url working file" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/slide-007.png &lt;br&gt; " id="1423" linkTypes="1" links="1247" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\what-is-leo\_build\html\slide-007.html &lt;br&gt; " id="1424" linkTypes="1" links="1247" title="@url built slide" />
<node body="" id="1425" linkTypes="3 3" links="1463 1464" title="@screenshot" />
<node body="" id="1426" linkTypes="1" links="1248" title="@select Urgent" />
<node body="" id="1427" linkTypes="1" links="1248" title="@pause" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-008.png &lt;br&gt; " id="1428" linkTypes="1" links="1248" title="@url screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-008.svg &lt;br&gt; " id="1429" linkTypes="1" links="1248" title="@url working file" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/slide-008.png &lt;br&gt; " id="1430" linkTypes="1" links="1248" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\what-is-leo\_build\html\slide-008.html &lt;br&gt; " id="1431" linkTypes="1" links="1248" title="@url built slide" />
<node body="" id="1432" linkTypes="3 3" links="1465 1466" title="@screenshot" />
<node body="" id="1433" linkTypes="1" links="1249" title="@select Urgent" />
<node body="" id="1434" linkTypes="1" links="1249" title="@pause" />
<node body="" id="1435" linkTypes="1" links="1249" title="@edit" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-009.png &lt;br&gt; " id="1436" linkTypes="1" links="1249" title="@url screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-009.svg &lt;br&gt; " id="1437" linkTypes="1" links="1249" title="@url working file" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/slide-009.png &lt;br&gt; " id="1438" linkTypes="1" links="1249" title="@url final output file" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\what-is-leo\_build\html\slide-009.html &lt;br&gt; " id="1439" linkTypes="1" links="1249" title="@url built slide" />
<node body="c:\leo.repo\leo-editor\leo\doc\html\slides\what-is-leo\_build\html\slide-010.html &lt;br&gt; " id="1440" linkTypes="1" links="1250" title="@url built slide" />
<node body="" id="1441" linkTypes="3 3" links="1467 1468" title="@screenshot" />
<node body="" id="1442" linkTypes="1" links="1251" title="@pause" />
<node body="" id="1443" linkTypes="1" links="1251" title="@select Diary" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-011.png &lt;br&gt; " id="1444" linkTypes="1" links="1251" title="@url screenshot" />
<node body="c:/leo.repo/leo-editor/leo/doc/html/slides/what-is-leo/screenshot-011.svg &lt;br&gt; " id="1445" linkTypes="1" links="1251" title="@url working file" />
<node body="def adjust_slide_node (self,p,slide_number): &lt;br&gt;  &lt;br&gt;     '''Adjust p, an @slide node.''' &lt;br&gt;  &lt;br&gt;     trace = True &lt;br&gt;  &lt;br&gt;     # Delete the first &quot;@url built slide&quot; node. &lt;br&gt;     self.delete_at_url_built_slide_node(p) &lt;br&gt;  &lt;br&gt;     # Do nothing more if there is an @no-screenshot node. &lt;br&gt;     if self.has_at_no_screenshot_node(p): &lt;br&gt;         return &lt;br&gt;  &lt;br&gt;     # Add or update the &quot;@url final output file&quot; node. &lt;br&gt;     p2 = self.add_at_url_final_output_file(p,slide_number) &lt;br&gt;  &lt;br&gt;     # Add the .. image:: directive. &lt;br&gt;     self.add_image_directive(p,slide_number) &lt;br&gt; " id="1446" linkTypes="3 3 3" links="1469 1470 1471" title="adjust_slide_node &amp; helpers" />
<node body="def check_dir (self,theDir): &lt;br&gt;  &lt;br&gt;     if not g.os_path_exists(theDir): &lt;br&gt;         return g.error('not found: %s' % (theDir)) &lt;br&gt;  &lt;br&gt;     if not g.os_path_isdir(theDir): &lt;br&gt;         return g.error('not a directory: %s' % (theDir)) &lt;br&gt;  &lt;br&gt;     return True &lt;br&gt; " id="1447" linkTypes="1" links="1366" title="check_dir" />
<node body="def count_slide_nodes (self): &lt;br&gt;  &lt;br&gt;     '''Return n1,n2 &lt;br&gt;  &lt;br&gt;     n1 is the total number of @slide nodes in the @slideshow tree. &lt;br&gt;     n2 is number of @slide nodes containing an @no-slideshow child. &lt;br&gt;     ''' &lt;br&gt;  &lt;br&gt;     p = self.slideshow_node &lt;br&gt;     after = p.nodeAfterTree() &lt;br&gt;     p = p.firstChild() &lt;br&gt;     n1,n2 = 0,0 &lt;br&gt;     while p and p != after: &lt;br&gt;         if self.match(p,'@slide'): &lt;br&gt;             n1 += 1 &lt;br&gt;             if self.has_at_no_screenshot_node(p): &lt;br&gt;                 n2 += 1 &lt;br&gt;             p.moveToNodeAfterTree() &lt;br&gt;         elif self.match(p,'@ignore'): &lt;br&gt;             p.moveToNodeAfterTree() &lt;br&gt;         else: &lt;br&gt;             p.moveToThreadNext() &lt;br&gt;  &lt;br&gt;     g.trace(n1,n2) &lt;br&gt;     return n1,n2 &lt;br&gt; " id="1448" linkTypes="1" links="1366" title="count_slide_nodes" />
<node body="def copy_file (self,aList,slide_n,wink_n): &lt;br&gt;  &lt;br&gt;     trace = True &lt;br&gt;  &lt;br&gt;     if wink_n &gt;= len(aList): &lt;br&gt;         return g.trace('can not happen: ' &lt;br&gt;             'len(aList): %s, n: %s' % ( &lt;br&gt;                 len(aList),wink_n)) &lt;br&gt;  &lt;br&gt;     fn_src = aList[wink_n] &lt;br&gt;     fn_dst = 'slide-%03d.png' % (slide_n) &lt;br&gt;  &lt;br&gt;     if trace: &lt;br&gt;         g.trace('%7s -&gt; %s' % (g.shortFileName(fn_src),fn_dst)) &lt;br&gt;  &lt;br&gt;     shutil.copyfile(fn_src,fn_dst) &lt;br&gt; " id="1449" linkTypes="1" links="1367" title="copy_file" />
<node body="" id="1450" linkTypes="1" links="1369" title="Take screenshot of the compile .nsi dialog in a Windows folder" />
<node body="" id="1451" linkTypes="3 3 3 3" links="1472 1473 1474 1475" title="To Do List" />
<node body="" id="1452" linkTypes="3 3" links="1476 1477" title="Diary" />
<node body="My to-do list. &lt;br&gt; " id="1453" linkTypes="3 3 3 3" links="1478 1479 1480 1481" title="To Do List" />
<node body="" id="1454" linkTypes="3 3" links="1482 1483" title="Diary" />
<node body="@nocolor-node &lt;br&gt;  &lt;br&gt; My to-do list. &lt;br&gt; " id="1455" linkTypes="3 3 3 3" links="1484 1485 1486 1487" title="To Do List" />
<node body="@nocolor-node &lt;br&gt;  &lt;br&gt; " id="1456" linkTypes="3 3" links="1488 1489" title="Diary" />
<node body="My to-do list. &lt;br&gt; " id="1457" linkTypes="3 3 3 3" links="1490 1491 1492 1493" title="To Do List" />
<node body="" id="1458" linkTypes="3 3" links="1494 1495" title="Diary" />
<node body="@nocolor &lt;br&gt;  &lt;br&gt; My to-do list. &lt;br&gt; " id="1459" linkTypes="3 3 3 3" links="1496 1497 1498 1499" title="To Do List" />
<node body="@nocolor &lt;br&gt; " id="1460" linkTypes="3 3" links="1500 1501" title="Diary" />
<node body="@nocolor &lt;br&gt;  &lt;br&gt; My to-do list. &lt;br&gt; " id="1461" linkTypes="3 3 3 3" links="1502 1503 1504 1505" title="To Do List" />
<node body="@nocolor &lt;br&gt; " id="1462" linkTypes="3 3" links="1506 1507" title="Diary" />
<node body="@nocolor &lt;br&gt;  &lt;br&gt; My to-do list. &lt;br&gt; " id="1463" linkTypes="3 3 3 3" links="1508 1509 1510 1511" title="To Do List" />
<node body="@nocolor &lt;br&gt; " id="1464" linkTypes="3 3" links="1512 1513" title="Diary" />
<node body="@nocolor &lt;br&gt;  &lt;br&gt; My to-do list. &lt;br&gt; " id="1465" linkTypes="3 3 3 3" links="1514 1515 1516 1517" title="To Do List" />
<node body="@nocolor &lt;br&gt; " id="1466" linkTypes="3 3" links="1518 1519" title="Diary" />
<node body="@nocolor &lt;br&gt;  &lt;br&gt; My to-do list. &lt;br&gt; " id="1467" linkTypes="3 3 3 3" links="1520 1521 1522 1523" title="To Do List" />
<node body="@nocolor &lt;br&gt;  &lt;br&gt; This is my diary. &lt;br&gt; " id="1468" linkTypes="3 3" links="1524 1525" title="Diary" />
<node body="def add_at_url_final_output_file (self,p,slide_number): &lt;br&gt;  &lt;br&gt;     '''Create or update the &quot;@url final output file&quot; node.''' &lt;br&gt;  &lt;br&gt;     trace = True &lt;br&gt;     tag ='@url final output file' &lt;br&gt;  &lt;br&gt;     for child in p.children(): &lt;br&gt;         if self.match(child,tag): &lt;br&gt;             p2 = child ; break &lt;br&gt;     else: &lt;br&gt;         if trace: g.es('add %s' % tag) &lt;br&gt;         p2 = p.insertAsLastChild() &lt;br&gt;         p2.h = tag &lt;br&gt;  &lt;br&gt;     p2.b = self.finalize( &lt;br&gt;         'slide-%03d.png' % (slide_number)) &lt;br&gt;  &lt;br&gt;     return p2 &lt;br&gt; " id="1469" linkTypes="1" links="1446" title="add_at_url_final_output_file" />
<node body="def add_image_directive (self,p,slide_number): &lt;br&gt;  &lt;br&gt;     '''Add an image directive in p if it is not there.''' &lt;br&gt;  &lt;br&gt;     s = '.. image:: slide-%03d.png' % (slide_number) &lt;br&gt;  &lt;br&gt;     if p.b.find(s) == -1: &lt;br&gt;         p.b = p.b.rstrip() + '\n\n%s\n\n' % (s) &lt;br&gt; " id="1470" linkTypes="1" links="1446" title="add_image_directive" />
<node body="def delete_at_url_built_slide_node (self,p): &lt;br&gt;  &lt;br&gt;     '''Delete any &quot;@url built slide&quot; node in p's children.''' &lt;br&gt;  &lt;br&gt;     trace = True &lt;br&gt;     tag = '@url built slide' &lt;br&gt;  &lt;br&gt;     for child in p.children(): &lt;br&gt;         if self.match(child,tag): &lt;br&gt;             if trace: g.es('del %s in %s' % (tag,p.h)) &lt;br&gt;             child.doDelete() &lt;br&gt;             break &lt;br&gt; " id="1471" linkTypes="1" links="1446" title="delete_at_url_built_slide_node" />
<node body="" id="1472" linkTypes="1" links="1451" title="Urgent" />
<node body="" id="1473" linkTypes="1" links="1451" title="Important" />
<node body="" id="1474" linkTypes="1" links="1451" title="Soon" />
<node body="" id="1475" linkTypes="1" links="1451" title="Whenever" />
<node body="" id="1476" linkTypes="3" links="1526" title="2009" />
<node body="" id="1477" linkTypes="1" links="1452" title="2010" />
<node body="" id="1478" linkTypes="1" links="1453" title="Urgent" />
<node body="" id="1479" linkTypes="1" links="1453" title="Important" />
<node body="" id="1480" linkTypes="1" links="1453" title="Soon" />
<node body="" id="1481" linkTypes="1" links="1453" title="Whenever" />
<node body="" id="1482" linkTypes="3" links="1527" title="2009" />
<node body="" id="1483" linkTypes="1" links="1454" title="2010" />
<node body="" id="1484" linkTypes="1" links="1455" title="Urgent" />
<node body="" id="1485" linkTypes="1" links="1455" title="Important" />
<node body="" id="1486" linkTypes="1" links="1455" title="Soon" />
<node body="" id="1487" linkTypes="1" links="1455" title="Whenever" />
<node body="" id="1488" linkTypes="3 3 3 3 3 3 3 3" links="1528 1529 1530 1531 1532 1533 1534 1535" title="2009" />
<node body="" id="1489" linkTypes="1" links="1456" title="2010" />
<node body="" id="1490" linkTypes="1" links="1457" title="Urgent" />
<node body="" id="1491" linkTypes="1" links="1457" title="Important" />
<node body="" id="1492" linkTypes="1" links="1457" title="Soon" />
<node body="" id="1493" linkTypes="1" links="1457" title="Whenever" />
<node body="" id="1494" linkTypes="3 3 3 3 3 3 3 3" links="1536 1537 1538 1539 1540 1541 1542 1543" title="2009" />
<node body="" id="1495" linkTypes="1" links="1458" title="2010" />
<node body="1. Make Leo tutorials.  The world is waiting. &lt;br&gt;  &lt;br&gt; 2. Pay phone bill or the world will never know. &lt;br&gt; " id="1496" linkTypes="1" links="1459" title="Urgent" />
<node body="" id="1497" linkTypes="1" links="1459" title="Important" />
<node body="" id="1498" linkTypes="1" links="1459" title="Soon" />
<node body="" id="1499" linkTypes="1" links="1459" title="Whenever" />
<node body="" id="1500" linkTypes="3 3 3 3 3 3 3 3" links="1544 1545 1546 1547 1548 1549 1550 1551" title="2009" />
<node body="" id="1501" linkTypes="1" links="1460" title="2010" />
<node body="1. Make Leo tutorials.  The world is waiting. &lt;br&gt;  &lt;br&gt; 2. Pay phone bill or the world will never know. &lt;br&gt; " id="1502" linkTypes="1" links="1461" title="Urgent" />
<node body="" id="1503" linkTypes="1" links="1461" title="Important" />
<node body="" id="1504" linkTypes="1" links="1461" title="Soon" />
<node body="" id="1505" linkTypes="1" links="1461" title="Whenever" />
<node body="" id="1506" linkTypes="3 3 3 3 3 3 3 3" links="1552 1553 1554 1555 1556 1557 1558 1559" title="2009" />
<node body="" id="1507" linkTypes="1" links="1462" title="2010" />
<node body="1. Make Leo tutorials.  The world is waiting. &lt;br&gt;  &lt;br&gt; 2. Pay phone bill or the world will never know. &lt;br&gt; " id="1508" linkTypes="1" links="1463" title="Urgent" />
<node body="" id="1509" linkTypes="1" links="1463" title="Important" />
<node body="" id="1510" linkTypes="1" links="1463" title="Soon" />
<node body="" id="1511" linkTypes="1" links="1463" title="Whenever" />
<node body="" id="1512" linkTypes="3 3 3 3 3 3 3 3" links="1560 1561 1562 1563 1564 1565 1566 1567" title="2009" />
<node body="" id="1513" linkTypes="1" links="1464" title="2010" />
<node body="1. Make Leo tutorials.  The world is waiting. &lt;br&gt;  &lt;br&gt; 2. Pay phone bill or the world will never know. &lt;br&gt; " id="1514" linkTypes="1" links="1465" title="Urgent" />
<node body="" id="1515" linkTypes="1" links="1465" title="Important" />
<node body="" id="1516" linkTypes="1" links="1465" title="Soon" />
<node body="" id="1517" linkTypes="1" links="1465" title="Whenever" />
<node body="" id="1518" linkTypes="3 3 3 3 3 3 3 3" links="1568 1569 1570 1571 1572 1573 1574 1575" title="2009" />
<node body="" id="1519" linkTypes="1" links="1466" title="2010" />
<node body="1. Make Leo tutorials.  The world is waiting. &lt;br&gt;  &lt;br&gt; 2. Pay phone bill or the world will never know. &lt;br&gt; " id="1520" linkTypes="1" links="1467" title="Urgent" />
<node body="" id="1521" linkTypes="1" links="1467" title="Important" />
<node body="" id="1522" linkTypes="1" links="1467" title="Soon" />
<node body="" id="1523" linkTypes="1" links="1467" title="Whenever" />
<node body="" id="1524" linkTypes="3 3 3 3 3 3 3 3" links="1576 1577 1578 1579 1580 1581 1582 1583" title="2009" />
<node body="" id="1525" linkTypes="1" links="1468" title="2010" />
<node body="" id="1526" linkTypes="1" links="1476" title="Jan 1" />
<node body="" id="1527" linkTypes="1" links="1482" title="Jan 1" />
<node body="" id="1528" linkTypes="1" links="1488" title="Aug" />
<node body="" id="1529" linkTypes="1" links="1488" title="Jul" />
<node body="" id="1530" linkTypes="1" links="1488" title="Jun" />
<node body="" id="1531" linkTypes="1" links="1488" title="May" />
<node body="" id="1532" linkTypes="1" links="1488" title="Apr" />
<node body="" id="1533" linkTypes="1" links="1488" title="Mar" />
<node body="" id="1534" linkTypes="1" links="1488" title="Feb" />
<node body="" id="1535" linkTypes="1" links="1488" title="Jan" />
<node body="" id="1536" linkTypes="1" links="1494" title="Aug" />
<node body="" id="1537" linkTypes="1" links="1494" title="Jul" />
<node body="" id="1538" linkTypes="1" links="1494" title="Jun" />
<node body="" id="1539" linkTypes="1" links="1494" title="May" />
<node body="" id="1540" linkTypes="1" links="1494" title="Apr" />
<node body="" id="1541" linkTypes="1" links="1494" title="Mar" />
<node body="" id="1542" linkTypes="1" links="1494" title="Feb" />
<node body="" id="1543" linkTypes="1" links="1494" title="Jan" />
<node body="" id="1544" linkTypes="1" links="1500" title="Aug" />
<node body="" id="1545" linkTypes="1" links="1500" title="Jul" />
<node body="" id="1546" linkTypes="1" links="1500" title="Jun" />
<node body="" id="1547" linkTypes="1" links="1500" title="May" />
<node body="" id="1548" linkTypes="1" links="1500" title="Apr" />
<node body="" id="1549" linkTypes="1" links="1500" title="Mar" />
<node body="" id="1550" linkTypes="1" links="1500" title="Feb" />
<node body="" id="1551" linkTypes="1" links="1500" title="Jan" />
<node body="" id="1552" linkTypes="1" links="1506" title="Aug" />
<node body="" id="1553" linkTypes="1" links="1506" title="Jul" />
<node body="" id="1554" linkTypes="1" links="1506" title="Jun" />
<node body="" id="1555" linkTypes="1" links="1506" title="May" />
<node body="" id="1556" linkTypes="1" links="1506" title="Apr" />
<node body="" id="1557" linkTypes="1" links="1506" title="Mar" />
<node body="" id="1558" linkTypes="1" links="1506" title="Feb" />
<node body="" id="1559" linkTypes="1" links="1506" title="Jan" />
<node body="" id="1560" linkTypes="1" links="1512" title="Aug" />
<node body="" id="1561" linkTypes="1" links="1512" title="Jul" />
<node body="" id="1562" linkTypes="1" links="1512" title="Jun" />
<node body="" id="1563" linkTypes="1" links="1512" title="May" />
<node body="" id="1564" linkTypes="1" links="1512" title="Apr" />
<node body="" id="1565" linkTypes="1" links="1512" title="Mar" />
<node body="" id="1566" linkTypes="1" links="1512" title="Feb" />
<node body="" id="1567" linkTypes="1" links="1512" title="Jan" />
<node body="" id="1568" linkTypes="1" links="1518" title="Aug" />
<node body="" id="1569" linkTypes="1" links="1518" title="Jul" />
<node body="" id="1570" linkTypes="1" links="1518" title="Jun" />
<node body="" id="1571" linkTypes="1" links="1518" title="May" />
<node body="" id="1572" linkTypes="1" links="1518" title="Apr" />
<node body="" id="1573" linkTypes="1" links="1518" title="Mar" />
<node body="" id="1574" linkTypes="1" links="1518" title="Feb" />
<node body="" id="1575" linkTypes="1" links="1518" title="Jan" />
<node body="" id="1576" linkTypes="1" links="1524" title="Aug" />
<node body="" id="1577" linkTypes="1" links="1524" title="Jul" />
<node body="" id="1578" linkTypes="1" links="1524" title="Jun" />
<node body="" id="1579" linkTypes="1" links="1524" title="May" />
<node body="" id="1580" linkTypes="1" links="1524" title="Apr" />
<node body="" id="1581" linkTypes="1" links="1524" title="Mar" />
<node body="" id="1582" linkTypes="1" links="1524" title="Feb" />
<node body="" id="1583" linkTypes="1" links="1524" title="Jan" />
</network>